<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Album Cover Mosaic Builder</title>
    <script>
        /* ARCHIVED CODE - Automatic redirect disabled per user request
         * To re-enable: uncomment the code below
         * 
        // Redirect desktop devices to desktop version
        (function() {
            // Check URL parameters first (for testing)
            const urlParams = new URLSearchParams(window.location.search);
            const forceMobile = urlParams.get('mobile') === 'true';
            
            if (forceMobile) {
                return; // Stay on mobile if forced
            }
            
            // Detect if device is desktop (not mobile)
            function isDesktopDevice() {
                // Check screen width
                if (window.innerWidth > 1024) {
                    // Check user agent to make sure it's not a mobile device with large screen
                    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
                    const isMobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
                    
                    // If screen is large AND not a mobile user agent, it's desktop
                    if (!isMobileUA) {
                        return true;
                    }
                }
                return false;
            }
            
            // Redirect desktop devices to desktop version
            if (isDesktopDevice()) {
                window.location.href = '/desktop/';
            }
        })();
        */
        
        // Immediately scroll to top when page loads (mobile optimization)
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }
        window.scrollTo(0, 0);
        
        // Responsive resize detection - switch to desktop if window becomes large
        (function() {
            const BREAKPOINT = 1024;
            
            // Check if device is actually a mobile device (by user agent)
            function isRealMobileDevice() {
                const userAgent = navigator.userAgent || navigator.vendor || window.opera;
                return /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
            }
            
            // Check and redirect function
            function checkAndRedirect() {
                // Real mobile devices always stay on mobile
                if (isRealMobileDevice()) {
                    console.log('üì± Real mobile device detected, staying on mobile');
                    return;
                }
                
                const currentWidth = window.innerWidth;
                console.log(`üîç Current window width: ${currentWidth}px, breakpoint: ${BREAKPOINT}px`);
                
                // If window is large enough, switch to desktop
                if (currentWidth >= BREAKPOINT) {
                    console.log('üñ•Ô∏è Window width >= 1024px, redirecting to desktop...');
                    window.location.href = '/desktop.html';
                }
            }
            
            // Check immediately on page load
            checkAndRedirect();
            
            // Debounce function to prevent too many redirects
            let resizeTimeout;
            function debounceResize(callback, delay) {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(callback, delay);
            }
            
            // Add resize event listener
            window.addEventListener('resize', function() {
                console.log('üìê Window resized, checking width...');
                debounceResize(checkAndRedirect, 300); // Reduced to 300ms for faster response
            });
            
            // Also check on orientation change (for tablets)
            window.addEventListener('orientationchange', function() {
                setTimeout(checkAndRedirect, 100);
            });
        })();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Load heic2any library for HEIC/HEIF conversion -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js" 
            onerror="console.error('Failed to load heic2any from primary CDN')"></script>
    <!-- Fallback CDN -->
    <script>
        // Wait a bit and check if heic2any loaded, if not try alternative
        setTimeout(() => {
            if (typeof heic2any === 'undefined' && typeof window !== 'undefined') {
                console.warn('heic2any not loaded from primary CDN, trying alternative...');
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/heic2any@0.0.4/dist/heic2any.min.js';
                script.onerror = () => console.error('Failed to load heic2any from fallback CDN');
                document.head.appendChild(script);
            }
        }, 500);
    </script>
    <script>
        // Only load shopifyCart.js if not using file:// protocol
        if (window.location.protocol !== 'file:') {
            const script = document.createElement('script');
            script.src = '/assets/js/shopifyCart.js';
            script.onerror = function() {
                console.warn('Shopify Cart script failed to load - continuing without it');
            };
            document.head.appendChild(script);
        } else {
            console.log('‚ö†Ô∏è File:// protocol detected - skipping shopifyCart.js');
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            background: #FFFBF5;
            min-height: 100vh;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        html {
            overflow-x: hidden;
        }

        .main-container {
            display: flex;
            min-height: 100vh;
            max-width: 100vw;
            overflow-x: hidden;
            margin: 0 auto;
        }

        /* Left Panel - 3D Viewer */
        .viewer-panel {
            flex: 1;
            min-width: 0;
            background: #FFFBF5;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: visible;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #FFF8F0;
            border-right: 1px solid #e0e0e0;
            min-height: 600px; /* ensure visible height when shown */
        }

        #canvas-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* Inline editor panel that replaces the 3D view initially */
        #editor-panel {
            flex: 1;
            padding: 20px 24px;
            overflow: visible;
            background: #FFFBF5;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .viewer-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .viewer-controls.stopped {
            display: none;
        }

        .viewer-btn {
            background: #E0E0E0;
            border: 1px solid #333333;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: none;
            font-size: 14px;
            transition: all 0.2s;
            font-weight: normal;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .viewer-btn:hover {
            background: #d0d0d0;
        }

        .viewer-btn.icon-only {
            padding: 10px;
            font-size: 18px;
        }

        .placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #333333;
            font-size: 16px;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .placeholder-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        /* Right Panel - Controls */
        .control-panel {
            flex: 0 0 450px;
            min-width: 450px;
            background: #FFFBF5;
            padding: 40px;
            overflow: visible;
        }
        
        /* Lock scrolling in Shopify embedded context - prevent free scrolling */
        body.shopify-embedded, html.shopify-embedded {
            overflow: hidden !important;
            height: 100vh !important;
            position: fixed !important;
            width: 100% !important;
        }
        
        .main-container.shopify-embedded {
            height: 100vh !important;
            overflow: hidden !important;
            position: relative !important;
        }
        
        /* Prevent scrolling on viewer and control panels in Shopify */
        .viewer-panel.shopify-embedded,
        .control-panel.shopify-embedded {
            overflow: hidden !important;
            height: 100vh !important;
        }

        .title {
            font-size: 32px;
            font-weight: normal;
            margin-bottom: 10px;
            color: #E87D3E;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .price {
            font-size: 20px;
            color: #333333;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .section {
            margin-bottom: 30px;
            width: 100%;
        }
        
        /* Reduce spacing for grid size section before action buttons */
        #size-panel {
            margin-bottom: 5px;
        }
        
        /* Reduce spacing for upload panel */
        #upload-panel {
            margin-top: 0;
        }

        .section:not(.collapsible-section) {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .section-label {
            font-size: 13px;
            font-weight: normal;
            color: #FF6B35;
            margin-bottom: 12px;
            text-transform: none;
            letter-spacing: 0;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            text-align: center;
            width: 100%;
        }

        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 12px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
            margin-bottom: 15px;
        }

        .upload-area:hover {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-area.has-file {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-icon {
            font-size: 40px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .upload-text {
            font-size: 14px;
            color: #333333;
            margin-bottom: 5px;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .upload-subtext {
            font-size: 12px;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .file-input {
            display: none;
        }
        
        /* Ensure labels work properly on touch devices */
        label[for="png-input"] {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        label[for="png-input"]:active {
            opacity: 0.7;
        }

        .grid-options {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            width: 100%;
        }

        .grid-btn {
            flex: 1;
            padding: 12px;
            border: 1px solid #333333;
            background: #E0E0E0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: normal;
            color: #333333;
            transition: all 0.2s;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            min-width: 0;
            box-sizing: border-box;
        }

        .grid-btn.active {
            background: #333333;
            color: #FFFFFF;
            border-color: #333333;
        }

        .grid-btn:hover:not(.active) {
            background: #d0d0d0;
        }

        /* Top Action Buttons Bar */
        .top-action-buttons {
            display: flex;
            gap: 0;
            margin: 5px 0;
            justify-content: space-around;
            border-top: 1px solid #e0e0e0;
            border-bottom: 1px solid #e0e0e0;
            padding: 16px 0;
        }

        .top-action-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px 4px;
            border: none;
            background: transparent;
            color: #666666;
            font-size: 12px;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            text-align: center;
        }

        .top-action-btn:hover {
            color: #333333;
        }

        .top-action-btn.active {
            color: #000000;
        }

        .top-action-btn .btn-icon {
            font-size: 24px;
            margin-bottom: 6px;
            line-height: 1;
            color: inherit;
        }

        .top-action-btn .btn-text {
            font-size: 12px;
            line-height: 1.2;
            color: inherit;
        }

        /* Collapsible Sections */
        .collapsible-section {
            display: none !important;
        }

        .collapsible-section.active {
            display: flex !important;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .color-palette {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            width: 100%;
            justify-content: space-between;
        }

        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            border: 3px solid #333333;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #333333;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 30px;
            width: 100%;
        }

        .btn {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #333333;
            border-radius: 6px;
            font-size: 14px;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s;
            background: #E0E0E0;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            width: 100%;
            box-sizing: border-box;
        }

        .btn-primary {
            background: #333333;
            color: #FFFFFF;
            border: 1px solid #333333;
        }

        .btn-primary:hover:not(:disabled) {
            background: #444444;
        }

        .btn-secondary {
            background: #333333;
            color: #FFFFFF;
            border: 1px solid #333333;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #444444;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            display: none;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: #0c5460;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .info-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 13px;
            color: #856404;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .panel-title {
            font-size: 24px;
            font-weight: normal;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            color: #E87D3E;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #999;
        }

        .close-btn:hover {
            color: #333;
        }

        .editor-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            text-align: center;
            margin-bottom: 0;
        }

        .canvas-label {
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 10px;
            color: #E87D3E;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .editor-canvas {
            max-width: 100%;
            width: 100%;
            aspect-ratio: 1 / 1;
            height: auto;
            border-radius: 10px;
            border: 2px solid #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: #ffffff !important;
            display: block;
            margin: 0 auto;
            object-fit: contain;
        }

        #png-preview img { background: #ffffff !important; }

        .slider-control {
            margin-bottom: 20px;
            width: 100%;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: normal;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
            border: none;
        }

        .editor-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-shrink: 0;
            margin-top: auto;
        }

        /* Toggle Switch Styling */
        #stand-toggle + span,
        #addon-mounting-toggle + span {
            background-color: #ccc;
        }

        #stand-toggle:checked + span,
        #addon-mounting-toggle:checked + span {
            background-color: #2d5016;
        }

        #stand-toggle + span:before,
        #addon-mounting-toggle + span:before {
            content: "";
            position: absolute;
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }

        #stand-toggle:checked + span:before,
        #addon-mounting-toggle:checked + span:before {
            content: "";
            position: absolute;
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
            transform: translateX(20px);
        }

        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
                width: 100%;
                margin: 0;
                padding: 0;
            }

            .control-panel {
                width: 100%;
                max-width: 100%;
                padding-left: 20px;
                padding-right: 20px;
                padding-top: 20px;
                padding-bottom: 20px;
                margin: 0;
                min-width: 0;
                flex: 1 1 auto;
                align-items: center;
            }

            #canvas-container {
                height: 400px;
            }

            .editor-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Mobile portrait view - ensure equal padding and centering */
        @media (max-width: 768px) and (orientation: portrait) {
            .control-panel {
                padding-left: 20px;
                padding-right: 20px;
                padding-top: 20px;
                padding-bottom: 20px;
                width: 100%;
                max-width: 100%;
                margin: 0;
                align-items: center;
            }

            .section {
                width: 100%;
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .top-action-buttons {
                width: 100%;
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                justify-content: center;
            }

            .section-label {
                text-align: center;
                width: 100%;
            }
        }

        /* iPhone 12 Pro and similar sizes (390px width) */
        @media (max-width: 428px) {
            .control-panel {
                padding-left: 20px;
                padding-right: 20px;
                padding-top: 20px;
                padding-bottom: 20px;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin: 0;
                align-items: center;
            }

            .section {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .top-action-buttons {
                width: 100%;
                max-width: 100%;
                margin-left: auto;
                margin-right: auto;
                box-sizing: border-box;
                display: flex;
                justify-content: center;
            }

            .grid-options {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                justify-content: center;
            }

            #png-preview {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                justify-content: center;
            }

            #crop-container {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin-left: auto;
                margin-right: auto;
            }

            .section-label {
                text-align: center;
                width: 100%;
                margin-left: auto;
                margin-right: auto;
            }
        }

        /* Smaller phones (iPhone SE, etc. - 375px width) */
        @media (max-width: 375px) {
            .control-panel {
                padding-left: 15px;
                padding-right: 15px;
                padding-top: 15px;
                padding-bottom: 15px;
            }
        }

        /* Very small phones (320px width) */
        @media (max-width: 320px) {
            .control-panel {
                padding-left: 10px;
                padding-right: 10px;
                padding-top: 10px;
                padding-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Left Panel: Editor (initial) and 3D Viewer -->
        <div class="viewer-panel">
            <!-- Inline Editor Panel (shown first) -->
            <div id="editor-panel" style="display: none;">
                <div class="panel-header">
                    <h2 class="panel-title" id="mobile-panel-title">Edit Your Photo</h2>
                </div>
                <div style="margin-top:12px;">
                    <div class="canvas-wrapper">
                        <div class="canvas-label" id="mobile-canvas-label" style="display: none;">Processed (Posterized)</div>
                        <div style="position: relative; display: inline-block; width: 100%;">
                            <canvas id="processed-canvas" class="editor-canvas" style="max-width:100%; width:100%; aspect-ratio:1/1; cursor: crosshair; touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;"></canvas>
                        </div>
                        <div style="display: flex; flex-direction: row; gap: 5px; justify-content: space-between; align-items: center; margin-top: 10px; margin-bottom: 0; width: 100%;">
                            <div style="display: flex; flex-direction: row; gap: 5px;">
                                <button onclick="zoomInProcessed()" style="padding: 0; margin: 0; font-size: 18px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; width: 40px; height: 40px; min-width: 40px; max-width: 40px; min-height: 40px; max-height: 40px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; box-sizing: border-box;" title="Zoom In">+</button>
                                <button onclick="zoomOutProcessed()" style="padding: 0; margin: 0; font-size: 18px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; width: 40px; height: 40px; min-width: 40px; max-width: 40px; min-height: 40px; max-height: 40px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; box-sizing: border-box;" title="Zoom Out">‚àí</button>
                                <button onclick="resetZoomProcessed()" id="processed-reset-btn" style="padding: 0; margin: 0; font-size: 18px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; width: 40px; height: 40px; min-width: 40px; max-width: 40px; min-height: 40px; max-height: 40px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; box-sizing: border-box;" title="Reset View">‚ñ°</button>
                            </div>
                            <button onclick="show3DView()" style="padding: 12px 16px; margin: 0; font-size: 14px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; white-space: nowrap; flex-shrink: 0; font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace; font-weight: normal;" title="View in 3D">View in 3D</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3D Viewer (hidden initially) -->
            <div id="canvas-container" style="display:none;">
                <div class="viewer-controls">
                    <button class="viewer-btn" onclick="showEditorPanel()" id="edit-photo-btn">Edit Photo</button>
                    <button class="viewer-btn icon-only" onclick="resetCamera()" title="Reset View">‚Ü∫</button>
                </div>
                <div id="three-placeholder" class="placeholder">
                    <div class="placeholder-icon">‚ñ°</div>
                    <div>Upload an STL file to preview your 3D model</div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Controls -->
        <div class="control-panel">
            <!-- Initial Upload Box (shown before image upload) -->
            <label for="png-input" id="initial-upload-box" style="width: 100%; padding: 40px 20px; background: #fafafa; border: 2px dashed #d0d0d0; border-radius: 8px; margin-bottom: 20px; text-align: center; cursor: pointer; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 200px; -webkit-tap-highlight-color: transparent; touch-action: manipulation;">
                <div style="font-size: 32px; color: #999; margin-bottom: 16px;">‚Üë</div>
                <div style="font-size: 14px; color: #666; font-family: 'Courier New', monospace; margin-bottom: 8px;">Upload an image to convert to brick art</div>
                <div style="font-size: 12px; color: #666; font-family: 'Courier New', monospace;">Will be initially set to 32x32</div>
            </label>
            
            <!-- Upload PNG Section with Cropper (appears above buttons) -->
            <div class="section" id="upload-panel" style="display: none;">
                <div class="section-label" id="mobile-section-upload" style="margin-bottom: 4px;">Uploaded Image</div>
                <label for="png-input" class="upload-area" id="png-upload-area" style="margin-bottom: 0; padding: 8px; cursor: pointer; -webkit-tap-highlight-color: transparent; touch-action: manipulation; display: block;">
                    <div class="upload-icon" style="font-size: 20px; margin-bottom: 4px;">üñºÔ∏è</div>
                    <div class="upload-text" id="png-upload-text" style="font-size: 12px; margin-bottom: 2px;">Choose image file...</div>
                    <div class="upload-subtext" id="png-upload-subtext" style="font-size: 10px;">Will be resized to 75√ó75 pixels</div>
                </label>
                
                <!-- Divider line -->
                <div style="width: 100%; height: 1px; background: #e0e0e0; margin: 5px 0 0 0;"></div>
                
                <!-- Crop Buttons - Always visible when image is uploaded -->
                <div id="crop-buttons" style="display: none; margin-top: 8px; text-align: right;">
                    <button class="btn" id="show-cropper-btn" onclick="showCropper()" style="width: auto; padding: 6px 12px; font-size: 12px; background: #E0E0E0; color: #333333; border: 1px solid #333333; display: inline-block;">
                        Show Cropper
                    </button>
                    <button class="btn" id="hide-cropper-btn" onclick="hideCropper()" style="width: auto; padding: 6px 12px; font-size: 12px; background: #E0E0E0; color: #333333; border: 1px solid #333333; display: none;">
                        Hide Cropper ^
                    </button>
                </div>
                
                <!-- PNG Preview with Crop Tool -->
                <div id="png-preview" style="display: none; text-align: center; margin-top: 15px; width: 100%;">
                    <div id="crop-container" style="position: relative; display: inline-block; max-width: 400px; width: 100%; margin: 0 auto;">
                        <img id="png-preview-img" style="width: 100%; max-width: 400px; height: auto; object-fit: contain; display: block; margin: 0 auto; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;" />
                        <canvas id="crop-canvas" style="position: absolute; top: 0; left: 0; pointer-events: auto; display: none; border: none; background: transparent; z-index: 10; touch-action: none;"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Panels (appear above buttons) -->
            <!-- Grid Size (Collapsible) -->
            <div class="section collapsible-section" id="size-panel">
                <div class="section-label" style="display: flex; align-items: center; justify-content: space-between;">
                    <span id="mobile-section-grid">2. Select Grid Size</span>
                    <button id="mobile-size-guide-btn" onclick="toggleSizeGuide()" style="background: transparent; border: 1px solid #333; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; font-family: inherit; display: flex; align-items: center; gap: 4px;">
                        <span style="filter: grayscale(100%);">üìè</span>
                        <span id="mobile-size-guide-btn-text" style="color: #E87D3E;">Size Guide</span>
                        <span id="mobile-size-guide-chevron" style="color: #E87D3E;">‚ñº</span>
                    </button>
                </div>
                
                <!-- Inline Size Guide Dropdown -->
                <div id="size-guide-dropdown" style="display: none; margin-bottom: 15px; padding: 15px; background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; width: 100%; box-sizing: border-box;">
                    <h3 id="mobile-size-guide-title" style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #333;">Size Guide</h3>
                    <div id="mobile-size-guide-content" style="font-size: 12px; line-height: 1.6; color: #666;">
                        <!-- Content will be loaded from JSON -->
                    </div>
                </div>
                
                <div class="grid-options">
                    <button class="grid-btn" data-size="48" id="mobile-grid-btn-48" onclick="selectGridSize(48)">48 √ó 48</button>
                    <button class="grid-btn active" data-size="75" id="mobile-grid-btn-75" onclick="selectGridSize(75)">75 √ó 75</button>
                    <button class="grid-btn" data-size="96" id="mobile-grid-btn-96" onclick="selectGridSize(96)">96 √ó 96</button>
                </div>
            </div>

            <!-- Image Adjustments (Collapsible) -->
            <div class="section collapsible-section" id="adjust-panel">
                <div class="section-label" id="mobile-section-adjustments">Image Adjustments</div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span id="mobile-slider-contrast-label">Contrast</span>
                        <span id="contrast-value">1.2</span>
                    </div>
                    <input type="range" class="slider" id="contrast-slider" min="0" max="3" step="0.1" value="1.2" />
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span id="mobile-slider-brightness-label">Brightness</span>
                        <span id="brightness-value">1.0</span>
                    </div>
                    <input type="range" class="slider" id="brightness-slider" min="0" max="3" step="0.1" value="1.0" />
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span id="mobile-slider-denoise-label">Denoise</span>
                        <span id="denoise-value">0.0</span>
                    </div>
                    <input type="range" class="slider" id="denoise-slider" min="0" max="1" step="0.1" value="0" />
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span id="mobile-slider-tones-label">Tones</span>
                        <span id="tones-value">4</span>
                    </div>
                    <input type="range" class="slider" id="tones-slider" min="2" max="4" step="1" value="4" />
                </div>
            </div>

            <!-- Painting (Collapsible) -->
            <div class="section collapsible-section" id="paint-panel">
                <div class="section-label" style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                    <button id="mobile-paint-mode-btn" onclick="togglePaintMode()" style="background: #E87D3E; border: 1px solid #E87D3E; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; font-family: inherit; display: flex; align-items: center; gap: 4px;">
                        <span style="color: #FFFFFF;">üñåÔ∏è Paint</span>
                    </button>
                    <span id="mobile-section-painting" style="color: #FF6B35;">Painting</span>
                    <button id="mobile-eraser-btn" onclick="toggleEraserMode()" style="background: transparent; border: 1px solid #333; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; font-family: inherit; display: flex; align-items: center; gap: 4px;">
                        <span>üßπ</span>
                        <span style="color: #333;">Eraser</span>
                    </button>
                </div>
                <div class="color-palette">
                    <div class="color-swatch selected" data-color="0,0,0" style="background: rgb(0,0,0); position: relative;" title="Black" onclick="selectPaintColor(0, 0, 0, this)">
                        <span id="mobile-color-black-title" style="position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #333; white-space: nowrap;">Black</span>
                    </div>
                    <div class="color-swatch" data-color="85,85,85" style="background: rgb(85,85,85); position: relative;" title="Dark Gray" onclick="selectPaintColor(85, 85, 85, this)">
                        <span id="mobile-color-darkgray-title" style="position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #333; white-space: nowrap;">Dark Gray</span>
                    </div>
                    <div class="color-swatch" data-color="170,170,170" style="background: rgb(170,170,170); position: relative;" title="Light Gray" onclick="selectPaintColor(170, 170, 170, this)">
                        <span id="mobile-color-lightgray-title" style="position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #333; white-space: nowrap;">Light Gray</span>
                    </div>
                    <div class="color-swatch" data-color="255,255,255" style="background: rgb(255,255,255); position: relative;" title="White" onclick="selectPaintColor(255, 255, 255, this)">
                        <span id="mobile-color-white-title" style="position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #333; white-space: nowrap;">White</span>
                    </div>
                </div>
                <div class="slider-control" style="margin-top: 15px;">
                    <div class="slider-label">
                        <span>Brush Size</span>
                        <span id="brush-size-value">1</span>
                    </div>
                    <input type="range" class="slider" id="brush-size-slider" min="1" max="10" step="1" value="1" />
                </div>
                <div id="undo-redo-buttons" style="display: none; margin-top: 15px; gap: 10px;" class="action-buttons">
                    <button class="btn" id="undo-btn" onclick="undoPaint()" style="flex: 1; background: #E0E0E0; color: #333333; border: 1px solid #333333;" disabled>‚Üê Undo</button>
                    <button class="btn" id="redo-btn" onclick="redoPaint()" style="flex: 1; background: #E0E0E0; color: #333333; border: 1px solid #333333;" disabled>Redo ‚Üí</button>
                </div>
                <button class="btn" onclick="resetProcessedImage()" style="width: 100%; margin-top: 10px; background: #E0E0E0; color: #333333; border: 1px solid #333333;">
                    Reset Image
                </button>
            </div>
            
            <!-- Top Action Buttons -->
            <div class="top-action-buttons" id="action-buttons-container" style="display: none;">
                <div class="top-action-btn" id="upload-btn" style="cursor: pointer; -webkit-tap-highlight-color: transparent; touch-action: manipulation; position: relative;">
                    <div class="btn-icon">‚Üë</div>
                    <div class="btn-text">Upload</div>
                    <input type="file" id="png-input-upload-btn" accept="image/*" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;" />
                </div>
                <button class="top-action-btn" id="size-btn" onclick="togglePanel('size')">
                    <div class="btn-icon">‚ñ°</div>
                    <div class="btn-text">Size</div>
                </button>
                <button class="top-action-btn" id="adjust-btn" onclick="togglePanel('adjust')">
                    <div class="btn-icon">‚ò∞</div>
                    <div class="btn-text">Adjust</div>
                </button>
                <button class="top-action-btn" id="paint-btn" onclick="togglePanel('paint')">
                    <div class="btn-icon">‚úé</div>
                    <div class="btn-text">Paint</div>
                </button>
            </div>
            <input type="file" id="png-input" class="file-input" accept="image/*" style="display: none;" />
        </div>

            <!-- Price Display Section -->
            <div class="section" id="price-display-section" style="margin-top: 5px; width: 100%; display: none; padding: 0 20px; box-sizing: border-box;">
                <!-- Price and Details Cards -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; width: 100%; align-items: stretch;">
                    <!-- Price Card -->
                    <div style="flex: 1; background: #f0f0f0; border-radius: 8px; box-sizing: border-box; display: flex; align-items: center; justify-content: center;">
                        <div id="main-price" style="font-size: 24px; font-weight: 600; color: #333; text-align: center; padding: 16px; width: 100%;">Price loading...</div>
                    </div>
                    <!-- Details Card -->
                    <div style="flex: 1; padding: 16px; background: #f0f0f0; border-radius: 8px; box-sizing: border-box; display: flex; align-items: center;">
                        <div style="font-size: 12px; color: #666; line-height: 1.6; text-align: left;">
                            <div><span id="mobile-label-dimensions">Dimensions:</span> <span id="price-dimensions">75 √ó 75</span></div>
                            <div><span id="addons-label">Add-ons:</span> <span id="addons-display">None</span></div>
                        </div>
                    </div>
                </div>
                
                <!-- Add to Cart Button -->
                <button id="add-to-cart-btn" style="width: 100%; padding: 16px; margin-bottom: 10px; background: #2d5016; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; text-transform: uppercase; box-sizing: border-box;">ADD TO CART</button>
                <button id="buy-now-btn" style="display: none; width: 100%; padding: 16px; margin-bottom: 20px; background: #2d5016; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; text-transform: uppercase; box-sizing: border-box;">BUY NOW</button>
                
                <!-- Stand Toggle -->
                <div id="stand-section" style="margin-bottom: 10px; width: 100%;">
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; background: #f9f9f9; border-radius: 6px; width: 100%; box-sizing: border-box;">
                        <div style="display: flex; align-items: center; flex: 1;">
                            <img id="stand-image" src="" alt="Stand" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 12px; display: none;">
                            <div style="flex: 1;">
                                <div id="mobile-stand-name" style="font-size: 14px; font-weight: 500; color: #333;">Stand</div>
                                <div id="stand-price-display" style="font-size: 12px; color: #666;">$10.00</div>
                            </div>
                        </div>
                        <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                            <input type="checkbox" id="stand-toggle" style="opacity: 0; width: 0; height: 0;" onchange="updateStandAndPrice()">
                            <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; border-radius: 24px; transition: .4s;"></span>
                        </label>
                    </div>
                </div>
                
                <!-- Add-ons Section -->
                <div id="addons-section" style="width: 100%;">
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; background: #f9f9f9; border-radius: 6px; width: 100%; box-sizing: border-box;">
                        <div style="display: flex; align-items: center; flex: 1;">
                            <img id="mounting-image" src="" alt="Wall Mounting Dots" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 12px; display: none;">
                            <div style="flex: 1;">
                                <div id="mobile-mounting-name" style="font-size: 14px; font-weight: 500; color: #333;">Nano Wall Mounting Dots (Pack of 8)</div>
                                <div id="addon-mounting-price" style="font-size: 12px; color: #666;">$5.99</div>
                            </div>
                        </div>
                        <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                            <input type="checkbox" id="addon-mounting-toggle" style="opacity: 0; width: 0; height: 0;" onchange="updateTotalPrice()">
                            <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; border-radius: 24px; transition: .4s;"></span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Status Message -->
        <div class="status-message" id="status-message"></div>

        <!-- Info Box -->
        <div class="info-box" style="background: transparent; border: none; padding: 15px; margin: 12px 0; text-align: left; max-width: 100%; box-sizing: border-box;">
            <div id="desktop-info-title" style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #333; text-align: left;">Custom Brick Mosaic Designer</div>
            <div id="desktop-info-description" style="font-size: 14px; line-height: 1.5; color: #666; margin-bottom: 8px; text-align: left;">
                Turn your favourite photos into stunning brick art‚Äîmade by you!
            </div>
            <div id="desktop-info-additional" style="font-size: 14px; line-height: 1.5; color: #666; text-align: left;">
                Bring your memories to life, one brick at a time. With our Custom Brick Mosaic Designer you can transform any image into a beautiful 3D printable mosaic.
            </div>
        </div>

        <!-- Directions Section -->
        <div style="padding: 15px; margin-top: 12px; background: transparent;">
            <div id="desktop-howto-title" style="font-size: 18px; font-weight: 600; margin-bottom: 12px; color: #333;">How to Use</div>
            <div id="desktop-howto-content" style="font-size: 14px; line-height: 1.6; color: #666;">
                <div style="margin-bottom: 10px;">
                    <strong style="color: #333; display: block; margin-bottom: 2px;">1. Upload Your Image</strong>
                    Click the "Upload" button and select a photo from your device. The image will be automatically processed.
                </div>
                <div style="margin-bottom: 10px;">
                    <strong style="color: #333; display: block; margin-bottom: 2px;">2. Adjust Size & Crop</strong>
                    Use the "Size" button to crop your image and choose your grid size (48√ó48, 75√ó75, or 96√ó96). Drag the blue crop box to select the area you want to use.
                </div>
                <div style="margin-bottom: 10px;">
                    <strong style="color: #333; display: block; margin-bottom: 2px;">3. Fine-Tune Adjustments</strong>
                    Click "Adjust" to modify brightness, contrast, and other settings to get the perfect look for your mosaic.
                </div>
                <div style="margin-bottom: 10px;">
                    <strong style="color: #333; display: block; margin-bottom: 2px;">4. Paint & Customize (Optional)</strong>
                    Use the "Paint" button to manually adjust individual colors and add your personal touch to the design.
                </div>
                <div style="margin-bottom: 10px;">
                    <strong style="color: #333; display: block; margin-bottom: 2px;">5. View in 3D</strong>
                    Click "View in 3D" to see your custom brick mosaic come to life. Rotate and zoom to explore your creation.
                </div>
                <div>
                    <strong style="color: #333; display: block; margin-bottom: 2px;">6. Proceed to Checkout</strong>
                    Once you're happy with your design, click "Proceed to Checkout" to order your custom brick mosaic.
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Backend URL Configuration
        // Handle file:// protocol (for local file testing)
        const isFileProtocol = window.location.protocol === 'file:';
        // Make BACKEND_URL globally accessible across script blocks
        window.BACKEND_URL = isFileProtocol
            ? null  // No backend when opening as file:// - works offline
            : (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
                ? 'http://localhost:5003'  // Local development on port 5003
                : 'https://rizepics.onrender.com'; // Production (Render) - matches admin panel
        const BACKEND_URL = window.BACKEND_URL; // Local reference for this script block
        
        // Helper function to get API URL - make globally accessible
        function getApiUrl(path) {
            const BACKEND_URL = window.BACKEND_URL || null;
            if (!BACKEND_URL) {
                // No backend available (file:// protocol or not configured)
                console.warn(`‚ö†Ô∏è No backend URL configured. API call to ${path} will fail.`);
                return null; // Return null to indicate no backend
            }
            const baseUrl = BACKEND_URL.replace(/\/$/, '');
            const cleanPath = path.startsWith('/') ? path : '/' + path;
            const fullUrl = baseUrl + cleanPath;
            console.log(`üîó API Call: ${fullUrl}`);
            return fullUrl;
        }
        // Make getApiUrl globally accessible
        window.getApiUrl = getApiUrl;
        
        // Log backend URL on load
        console.log('üöÄ Backend URL configured:', BACKEND_URL);
        console.log('üåê Current hostname:', window.location.hostname);
        
        // Shopify Configuration
        // Get Shopify store URL from URL parameters, current domain, or config
        const urlParams = new URLSearchParams(window.location.search);
        
        // Try multiple methods to detect Shopify store URL
        let shopifyStore = urlParams.get('shop');
        
        // Method 1: Check if we're on a Shopify domain
        if (!shopifyStore && window.location.hostname.includes('myshopify.com')) {
            shopifyStore = window.location.hostname;
            console.log('‚úÖ Detected Shopify store from domain:', shopifyStore);
        }
        
        // Method 2: Check if parent window is Shopify (for embedded apps)
        if (!shopifyStore && window.parent && window.parent.location.hostname.includes('myshopify.com')) {
            shopifyStore = window.parent.location.hostname;
            console.log('‚úÖ Detected Shopify store from parent window:', shopifyStore);
        }
        
        // Method 3: Check window.Shopify object
        if (!shopifyStore && (window.Shopify || window.parent.Shopify)) {
            const shopifyObj = window.Shopify || window.parent.Shopify;
            if (shopifyObj.shop) {
                shopifyStore = shopifyObj.shop;
                console.log('‚úÖ Detected Shopify store from Shopify object:', shopifyStore);
            }
        }
        
        // Method 4: Default fallback (user should configure this)
        if (!shopifyStore) {
            shopifyStore = 'your-store.myshopify.com'; // USER: Replace with your actual Shopify store
            console.warn('‚ö†Ô∏è Using default Shopify store. To configure: Add ?shop=your-store.myshopify.com to URL or update this default value.');
        }
        
        const SHOPIFY_STORE_URL = shopifyStore.startsWith('http') ? shopifyStore : `https://${shopifyStore}`;
        const SHOPIFY_PRODUCT_URL = `${SHOPIFY_STORE_URL}/products/3d-album-mosaic`; // Fallback URL
        
        console.log('üõí Shopify Store URL:', SHOPIFY_STORE_URL);
        
        // Initialize Shopify Cart Service
        let shopifyCart = null;
        // Check if we're in Shopify context (iframe, Shopify domain, or shopify param)
        const isInIframe = window.self !== window.top;
        const isShopifyDomain = window.location.hostname.includes('myshopify.com') || 
                               window.parent.location.hostname.includes('myshopify.com');
        const hasShopifyParam = urlParams.get('shopify') === 'true';
        
        if (hasShopifyParam || isInIframe || isShopifyDomain) {
            try {
                if (typeof ShopifyCartService !== 'undefined') {
                    const storeUrl = ShopifyCartService.getStoreUrl() || SHOPIFY_STORE_URL;
                    if (storeUrl && storeUrl !== 'https://your-store.myshopify.com') {
                        shopifyCart = new ShopifyCartService(storeUrl);
                        console.log('‚úÖ Shopify Cart Service initialized:', storeUrl);
                    } else {
                        console.warn('‚ö†Ô∏è Shopify store URL not configured');
                    }
                } else {
                    console.warn('‚ö†Ô∏è ShopifyCartService not loaded');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Shopify Cart Service initialization error:', error);
            }
        }
        
        // Shopify Variant IDs - Get from backend API or environment
        // These will be loaded from backend configuration
        let shopifyVariants = {
            48: null,  // Will be loaded from API
            75: null,
            96: null,
            stand: null,
            mounting: null
        };
        
        // Load Shopify variant IDs from backend
        async function loadShopifyVariants() {
            try {
                const response = await fetch(getApiUrl('/api/shopify/variants'));
                if (response.ok) {
                    const data = await response.json();
                    shopifyVariants = {
                        48: data.variant_48 || null,
                        75: data.variant_75 || null,
                        96: data.variant_96 || null,
                        stand: data.variant_stand || null,
                        mounting: data.variant_mounting || null
                    };
                    console.log('‚úÖ Shopify variants loaded:', shopifyVariants);
                    // Show Buy Now button if we have variants
                    const buyNowBtn = document.getElementById('buy-now-btn');
                    if (buyNowBtn && (shopifyVariants[48] || shopifyVariants[75] || shopifyVariants[96])) {
                        buyNowBtn.style.display = 'block';
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not load Shopify variants:', error);
            }
        }
        
        // Load variants on page load if in Shopify context
        const isInIframeForVariants = window.self !== window.top;
        const isShopifyDomainForVariants = window.location.hostname.includes('myshopify.com') || 
                                          window.parent.location.hostname.includes('myshopify.com');
        if (urlParams.get('shopify') === 'true' || isInIframeForVariants || isShopifyDomainForVariants) {
            loadShopifyVariants();
        }

        // Price management
        let prices = {};
        let productImages = {};
        let textContent = {};
        let selectedAddons = {
            mounting: false
        };
        let standSelected = false; // Default to stand OFF

        // Save prices to localStorage for persistence
        function savePrices() {
            try {
                localStorage.setItem('prices', JSON.stringify(prices));
                console.log('Prices saved to localStorage');
            } catch (e) {
                console.warn('Failed to save prices to localStorage:', e);
            }
        }

        // Load cached prices from localStorage
        function loadCachedPrices() {
            try {
                const cached = localStorage.getItem('prices');
                if (cached) {
                    prices = JSON.parse(cached);
                    console.log('Loaded cached prices from localStorage:', prices);
                    updatePriceDisplay();
                    return true;
                }
            } catch (e) {
                console.warn('Failed to load cached prices:', e);
            }
            return false;
        }

        // Load prices from API
        async function loadPrices() {
            // If no backend URL (file:// protocol), use defaults and cached data
            if (!BACKEND_URL) {
                console.log('‚ö†Ô∏è No backend URL - using default prices for file:// protocol');
                // Use default prices
                prices = {
                    '48x48': 39.99,
                    '75x75': 49.99,
                    '96x96': 59.99,
                    stand: 10.00,
                    wall_mounting_dots: 5.99
                };
                // Try to load cached prices
                loadCachedPrices();
                // Set default grid size
                selectedGridSize = 75;
                // Update UI
                document.querySelectorAll('.grid-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.size === '75') {
                        btn.classList.add('active');
                    }
                });
                updatePriceDisplay();
                // Try to load cached images
                loadCachedProductImages();
                return;
            }
            
            try {
                const url = getApiUrl('/api/prices?t=' + Date.now());
                if (!url) {
                    throw new Error('No backend URL configured');
                }
                console.log('üîó Loading prices from:', url);
                const response = await fetch(url, {
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                if (!response.ok) {
                    throw new Error(`Failed to fetch prices: ${response.status}`);
                }
                prices = await response.json();
                console.log('Prices loaded from admin:', prices);
                console.log('Price keys available:', Object.keys(prices));
                
                // Save prices to localStorage for persistence
                savePrices();
                
                // Ensure 75√ó75 is selected by default
                selectedGridSize = 75;
                
                await loadImages();
                await loadTextContent();
                
                // Ensure images are displayed after a short delay to ensure DOM is ready
                setTimeout(() => {
                    updateProductImages();
                }, 100);
                
                // Ensure 75√ó75 button is active
                document.querySelectorAll('.grid-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.size === '75') {
                        btn.classList.add('active');
                    }
                });
                
                // Update price display with 75√ó75 price after button is set
                updatePriceDisplay();
                
                // Force update price multiple times to ensure it's correct
                setTimeout(() => {
                    updatePriceDisplay();
                }, 50);
                setTimeout(() => {
                    updatePriceDisplay();
                }, 200);
                setTimeout(() => {
                    updatePriceDisplay();
                }, 500);
            } catch (error) {
                console.error('Failed to load prices:', error);
                // Try to use cached prices if API fails
                if (!loadCachedPrices()) {
                    // Use defaults if no cache
                    prices = {
                        '48x48': 39.99,
                        '75x75': 49.99,
                        '96x96': 59.99,
                        stand: 10.00,
                        wall_mounting_dots: 5.99
                    };
                    updatePriceDisplay();
                }
                // Also try to load cached images
                loadCachedProductImages();
            }
        }

        // Load text content from API
        async function loadTextContent() {
            // If no backend URL (file:// protocol), skip API call
            if (!BACKEND_URL) {
                console.log('‚ö†Ô∏è No backend URL - skipping text content load for file:// protocol');
                return;
            }
            
            try {
                const url = getApiUrl('/api/content?t=' + Date.now());
                if (!url) {
                    return; // No backend, skip
                }
                // Add cache-busting parameter to ensure fresh content
                const response = await fetch(url);
                textContent = await response.json();
                updateTextContent();
            } catch (error) {
                console.error('Failed to load text content:', error);
            }
        }
        
        // Periodically refresh content to pick up admin changes (only if backend available)
        if (BACKEND_URL) {
            setInterval(() => {
                loadTextContent();
            }, 5000); // Check every 5 seconds
        }

        // Update text content on page
        function updateTextContent() {
            // Upload area text
            if (textContent.upload_image_text) {
                const uploadText = document.getElementById('png-upload-text');
                if (uploadText) uploadText.textContent = textContent.upload_image_text;
            }
            if (textContent.upload_subtext) {
                const uploadSubtext = document.getElementById('png-upload-subtext');
                if (uploadSubtext) uploadSubtext.textContent = textContent.upload_subtext;
            }
            
            // STL files are pre-uploaded, no UI needed
            
            // Info box content (using mobile view text)
            if (textContent.info_title) {
                const titleEl = document.getElementById('desktop-info-title');
                if (titleEl) titleEl.textContent = textContent.info_title;
            }
            if (textContent.info_description) {
                const descEl = document.getElementById('desktop-info-description');
                if (descEl) descEl.textContent = textContent.info_description;
            }
            if (textContent.info_additional) {
                const addEl = document.getElementById('desktop-info-additional');
                if (addEl) addEl.textContent = textContent.info_additional;
            }
            
            // How to Use section
            if (textContent.howto_title) {
                const howtoTitleEl = document.getElementById('desktop-howto-title');
                if (howtoTitleEl) howtoTitleEl.textContent = textContent.howto_title;
            }
            if (textContent.howto_content) {
                const howtoContentEl = document.getElementById('desktop-howto-content');
                if (howtoContentEl) {
                    // Parse the howto_content and format it with the step structure
                    const steps = textContent.howto_content.split('\n\n');
                    let formattedContent = '';
                    steps.forEach((step, index) => {
                        const lines = step.split('\n');
                        const title = lines[0];
                        const description = lines.slice(1).join(' ');
                        formattedContent += `
                            <div style="margin-bottom: 16px;">
                                <strong style="color: #333; display: block; margin-bottom: 4px;">${title}</strong>
                                ${description}
                            </div>
                        `;
                    });
                    howtoContentEl.innerHTML = formattedContent;
                }
            }
            
            // Mobile-specific text elements
            if (textContent.panel_title) {
                const el = document.getElementById('mobile-panel-title');
                if (el) el.textContent = textContent.panel_title;
            }
            if (textContent.canvas_label) {
                const el = document.getElementById('mobile-canvas-label');
                if (el) el.textContent = textContent.canvas_label;
            }
            if (textContent.section_upload) {
                const el = document.getElementById('mobile-section-upload');
                if (el) el.textContent = textContent.section_upload;
            }
            if (textContent.section_grid) {
                const el = document.getElementById('mobile-section-grid');
                if (el) el.textContent = textContent.section_grid;
            }
            if (textContent.section_adjustments) {
                const el = document.getElementById('mobile-section-adjustments');
                if (el) el.textContent = textContent.section_adjustments;
            }
            if (textContent.section_painting) {
                const el = document.getElementById('mobile-section-painting');
                if (el) el.textContent = textContent.section_painting;
            }
            if (textContent.grid_btn_48) {
                const el = document.getElementById('mobile-grid-btn-48');
                if (el) el.textContent = textContent.grid_btn_48;
            }
            if (textContent.grid_btn_75) {
                const el = document.getElementById('mobile-grid-btn-75');
                if (el) el.textContent = textContent.grid_btn_75;
            }
            if (textContent.grid_btn_96) {
                const el = document.getElementById('mobile-grid-btn-96');
                if (el) el.textContent = textContent.grid_btn_96;
            }
            if (textContent.slider_contrast_label) {
                const el = document.getElementById('mobile-slider-contrast-label');
                if (el) el.textContent = textContent.slider_contrast_label;
            }
            if (textContent.slider_brightness_label) {
                const el = document.getElementById('mobile-slider-brightness-label');
                if (el) el.textContent = textContent.slider_brightness_label;
            }
            if (textContent.slider_tones_label) {
                const el = document.getElementById('mobile-slider-tones-label');
                if (el) el.textContent = textContent.slider_tones_label;
            }
            if (textContent.slider_denoise_label) {
                const el = document.getElementById('mobile-slider-denoise-label');
                if (el) el.textContent = textContent.slider_denoise_label;
            }
            if (textContent.label_dimensions) {
                const el = document.getElementById('mobile-label-dimensions');
                if (el) el.textContent = textContent.label_dimensions;
            }
            if (textContent.stand_name) {
                const el = document.getElementById('mobile-stand-name');
                if (el) el.textContent = textContent.stand_name;
            }
            if (textContent.mounting_name) {
                const el = document.getElementById('mobile-mounting-name');
                if (el) el.textContent = textContent.mounting_name;
            }
            if (textContent.color_black_title) {
                const el = document.getElementById('mobile-color-black-title');
                if (el) el.textContent = textContent.color_black_title;
            }
            if (textContent.color_darkgray_title) {
                const el = document.getElementById('mobile-color-darkgray-title');
                if (el) el.textContent = textContent.color_darkgray_title;
            }
            if (textContent.color_lightgray_title) {
                const el = document.getElementById('mobile-color-lightgray-title');
                if (el) el.textContent = textContent.color_lightgray_title;
            }
            if (textContent.color_white_title) {
                const el = document.getElementById('mobile-color-white-title');
                if (el) el.textContent = textContent.color_white_title;
            }
        }

        // Save product images to localStorage for persistence
        function saveProductImages() {
            try {
                localStorage.setItem('productImages', JSON.stringify(productImages));
                console.log('Product images saved to localStorage');
            } catch (e) {
                console.warn('Failed to save product images to localStorage:', e);
            }
        }

        // Load cached product images from localStorage
        function loadCachedProductImages() {
            try {
                const cached = localStorage.getItem('productImages');
                if (cached) {
                    productImages = JSON.parse(cached);
                    console.log('Loaded cached product images from localStorage:', productImages);
                    updateProductImages();
                    return true;
                }
            } catch (e) {
                console.warn('Failed to load cached product images:', e);
            }
            return false;
        }
        
        // Save image state to localStorage for persistence across view switches
        function saveImageState(img, file) {
            try {
                console.log('üíæ Saving image state to localStorage...');
                
                // Convert image to DataURL for storage
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const imageDataURL = canvas.toDataURL('image/png');
                
                // Save image data
                const imageState = {
                    dataURL: imageDataURL,
                    width: img.width,
                    height: img.height,
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: file.type,
                    timestamp: Date.now()
                };
                
                localStorage.setItem('uploadedImageState', JSON.stringify(imageState));
                console.log('‚úÖ Image state saved to localStorage');
                return true;
            } catch (e) {
                console.warn('‚ö†Ô∏è Failed to save image state:', e);
                return false;
            }
        }
        
        // Restore image state from localStorage
        function restoreImageState() {
            try {
                console.log('üìÇ Checking for saved image state...');
                const saved = localStorage.getItem('uploadedImageState');
                if (!saved) {
                    console.log('üìÇ No saved image state found');
                    return false;
                }
                
                const imageState = JSON.parse(saved);
                console.log('üìÇ Found saved image state:', imageState.fileName);
                
                // Check if state is recent (within 24 hours)
                const age = Date.now() - imageState.timestamp;
                if (age > 24 * 60 * 60 * 1000) {
                    console.log('üìÇ Saved image state is too old, ignoring');
                    localStorage.removeItem('uploadedImageState');
                    return false;
                }
                
                // Restore image from DataURL
                const img = new Image();
                img.onload = () => {
                    console.log('‚úÖ Restored image from localStorage');
                    rawUploadedImage = img;
                    fullOriginalImage = img;
                    
                    // Hide upload box and show editor
                    const initialUploadBox = document.getElementById('initial-upload-box');
                    if (initialUploadBox) {
                        initialUploadBox.style.display = 'none';
                    }
                    
                    const editorPanel = document.getElementById('editor-panel');
                    if (editorPanel) {
                        editorPanel.style.display = 'block';
                    }
                    
                    const actionButtonsContainer = document.getElementById('action-buttons-container');
                    if (actionButtonsContainer) {
                        actionButtonsContainer.style.display = 'flex';
                    }
                    
                    const priceSection = document.getElementById('price-display-section');
                    if (priceSection) {
                        priceSection.style.display = 'block';
                    }
                    
                    // Process the restored image
                    try {
                        processImage();
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Error processing restored image:', error);
                    }
                };
                img.onerror = () => {
                    console.warn('‚ö†Ô∏è Failed to load restored image');
                    localStorage.removeItem('uploadedImageState');
                };
                img.src = imageState.dataURL;
                
                return true;
            } catch (e) {
                console.warn('‚ö†Ô∏è Failed to restore image state:', e);
                localStorage.removeItem('uploadedImageState');
                return false;
            }
        }

        // Load product images from API
        async function loadImages() {
            // If no backend URL (file:// protocol), use cached images only
            if (!BACKEND_URL) {
                console.log('‚ö†Ô∏è No backend URL - using cached images for file:// protocol');
                loadCachedProductImages();
                return;
            }
            
            try {
                const url = getApiUrl('/api/images?t=' + Date.now());
                if (!url) {
                    // No backend, use cached images
                    loadCachedProductImages();
                    return;
                }
                // Add cache-busting parameter to force reload
                const response = await fetch(url);
                const images = await response.json();
                console.log('Loaded images from server (raw):', images);
                
                // Convert relative image URLs to full backend URLs
                productImages = {};
                for (const [key, value] of Object.entries(images)) {
                    if (value && typeof value === 'string') {
                        // If it's a relative URL (starts with /), convert to full backend URL
                        if (value.startsWith('/')) {
                            productImages[key] = BACKEND_URL.replace(/\/$/, '') + value;
                        } else if (value.startsWith('http://') || value.startsWith('https://')) {
                            // Already a full URL, use as-is
                            productImages[key] = value;
                        } else {
                            // Relative path without leading slash, add backend URL
                            productImages[key] = BACKEND_URL.replace(/\/$/, '') + '/' + value;
                        }
                    } else {
                        productImages[key] = value;
                    }
                }
                console.log('Loaded images from server (converted):', productImages);
                // Save to localStorage for persistence
                saveProductImages();
                updateProductImages();
            } catch (error) {
                console.error('Failed to load images:', error);
                // If API fails, try to use cached images
                loadCachedProductImages();
            }
        }

        // Update product images display
        function updateProductImages() {
            console.log('Updating product images:', productImages);
            
            // Stand image
            const standImage = document.getElementById('stand-image');
            if (standImage) {
                if (productImages.stand) {
                    // Convert relative URL to full backend URL if needed
                    let imageUrl = productImages.stand;
                    if (!imageUrl.startsWith('http') && BACKEND_URL) {
                        // It's a relative URL, convert to full backend URL
                        const apiUrl = getApiUrl(imageUrl.startsWith('/') ? imageUrl : '/' + imageUrl);
                        if (apiUrl) {
                            imageUrl = apiUrl;
                        }
                    }
                    // Add cache-busting parameter to image URL
                    imageUrl = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
                    standImage.src = imageUrl;
                    standImage.style.display = 'block';
                    standImage.onerror = function() {
                        console.error('‚ùå Failed to load stand image from:', imageUrl);
                        standImage.style.display = 'none';
                    };
                    standImage.onload = function() {
                        console.log('‚úÖ Stand image loaded successfully:', imageUrl);
                    };
                } else {
                    console.log('‚ö†Ô∏è No stand image in productImages');
                    standImage.style.display = 'none';
                }
            }
            
            // Mounting dots image
            const mountingImage = document.getElementById('mounting-image');
            if (mountingImage) {
                if (productImages.wall_mounting_dots) {
                    // Convert relative URL to full backend URL if needed
                    let imageUrl = productImages.wall_mounting_dots;
                    if (!imageUrl.startsWith('http') && BACKEND_URL) {
                        // It's a relative URL, convert to full backend URL
                        const apiUrl = getApiUrl(imageUrl.startsWith('/') ? imageUrl : '/' + imageUrl);
                        if (apiUrl) {
                            imageUrl = apiUrl;
                        }
                    }
                    // Add cache-busting parameter to image URL
                    imageUrl = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
                    mountingImage.src = imageUrl;
                    mountingImage.style.display = 'block';
                    mountingImage.onerror = function() {
                        console.error('‚ùå Failed to load mounting image from:', imageUrl);
                        mountingImage.style.display = 'none';
                    };
                    mountingImage.onload = function() {
                        console.log('‚úÖ Mounting image loaded successfully:', imageUrl);
                    };
                } else {
                    console.log('‚ö†Ô∏è No wall_mounting_dots image in productImages');
                    mountingImage.style.display = 'none';
                }
            }
        }

        // Update price display based on selected grid size, stand, and addons
        async function updatePriceDisplay() {
            // Reload prices from admin API to ensure they're up-to-date
            try {
                const response = await fetch(getApiUrl('/api/prices?t=' + Date.now()), {
                    cache: 'no-cache'
                });
                if (response.ok) {
                    const freshPrices = await response.json();
                    // Only update if prices have changed
                    if (JSON.stringify(freshPrices) !== JSON.stringify(prices)) {
                        prices = freshPrices;
                        console.log('Prices refreshed from admin:', prices);
                        // Also reload images when prices are refreshed
                        await loadImages();
                    }
                }
            } catch (error) {
                console.error('Failed to refresh prices:', error);
                // Continue with cached prices if refresh fails
            }
            
            // Use 75√ó75 as default if no grid size is selected
            const gridSize = selectedGridSize || 75;
            const priceKey = `${gridSize}x${gridSize}`;
            
            // Get base price for the selected grid size (defaults to 75√ó75)
            // Try multiple key formats in case admin uses different format
            let basePrice = 0;
            if (prices) {
                // Try exact key first
                if (prices[priceKey] !== undefined && prices[priceKey] !== null) {
                    basePrice = parseFloat(prices[priceKey]) || 0;
                } 
                // Try 75x75 as fallback
                else if (prices['75x75'] !== undefined && prices['75x75'] !== null) {
                    basePrice = parseFloat(prices['75x75']) || 0;
                    console.log(`Price for ${priceKey} not found, using 75x75 price: $${basePrice}`);
                }
                // Try other possible formats
                else if (prices['75√ó75'] !== undefined && prices['75√ó75'] !== null) {
                    basePrice = parseFloat(prices['75√ó75']) || 0;
                }
                else {
                    console.warn('Prices loaded but grid size price not found. Grid size:', gridSize, 'Price key:', priceKey);
                    console.warn('Available price keys:', Object.keys(prices));
                    console.warn('Full prices object:', prices);
                }
            }
            
            // Calculate total with stand and addons
            let total = basePrice;
            
            // Add stand price if selected
            if (standSelected && prices && prices.stand !== undefined) {
                const standPrice = parseFloat(prices.stand) || 0;
                total += standPrice;
            }
            
            // Add addons (nano mounting dots)
            if (selectedAddons.mounting && prices && prices.wall_mounting_dots !== undefined) {
                const mountingPrice = parseFloat(prices.wall_mounting_dots) || 0;
                total += mountingPrice;
            }
            
            // Update main price
            const mainPriceEl = document.getElementById('main-price');
            if (mainPriceEl) {
                // Simple check: if prices object exists, show the price
                if (prices && typeof prices === 'object') {
                    // Always show the calculated price
                    mainPriceEl.textContent = `$${total.toFixed(2)}`;
                } else {
                    // Prices not loaded yet
                    mainPriceEl.textContent = 'Price loading...';
                }
            }
            
            // Update dimensions
            const dimensionsEl = document.getElementById('price-dimensions');
            
            if (dimensionsEl) {
                dimensionsEl.textContent = `${gridSize} √ó ${gridSize}`;
            }
            
            // Update add-ons display
            const addonsDisplayEl = document.getElementById('addons-display');
            if (addonsDisplayEl) {
                const addons = [];
                if (standSelected) {
                    addons.push('Stand');
                }
                if (selectedAddons.mounting) {
                    addons.push('Nano wall mounting dots');
                }
                addonsDisplayEl.textContent = addons.length > 0 ? addons.join(', ') : 'None';
            }
            
            // Update stand price display
            const standPriceEl = document.getElementById('stand-price-display');
            if (standPriceEl) {
                const standPrice = prices.stand || 0;
                standPriceEl.textContent = `$${standPrice.toFixed(2)}`;
            }
            
            // Update addons breakdown
            updateOrderBreakdown();
            
            // Update addon prices
            const mountingPriceEl = document.getElementById('addon-mounting-price');
            if (mountingPriceEl && prices.wall_mounting_dots !== undefined) {
                mountingPriceEl.textContent = `$${prices.wall_mounting_dots.toFixed(2)}`;
            }
        }

        // Update stand selection and total price
        function updateStandAndPrice() {
            const standToggle = document.getElementById('stand-toggle');
            standSelected = standToggle ? standToggle.checked : false;
            updatePriceDisplay();
            // Also ensure images are displayed
            updateProductImages();
        }

        // Update total price when addons change
        function updateTotalPrice() {
            const mountingToggle = document.getElementById('addon-mounting-toggle');
            
            selectedAddons.mounting = mountingToggle ? mountingToggle.checked : false;
            
            updatePriceDisplay();
            // Also ensure images are displayed
            updateProductImages();
        }

        // Update order breakdown display
        function updateOrderBreakdown() {
            const breakdownAddons = document.getElementById('breakdown-addons');
            
            if (breakdownAddons) {
                const addons = [];
                if (standSelected) {
                    addons.push('Stand');
                }
                if (selectedAddons.mounting) {
                    addons.push('Nano');
                }
                
                if (addons.length > 0) {
                    breakdownAddons.textContent = addons.join(', ');
                } else {
                    breakdownAddons.textContent = 'None';
                }
            }
        }

        let stlFile = null;
        let pngFile = null;
        let pngImage = null;
        let scene, camera, renderer, controls, currentMesh;
        let originalGeometry = null;
        let selectedGridSize = 75;
        let rawUploadedImage = null;
        let editorSettings = {
            contrast: 1.2,
            brightness: 1.0,
            pixelSize: 75,
            tones: 4,
            denoise: 0,
            blackPoint: 0,
            whitePoint: 255,
        };
        // Crop variables
        let cropperVisible = false;
        let cropperManuallyHidden = false; // Track if user manually hid the cropper
        let cropX = 0, cropY = 0, cropSize = 0;
        let cropInitialized = false; // Track if crop has ever been initialized
        let isDraggingCrop = false;
        let isResizingCrop = false;
        let resizeEdge = ''; // 'left', 'right', 'top', 'bottom', 'topleft', 'topright', 'bottomleft', 'bottomright'
        let dragStartX = 0, dragStartY = 0;
        let cropStartX = 0, cropStartY = 0, cropStartSize = 0;
        // Cropper zoom/pan variables
        let cropperZoom = 1.0;
        let cropperPanX = 0;
        let cropperPanY = 0;
        let isPanningCropper = false;
        let panStartX = 0, panStartY = 0;
        
        // Paint variables
        let selectedPaintColor = { r: 0, g: 0, b: 0 }; // Default to black
        let brushSize = 1; // Brush size in pixels (1 = single pixel, larger = area)
        let processedImageData = null; // Store the processed image data for pixel editing
        let originalProcessedImageData = null; // Store the original processed image data (before painting)
        let undoStack = []; // Stack for undo history
        let redoStack = []; // Stack for redo history
        let lastPaintState = null; // Store state before current paint stroke starts
        let processedZoom = 1.0; // Zoom level for processed canvas
        let processedZoomOffsetX = 0;
        let processedZoomOffsetY = 0;
        let isPanningProcessed = false;
        let eraserMode = false; // Track if eraser mode is active
        let paintMode = true; // Track if paint mode is active (default on)
        let processedPanStartX = 0, processedPanStartY = 0;
        let zoomMode = null; // 'zoom-in', 'zoom-out', or null
        let fullOriginalImage = null; // Store the full original uncropped image
        let cropCoordinates = null; // Store crop coordinates {x, y, size} for processing
        let fullProcessedImageDataURL = null; // Store the full processed image snapshot for cropper preview

        const pixelSizes = [48, 75, 96];

        // IndexedDB persistence for files
        let dbPromise = null;
        function openDB() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
                const req = indexedDB.open('albumCoverDB', 1);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains('files')) {
                        db.createObjectStore('files');
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
            return dbPromise;
        }

        // Key helper for per-size storage
        function dbKey(type, size = selectedGridSize) {
            return `${type}_${size}`;
        }

        async function saveFileToDB(key, file) {
            try {
                const db = await openDB();
                await new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readwrite');
                    const store = tx.objectStore('files');
                    const value = { name: file.name, type: file.type, blob: file };
                    const req = store.put(value, key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                console.warn('Failed to save file to IndexedDB', e);
            }
        }

        async function loadFileFromDB(key) {
            try {
                const db = await openDB();
                return await new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const req = store.get(key);
                    req.onsuccess = () => resolve(req.result || null);
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                console.warn('Failed to load file from IndexedDB', e);
                return null;
            }
        }

        async function deleteFileFromDB(key) {
            try {
                const db = await openDB();
                await new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readwrite');
                    const store = tx.objectStore('files');
                    const req = store.delete(key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                });
                console.log(`‚úÖ Deleted ${key} from IndexedDB cache`);
            } catch (e) {
                console.warn('Failed to delete file from IndexedDB', e);
            }
        }

        // Persist simple state in localStorage
        function saveSimpleState() {
            localStorage.setItem('selectedGridSize', String(selectedGridSize));
            localStorage.setItem('editorSettings', JSON.stringify(editorSettings));
        }

        function loadSimpleState() {
            const sizeStr = localStorage.getItem('selectedGridSize');
            if (sizeStr) {
                const s = parseInt(sizeStr);
                if ([32,48,75,96].includes(s)) {
                    selectedGridSize = s;
                }
            }
            const es = localStorage.getItem('editorSettings');
            if (es) {
                try {
                    const parsed = JSON.parse(es);
                    editorSettings = { ...editorSettings, ...parsed };
                } catch {}
            }
        }

        async function restoreForSize(size) {
            // PNG
            const pngEntry = await loadFileFromDB(dbKey('png', size));
            if (pngEntry && pngEntry.blob) {
                const restoredPNG = new File([pngEntry.blob], pngEntry.name || 'image.png', { type: pngEntry.type || 'image/png' });
                pngFile = restoredPNG;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        rawUploadedImage = img;
                        fullOriginalImage = img; // Store full original uncropped image
                        cropCoordinates = null; // Reset crop coordinates when restoring image
                        pngImage = img;
                        
                        // Reset cropper state when restoring image
                        fullProcessedImageDataURL = null;
                        cropperVisible = false;
                        cropperManuallyHidden = false; // Reset flag when restoring
                        cropInitialized = false;
                        const previewImg = document.getElementById('png-preview-img');
                        if (previewImg) {
                            previewImg.removeAttribute('data-cropper-fixed');
                        }
                        document.getElementById('png-preview').style.display = 'none';
                        document.getElementById('crop-canvas').style.display = 'none';
                        document.getElementById('show-cropper-btn').style.display = 'block';
                        document.getElementById('hide-cropper-btn').style.display = 'none';
                        
                        // Auto-tune per restored image
                        autoTuneSettingsFromImage(img);
                        document.getElementById('contrast-slider').value = String(editorSettings.contrast);
                        document.getElementById('brightness-slider').value = String(editorSettings.brightness);
                        document.getElementById('contrast-value').textContent = editorSettings.contrast.toFixed(1);
                        document.getElementById('brightness-value').textContent = editorSettings.brightness.toFixed(1);
                        // Don't set preview image here - it will be set to processed version after processImage() runs
                        // document.getElementById('png-preview-img').src = ev.target.result;
                        // Show crop buttons when image is restored
                        document.getElementById('crop-buttons').style.display = 'block';
                        // Don't show preview automatically - only show when "Show Cropper" is clicked
                        // document.getElementById('png-preview').style.display = 'block';
                        document.getElementById('png-upload-area').classList.add('has-file');
                        document.getElementById('png-upload-text').textContent = restoredPNG.name;
                        if (currentMesh) applyColorsToMesh();
                        processImage();
                        // Automatically show cropper after image is processed (with small delay to ensure processed canvas is ready)
                        // Only auto-show if user hasn't manually hidden it
                        if (!cropperManuallyHidden) {
                            setTimeout(() => {
                                // Only show cropper if user hasn't manually hidden it
                            if (!cropperManuallyHidden) {
                                showCropper();
                            } else {
                                // Cropper was manually hidden, show the show button instead
                                document.getElementById('show-cropper-btn').style.display = 'block';
                                document.getElementById('hide-cropper-btn').style.display = 'none';
                            }
                            }, 100);
                        }
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(restoredPNG);
            } else {
                // Clear preview if no PNG for this size
                document.getElementById('png-preview').style.display = 'none';
                document.getElementById('crop-buttons').style.display = 'none';
                document.getElementById('png-upload-area').classList.remove('has-file');
                document.getElementById('png-upload-text').textContent = 'Choose image file...';
                pngFile = null;
            }

            // STL - Always load from server first to get latest version, then fall back to cache if server fails
                try {
                    await loadSTLFromServer(size);
                } catch (error) {
                    console.warn('Failed to load STL from server, trying cache...', error);
                    // Fallback to cache if server fails
                    const stlEntry = await loadFileFromDB(dbKey('stl', size));
                    if (stlEntry && stlEntry.blob) {
                        const restoredSTL = new File([stlEntry.blob], stlEntry.name || `${size}x${size}_grid.stl`, { type: stlEntry.type || 'application/octet-stream' });
                        stlFile = restoredSTL;
                        await loadSTL(restoredSTL);
                        console.log(`‚úÖ Restored STL for ${size}√ó${size} grid from cache (server unavailable)`);
                        showStatus('warning', `Using cached STL for ${size}√ó${size}. Upload new STL via admin to update.`);
                    } else {
                        // No cache either - show error
                        stlFile = null;
                        showStatus('error', `STL file not found for ${size}√ó${size}. Please upload via admin.`);
                        console.error(`‚ùå No STL file available for ${size}√ó${size} (server or cache)`);
                    }
                }
        }

        // Helper function to create processed image at a specific size
        function createProcessedImageAtSize(image, targetSize, callback) {
            // Cap resolution at 2048x2048 to prevent lag
            const MAX_PROCESSING_SIZE = 2048;
            
            // If crop coordinates exist, crop from the full original image first
            let imageToProcess = image;
            let sourceWidth, sourceHeight;
            if (cropCoordinates && cropCoordinates.size > 0) {
                sourceWidth = cropCoordinates.size;
                sourceHeight = cropCoordinates.size;
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = cropCoordinates.size;
                cropCanvas.height = cropCoordinates.size;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(image, cropCoordinates.x, cropCoordinates.y, cropCoordinates.size, cropCoordinates.size, 0, 0, cropCoordinates.size, cropCoordinates.size);
                imageToProcess = cropCanvas;
            } else {
                sourceWidth = image.width;
                sourceHeight = image.height;
            }
            
            // Process at target size directly for all pixelated modes (48x48, 75x75, 96x96)
            const processCanvas = document.createElement('canvas');
            processCanvas.width = targetSize;
            processCanvas.height = targetSize;
            const processCtx = processCanvas.getContext('2d');
            
            // Draw image at target size
            processCtx.drawImage(imageToProcess, 0, 0, targetSize, targetSize);
            
            const imageData = processCtx.getImageData(0, 0, processCanvas.width, processCanvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                // Always use 4 colors for all pixelated modes
                const base = [0,85,170,255];
                const n = 4;
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }

            processCtx.putImageData(imageData, 0, 0);
            
            // Use processed canvas directly at target size
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = targetSize;
            finalCanvas.height = targetSize;
            const finalCtx = finalCanvas.getContext('2d');
            
            // Disable smoothing for pixelated look
            finalCtx.imageSmoothingEnabled = false;
            finalCtx.drawImage(processCanvas, 0, 0, targetSize, targetSize);

            // Convert to image
            finalCanvas.toBlob((blob) => {
                const processedFile = new File([blob], 'processed.png', { type: 'image/png' });
                const img = new Image();
                img.onload = () => {
                    if (callback) callback(processedFile, img);
                };
                img.src = URL.createObjectURL(blob);
            });
        }

        // Handle grid size selection
        // Panel Toggle Function
        function togglePanel(panelName) {
            // Hide all panels
            document.getElementById('adjust-panel').classList.remove('active');
            document.getElementById('size-panel').classList.remove('active');
            document.getElementById('paint-panel').classList.remove('active');
            
            // Remove active class from all buttons
            document.getElementById('adjust-btn').classList.remove('active');
            document.getElementById('size-btn').classList.remove('active');
            document.getElementById('paint-btn').classList.remove('active');
            
            // Get crop buttons element
            const cropButtons = document.getElementById('crop-buttons');
            
            // Hide cropper and crop buttons completely when switching to adjustments or paint
            if (panelName === 'adjust' || panelName === 'paint') {
                hideCropper();
                // Hide crop buttons completely
                if (cropButtons) {
                    cropButtons.style.display = 'none';
                }
            }
            
            // Show selected panel and activate button (always show, no toggle)
            const panel = document.getElementById(panelName + '-panel');
            const btn = document.getElementById(panelName + '-btn');
            
            if (panel && btn) {
                // Always show the selected panel
                panel.classList.add('active');
                btn.classList.add('active');
                
                // If showing size panel and image is uploaded, show cropper and buttons
                if (panelName === 'size') {
                    // Small delay to ensure panel is visible first
                    setTimeout(() => {
                        if (rawUploadedImage) {
                            // Make sure upload panel is visible for cropper
                            const uploadPanel = document.getElementById('upload-panel');
                            if (uploadPanel) {
                                uploadPanel.style.display = 'block';
                                // Hide upload area and label, keep only cropper visible
                                const uploadArea = document.getElementById('png-upload-area');
                                const sectionLabel = uploadPanel.querySelector('.section-label');
                                if (uploadArea) uploadArea.style.display = 'none';
                                if (sectionLabel) sectionLabel.style.display = 'none';
                                // Show crop buttons
                                if (cropButtons) {
                                    cropButtons.style.display = 'block';
                                }
                            }
                            // Only show cropper if user hasn't manually hidden it
                            if (!cropperManuallyHidden) {
                                showCropper();
                            } else {
                                // Cropper was manually hidden, show the show button instead
                                document.getElementById('show-cropper-btn').style.display = 'block';
                                document.getElementById('hide-cropper-btn').style.display = 'none';
                            }
                        }
                    }, 100);
                }
            }
        }

        async function selectGridSize(size) {
            selectedGridSize = size;
            saveSimpleState();
            
            // Update button states
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.size) === size) {
                    btn.classList.add('active');
                }
            });
            
            // Update text to show selected grid size
            const pngSubtext = document.getElementById('png-upload-subtext');
            if (pngSubtext) {
                pngSubtext.textContent = `Will be resized to ${size}√ó${size} pixels`;
            }
            
            // Update price display
            updatePriceDisplay();
            
            console.log(`Grid size selected: ${size}√ó${size}`);

            // Clear current STL to allow restore
            stlFile = null;

            // If there's a current image loaded, reprocess it with the new size
            // Otherwise, restore saved files for this size
            if (rawUploadedImage) {
                // Reprocess current image with new grid size
                processImage(); // Update preview canvas
                // Also create new processed image for 3D view
                createProcessedImageAtSize(rawUploadedImage, size, (file, img) => {
                    pngFile = file;
                    pngImage = img;
                    // Save to IndexedDB for this size
                    saveFileToDB(dbKey('png', size), file);
                    // Apply colors to 3D mesh if loaded
                    if (currentMesh) {
                        applyColorsToMesh();
                    }
                });
                
                // Load STL for this size - always try server first to get latest version
                try {
                    console.log(`üîÑ Loading STL for ${size}√ó${size} grid from admin...`);
                    await loadSTLFromServer(size);
                } catch (error) {
                    console.warn('Failed to load STL from server, trying cache...', error);
                    // Fallback to cache if server fails
                    const stlEntry = await loadFileFromDB(dbKey('stl', size));
                    if (stlEntry && stlEntry.blob) {
                        const restoredSTL = new File([stlEntry.blob], stlEntry.name || `${size}x${size}_grid.stl`, { type: stlEntry.type || 'application/octet-stream' });
                        stlFile = restoredSTL;
                        await loadSTL(restoredSTL);
                        console.log(`‚úÖ Restored STL for ${size}√ó${size} grid from cache (server unavailable)`);
                        showStatus('warning', `Using cached STL for ${size}√ó${size}. Upload new STL via admin to update.`);
                    } else {
                        // No cache either - show error
                        stlFile = null;
                        showStatus('error', `STL file not found for ${size}√ó${size}. Please upload via admin.`);
                        console.error(`‚ùå No STL file available for ${size}√ó${size} (server or cache)`);
                    }
                }
            } else if (pngFile) {
                // If we have a processed PNG file, reload the original if possible
                // Otherwise, just restore saved files for this size
                // Don't restore on initial page load - only restore if user explicitly changes grid size
                // await restoreForSize(size);
                // Also load STL for this size
                await loadSTLFromServer(size);
            } else {
                // No current image - don't restore saved PNG on page load
                // Only load STL for this size
                // await restoreForSize(size);
                await loadSTLFromServer(size);
            }
        }

        // Photo Editor Functions
        function showEditorPanel() {
            console.log('showEditorPanel called');
            
            // HIDE initial upload box
            const initialUploadBox = document.getElementById('initial-upload-box');
            if (initialUploadBox) {
                initialUploadBox.style.display = 'none';
            }
            
            // SHOW editor panel
            const editorPanel = document.getElementById('editor-panel');
            if (editorPanel) {
                editorPanel.style.display = 'block';
            }
            
            // HIDE 3D canvas container
            const canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer) {
                canvasContainer.style.display = 'none';
            }
            
            // Reset viewer controls position when editor is shown
            updateViewerControlsPosition();
            
            // Process image if we have one
            if (rawUploadedImage) {
                if (processedImageData && processedImageData.width === selectedGridSize && processedImageData.height === selectedGridSize) {
                    redrawProcessedCanvas();
                } else {
                    processImage();
                }
            }
            
            console.log('Editor panel should now be visible');
        }

        function updateViewerControlsPosition() {
            const canvasContainer = document.getElementById('canvas-container');
            const viewerControls = document.querySelector('.viewer-controls');
            
            if (!canvasContainer || !viewerControls) return;
            
            // Only update if viewer is visible
            if (canvasContainer.style.display === 'none') {
                viewerControls.classList.remove('stopped');
                return;
            }
            
            const containerRect = canvasContainer.getBoundingClientRect();
            
            // If the bottom of the container has scrolled past the top of the viewport, hide the controls
            // Otherwise keep them visible at the top
            if (containerRect.bottom < 0) {
                viewerControls.classList.add('stopped');
            } else {
                viewerControls.classList.remove('stopped');
            }
        }

        async function show3DView() {
            console.log('üé¨ show3DView called');
            console.log('   stlFile:', stlFile ? 'exists' : 'missing');
            console.log('   currentMesh:', currentMesh ? 'exists' : 'missing');
            console.log('   selectedGridSize:', selectedGridSize);
            
            // Always ensure STL is loaded before showing 3D view
            if (!stlFile || !currentMesh) {
                console.log('üì¶ Loading STL before showing 3D view...');
                try {
                    await loadSTLFromServer(selectedGridSize);
                    console.log('‚úÖ STL loaded successfully');
                } catch (error) {
                    console.error('‚ùå Failed to load STL from server, trying cache...', error);
                    // Try to load from cache as fallback
                    try {
                        const stlEntry = await loadFileFromDB(dbKey('stl', selectedGridSize));
                        if (stlEntry && stlEntry.blob) {
                            const cachedSTL = new File([stlEntry.blob], stlEntry.name || `${selectedGridSize}x${selectedGridSize}_grid.stl`, { 
                                type: stlEntry.type || 'application/octet-stream' 
                            });
                            stlFile = cachedSTL;
                            await loadSTL(cachedSTL);
                            console.log(`‚úÖ Loaded STL from cache for ${selectedGridSize}√ó${selectedGridSize}`);
                        } else {
                            throw new Error('No cached STL available');
                        }
                    } catch (cacheError) {
                        console.error('‚ùå Failed to load STL from cache:', cacheError);
                        const placeholder = document.getElementById('three-placeholder');
                        if (placeholder) {
                            const errorMsg = cacheError.message || `STL file not found for ${selectedGridSize}√ó${selectedGridSize} grid.`;
                            placeholder.style.display = 'block';
                            placeholder.querySelector('div:last-child').textContent = errorMsg;
                        }
                        // Show detailed error message
                        const errorMessage = cacheError.message || 
                            `Failed to load 3D model for ${selectedGridSize}√ó${selectedGridSize} grid.\n\n` +
                            `Backend URL: ${BACKEND_URL}\n\n` +
                            `Please ensure:\n` +
                            `1. Backend server is running\n` +
                            `2. STL file is uploaded via admin panel\n` +
                            `3. Check browser console for details`;
                        alert(errorMessage);
                        return;
                    }
                }
            }
            
            // If still no mesh after loading, show error
            if (!currentMesh) {
                console.error('‚ùå Failed to load STL mesh. Cannot show 3D view.');
                const placeholder = document.getElementById('three-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'block';
                    placeholder.querySelector('div:last-child').textContent = `STL file not found for ${selectedGridSize}√ó${selectedGridSize} grid. Please upload via admin.`;
                }
                alert('3D model not available. Please ensure STL file is loaded.');
                return;
            }
            
            console.log('‚úÖ Mesh loaded, proceeding to show 3D view');
            
            // Hide placeholder before showing 3D view (mesh is loaded)
            const placeholder = document.getElementById('three-placeholder');
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            
            // Regenerate PNG with current crop settings before showing 3D view
            // If there's painted image data, use that instead of regenerating from scratch
            if (rawUploadedImage && currentMesh) {
                if (processedImageData && processedImageData.width > 0 && processedImageData.height > 0) {
                    // Use painted image data if available
                    const paintedCanvas = document.createElement('canvas');
                    paintedCanvas.width = processedImageData.width;
                    paintedCanvas.height = processedImageData.height;
                    const paintedCtx = paintedCanvas.getContext('2d');
                    paintedCtx.putImageData(processedImageData, 0, 0);
                    
                    // Convert to blob and image
                    paintedCanvas.toBlob((blob) => {
                        const paintedFile = new File([blob], 'painted.png', { type: 'image/png' });
                        const img = new Image();
                        img.onload = () => {
                            pngFile = paintedFile;
                            pngImage = img;
                            // Apply colors to 3D mesh with painted image
                            applyColorsToMesh();
                        };
                        img.src = URL.createObjectURL(blob);
                    });
                } else {
                    // Create processed image at current grid size with current crop
                    createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                        pngFile = file;
                        pngImage = img;
                        // Apply colors to 3D mesh with cropped image
                        applyColorsToMesh();
                    });
                }
            }
            
            // Ensure Three.js is initialized before showing 3D view
            if (!scene || !camera || !renderer) {
                console.log('‚ö†Ô∏è Three.js not initialized, initializing now...');
                initThree();
            }
            
            const editorPanel = document.getElementById('editor-panel');
            const canvasContainer = document.getElementById('canvas-container');
            
            if (!editorPanel) {
                console.error('‚ùå editor-panel not found');
                return;
            }
            if (!canvasContainer) {
                console.error('‚ùå canvas-container not found');
                return;
            }
            
            console.log('üîÑ Switching to 3D view');
            editorPanel.style.display = 'none';
            canvasContainer.style.display = 'block';
            
            // Update controls position and setup scroll handler
            updateViewerControlsPosition();
            
            // Ensure Three.js canvas resizes correctly after becoming visible (wait a frame)
            requestAnimationFrame(() => {
                try {
                    const container = document.getElementById('canvas-container');
                    if (!container) {
                        console.error('‚ùå canvas-container not found');
                        return;
                    }
                    
                    let w = container.clientWidth || container.offsetWidth;
                    let h = container.clientHeight || container.offsetHeight;
                    if (!w || !h) {
                        w = window.innerWidth;
                        h = window.innerHeight;
                    }
                    
                    // Ensure renderer exists and is attached
                    if (!renderer) {
                        console.error('‚ùå Renderer not initialized');
                        initThree();
                        return;
                    }
                    
                    // Ensure renderer DOM is attached to container
                    if (renderer.domElement && renderer.domElement.parentNode !== container) {
                        container.appendChild(renderer.domElement);
                    }
                    
                    if (camera) {
                        renderer.setSize(w, h, true);
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                    }
                    
                    // Fit camera to current mesh if available
                    if (currentMesh && camera && controls) {
                        const box = new THREE.Box3().setFromObject(currentMesh);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z) || 100;
                        camera.position.set(maxDim, maxDim, maxDim);
                        controls.target.set(0, 0, 0);
                        controls.update();
                    }
                    
                    // Render once immediately after resize
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                } catch (e) {
                    console.error('‚ùå Resize after showing 3D view failed:', e);
                }
            });
        }


        function processImage() {
            if (!rawUploadedImage) return;

            const processedCanvas = document.getElementById('processed-canvas');
            const processedCtx = processedCanvas.getContext('2d');
            
            // CRITICAL: Disable image smoothing immediately to prevent initial blur
            processedCtx.imageSmoothingEnabled = false;
            processedCtx.mozImageSmoothingEnabled = false;
            processedCtx.webkitImageSmoothingEnabled = false;
            processedCtx.msImageSmoothingEnabled = false;

            // Set canvas sizes - use container width for full display
            const container = document.getElementById('editor-panel');
            const containerWidth = Math.max(200, container.clientWidth - 48); // padding
            // Use container width to ensure full image is visible
            const side = containerWidth;
            // Set canvas internal resolution (for drawing)
            processedCanvas.width = side;
            processedCanvas.height = side;
            // Set CSS display size to match container width with 1:1 aspect ratio
            processedCanvas.style.width = '100%';
            processedCanvas.style.height = 'auto';
            processedCanvas.style.maxWidth = '100%';
            processedCanvas.style.aspectRatio = '1 / 1';
            processedCanvas.style.display = 'block';

            // Process: Convert to grayscale with luminosity + posterize + pixelate
            const pixelSize = selectedGridSize;
            
            // For posterized mode (48), cap resolution at 2048x2048 to prevent lag on large images
            const MAX_PROCESSING_SIZE = 2048;
            
            let sourceWidth, sourceHeight;
            if (cropCoordinates && cropCoordinates.size > 0) {
                sourceWidth = cropCoordinates.size;
                sourceHeight = cropCoordinates.size;
            } else {
                sourceWidth = rawUploadedImage.width;
                sourceHeight = rawUploadedImage.height;
            }
            
            // Process at pixel size for all modes (no resolution capping needed)
            
            // Create temp canvas at pixel size for all pixelated modes
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = pixelSize;
            tempCanvas.height = pixelSize;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.mozImageSmoothingEnabled = false;
            tempCtx.webkitImageSmoothingEnabled = false;
            tempCtx.msImageSmoothingEnabled = false;
            
            // If crop coordinates exist, crop from the full original image first
            if (cropCoordinates && cropCoordinates.size > 0) {
                // Create cropped version from full original
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = cropCoordinates.size;
                cropCanvas.height = cropCoordinates.size;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.imageSmoothingEnabled = false;
                cropCtx.mozImageSmoothingEnabled = false;
                cropCtx.webkitImageSmoothingEnabled = false;
                cropCtx.msImageSmoothingEnabled = false;
                cropCtx.drawImage(rawUploadedImage, cropCoordinates.x, cropCoordinates.y, cropCoordinates.size, cropCoordinates.size, 0, 0, cropCoordinates.size, cropCoordinates.size);
                
                // Draw cropped image at small size (pixelation effect)
                tempCtx.drawImage(cropCanvas, 0, 0, pixelSize, pixelSize);
            } else {
                // Draw full image at small size (pixelation effect)
                // Crop to square first to prevent stretching - use centered crop
                const sourceSquareSize = Math.min(rawUploadedImage.width, rawUploadedImage.height);
                const offsetX = (rawUploadedImage.width - sourceSquareSize) / 2;
                const offsetY = (rawUploadedImage.height - sourceSquareSize) / 2;
                tempCtx.drawImage(rawUploadedImage, offsetX, offsetY, sourceSquareSize, sourceSquareSize, 0, 0, pixelSize, pixelSize);
            }
            
            // Get image data
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            const width = tempCanvas.width;
            const height = tempCanvas.height;

            // STEP 1: Convert to grayscale with adjustments
            const grayValues = new Float32Array(width * height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                    // Percentile stretch using black/white points
                    const bp = editorSettings.blackPoint ?? 0;
                    const wp = editorSettings.whitePoint ?? 255;
                    gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                    // Apply contrast and brightness
                    gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                    gray = gray * editorSettings.brightness;
                    gray = Math.max(0, Math.min(255, gray));
                    
                    grayValues[y * width + x] = gray;
                }
            }

            // STEP 2: Apply denoise filter if needed
            const denoiseLevel = editorSettings.denoise || 0;
            if (denoiseLevel > 0.01) {
                // Scale filter size smoothly: 0 = no filter, 0.1-0.5 = 3x3, 0.6-0.8 = 5x5, 0.9-1.0 = 7x7
                // Interpolate filter size based on denoise level (0 to 1)
                let filterSize;
                if (denoiseLevel <= 0.5) {
                    // 0.1 to 0.5: use 3x3 filter with variable intensity
                    filterSize = 3;
                } else if (denoiseLevel <= 0.8) {
                    // 0.6 to 0.8: use 5x5 filter
                    filterSize = 5;
                } else {
                    // 0.9 to 1.0: use 7x7 filter
                    filterSize = 7;
                }
                
                const radius = Math.floor(filterSize / 2);
                const denoisedValues = new Float32Array(width * height);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const neighbors = [];
                        
                        // Collect neighboring pixels
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                
                                // Check bounds
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    neighbors.push(grayValues[ny * width + nx]);
                                }
                            }
                        }
                        
                        // Calculate median
                        neighbors.sort((a, b) => a - b);
                        const median = neighbors[Math.floor(neighbors.length / 2)];
                        
                        // Blend between original and median based on denoise level
                        // At denoiseLevel 0.1: very slight blend (90% original, 10% median)
                        // At denoiseLevel 1.0: full blend (0% original, 100% median)
                        const original = grayValues[y * width + x];
                        const blended = original * (1 - denoiseLevel) + median * denoiseLevel;
                        denoisedValues[y * width + x] = blended;
                    }
                }
                
                // Copy denoised values back
                for (let i = 0; i < grayValues.length; i++) {
                    grayValues[i] = denoisedValues[i];
                }
            }

            // STEP 3: Apply tone quantization
            const base = [0,85,170,255];
            const n = editorSettings.tones || 4;
            const indices = [];
            for (let k = 0; k < n; k++) {
                const idx = Math.round((k*(base.length-1))/(n-1));
                indices.push(base[idx]);
            }
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const gray = grayValues[y * width + x];
                    
                    // Quantize to N tones
                    let finalColor = indices[indices.length-1];
                    for (let t = 0; t < indices.length-1; t++) {
                        const mid = (indices[t] + indices[t+1]) / 2;
                        if (gray < mid) { finalColor = indices[t]; break; }
                    }

                    data[i] = finalColor;
                    data[i + 1] = finalColor;
                    data[i + 2] = finalColor;
                }
            }

            tempCtx.putImageData(imageData, 0, 0);

            // Store the processed image data for pixel editing
            // Store at pixel size for all pixelated modes
            const imageDataCopy = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            processedImageData = imageDataCopy;
            
            // Store a deep copy as the original (for reset functionality)
            originalProcessedImageData = new ImageData(
                new Uint8ClampedArray(imageDataCopy.data),
                imageDataCopy.width,
                imageDataCopy.height
            );

            // Draw result to processed canvas (scaled up)
            // Always use pixelated rendering (no smoothing)
            processedCtx.imageSmoothingEnabled = false;
            processedCtx.drawImage(tempCanvas, 0, 0, processedCanvas.width, processedCanvas.height);
            
            // Create a preview version at preview size for general use
            const previewCanvas = document.createElement('canvas');
            const previewMaxSize = 400;
            previewCanvas.width = previewMaxSize;
            previewCanvas.height = previewMaxSize;
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.imageSmoothingEnabled = false;
            previewCtx.drawImage(tempCanvas, 0, 0, previewMaxSize, previewMaxSize);
            const previewDataURL = previewCanvas.toDataURL();
            
            // IMPORTANT: Only store the full processed preview if cropper is NOT visible
            // Once cropper is visible, this snapshot is FROZEN and must never change
            // This is exclusively for the cropper preview - completely separate from editor updates
            if (!cropperVisible) {
                // Only update when cropper is not visible - this way it captures the full image before cropping
                fullProcessedImageDataURL = previewDataURL;
            }
            // If cropper IS visible, DO NOT overwrite fullProcessedImageDataURL - keep it frozen
            
            // Update preview image to show same processed result (scaled up to match preview size)
            // BUT NEVER update if cropper is visible/fixed - the cropper preview must stay unchanged
            // IMPORTANT: Check cropperVisible FIRST to prevent any updates while cropping
            const previewImg = document.getElementById('png-preview-img');
            const isCropperFixed = previewImg && previewImg.getAttribute('data-cropper-fixed') === 'true';
            // Only update if cropper is NOT visible AND preview is NOT fixed
            if (previewImg && rawUploadedImage && !cropperVisible && !isCropperFixed) {
                previewImg.src = previewDataURL;
            }
            // If cropper is visible, NEVER update the preview - it must stay frozen
            
            // Re-attach paint handlers after processing
            setTimeout(() => {
                setupPaintHandlers();
            }, 100);
        }

        function applyPhotoEdits() {
            // Create the processed image at the selected pixel size
            const pixelSize = selectedGridSize; // Use selectedGridSize
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = pixelSize;
            finalCanvas.height = pixelSize;
            const finalCtx = finalCanvas.getContext('2d');

            // Use painted image data if available, otherwise process from scratch
            let imageData;
            if (processedImageData && processedImageData.width === pixelSize && processedImageData.height === pixelSize) {
                // Use the painted image data (preserve paintings)
                imageData = new ImageData(
                    new Uint8ClampedArray(processedImageData.data),
                    processedImageData.width,
                    processedImageData.height
                );
            } else {
                // Draw and process from original
                finalCtx.drawImage(rawUploadedImage, 0, 0, pixelSize, pixelSize);
                imageData = finalCtx.getImageData(0, 0, pixelSize, pixelSize);
                const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }
            
                // Store for future editing
                processedImageData = imageData;
                
                // Store a deep copy as the original (for reset functionality)
                originalProcessedImageData = new ImageData(
                    new Uint8ClampedArray(imageData.data),
                    imageData.width,
                    imageData.height
                );
            }

            finalCtx.putImageData(imageData, 0, 0);

            // Convert to image and use as PNG
            finalCanvas.toBlob((blob) => {
                const processedFile = new File([blob], 'processed.png', { type: 'image/png' });
                pngFile = processedFile;

                const img = new Image();
                img.onload = () => {
                    pngImage = img;
                    // Don't set preview here - it's already set to processed version in processImage()
                    // document.getElementById('png-preview-img').src = img.src;
                    // Show crop buttons when image is processed
                    document.getElementById('crop-buttons').style.display = 'block';
                    // Don't show preview automatically - only show when "Show Cropper" is clicked
                    // document.getElementById('png-preview').style.display = 'block';
                    document.getElementById('png-upload-area').classList.add('has-file');
                    document.getElementById('png-upload-text').textContent = 'Processed image';

                    // Apply colors to 3D mesh if STL is loaded
                    if (currentMesh) {
                        applyColorsToMesh();
                    }
                    // Automatically switch to 3D view after applying
                    show3DView();
                };
                img.src = URL.createObjectURL(blob);

                // Persist processed PNG for current grid size
                saveFileToDB(dbKey('png'), processedFile);
            }, 'image/png');
        }

        // Crop Functions - Simple cropper with blue dotted line
        function showCropper() {
            console.log('Show cropper clicked');
            
            const previewImg = document.getElementById('png-preview-img');
            const cropCanvas = document.getElementById('crop-canvas');
            const container = document.getElementById('crop-container');
            
            if (!previewImg || !cropCanvas || !container) {
                console.error('Cropper elements not found');
                return;
            }
            
            // User is manually showing the cropper, so clear the manually hidden flag
            cropperManuallyHidden = false;
            
            // Make upload panel visible but hide the upload area and label - only show cropper
            const uploadPanel = document.getElementById('upload-panel');
            if (uploadPanel) {
                uploadPanel.style.display = 'block';
                // Hide upload area and label, keep only cropper visible
                const uploadArea = document.getElementById('png-upload-area');
                const sectionLabel = uploadPanel.querySelector('.section-label');
                if (uploadArea) uploadArea.style.display = 'none';
                if (sectionLabel) sectionLabel.style.display = 'none';
            }
            
            // Make sure preview image is visible
            document.getElementById('png-preview').style.display = 'block';
            
            // Show the original photo in the cropper (not the processed image)
            if (rawUploadedImage) {
                // Use the original image directly - CSS object-fit: contain will handle displaying it fully within the square container
                const originalDataURL = rawUploadedImage.src || (rawUploadedImage instanceof HTMLImageElement ? rawUploadedImage.src : null);
                if (originalDataURL) {
                    previewImg.src = originalDataURL;
                    previewImg.setAttribute('data-cropper-fixed', 'true');
                    // Store the original image for reference
                    fullProcessedImageDataURL = originalDataURL;
                }
            } else if (pngImage && pngImage.src) {
                // Fallback: use pngImage if rawUploadedImage not available
                // Use the original image directly - CSS object-fit: contain will handle displaying it fully
                previewImg.src = pngImage.src;
                previewImg.setAttribute('data-cropper-fixed', 'true');
                fullProcessedImageDataURL = pngImage.src;
            } else {
                alert('Please upload an image first');
                return;
            }
            
            // Wait for image to load if needed
            if (previewImg.complete && previewImg.naturalWidth > 0) {
                setTimeout(initCropper, 50);
            } else {
                previewImg.onload = function() {
                    setTimeout(initCropper, 50);
                };
                // If image is already loading, trigger onload manually
                if (previewImg.src) {
                    previewImg.load();
                }
            }
            
            function initCropper() {
                // Reset zoom/pan when showing cropper
                cropperZoom = 1.0;
                cropperPanX = 0;
                cropperPanY = 0;
                updateCropperTransform();
                
                // Calculate available width based on container or viewport
                const container = document.getElementById('crop-container');
                const parentContainer = container ? container.parentElement : null;
                
                // Calculate max width: container max-width or available viewport space (with padding)
                let containerWidth = 400; // Default max width
                if (parentContainer) {
                    const parentRect = parentContainer.getBoundingClientRect();
                    const availableWidth = Math.min(parentRect.width - 48, window.innerWidth - 48); // Account for padding
                    containerWidth = Math.min(400, Math.max(200, availableWidth));
                } else {
                    // Fallback: use viewport with padding
                    containerWidth = Math.min(400, Math.max(200, window.innerWidth - 48));
                }
                
                // Wait for image to load to get natural dimensions
                const getImageDisplayInfo = () => {
                    if (!previewImg.naturalWidth || !previewImg.naturalHeight) {
                        setTimeout(getImageDisplayInfo, 50);
                        return;
                    }
                    
                    // Get actual rendered container width after CSS is applied
                    if (container) {
                        const containerRect = container.getBoundingClientRect();
                        if (containerRect.width > 0) {
                            containerWidth = containerRect.width;
                        }
                    }
                    
                    const imgAspect = previewImg.naturalWidth / previewImg.naturalHeight;
                    
                    let imgDisplayWidth, imgDisplayHeight, imgOffsetX, imgOffsetY;
                    
                    // Always use containerWidth as the base width (but ensure it doesn't exceed viewport)
                    // For vertical images, height extends beyond; for horizontal, height fits
                    imgDisplayWidth = Math.min(containerWidth, window.innerWidth - 48);
                    imgDisplayHeight = imgDisplayWidth / imgAspect;
                    imgOffsetX = 0;
                    imgOffsetY = 0; // No vertical offset - image starts at top
                    
                    // Store image display info for crop calculations
                    previewImg._cropDisplayInfo = {
                        width: imgDisplayWidth,
                        height: imgDisplayHeight,
                        offsetX: imgOffsetX,
                        offsetY: imgOffsetY,
                        containerWidth: imgDisplayWidth,
                        containerHeight: imgDisplayHeight // Use actual image height
                    };
                    
                    // Update image styling - no fixed height, let it extend, but ensure it fits viewport
                    const maxAllowedWidth = Math.min(imgDisplayWidth, window.innerWidth - 48);
                    if (previewImg) {
                        previewImg.style.width = maxAllowedWidth + 'px';
                        previewImg.style.height = (maxAllowedWidth / imgAspect) + 'px';
                        previewImg.style.maxWidth = maxAllowedWidth + 'px';
                        previewImg.style.maxHeight = 'none';
                    }
                    if (container) {
                        container.style.maxWidth = maxAllowedWidth + 'px';
                        container.style.width = maxAllowedWidth + 'px';
                        container.style.height = 'auto'; // Let container adjust to image height
                    }
                    
                    // Wait for image to render, then get actual dimensions
                    setTimeout(() => {
                        const imgRect = previewImg.getBoundingClientRect();
                        let actualWidth = imgRect.width || maxAllowedWidth;
                        let actualHeight = imgRect.height || (maxAllowedWidth / imgAspect);
                        
                        // Ensure width doesn't exceed viewport
                        const viewportMaxWidth = window.innerWidth - 48;
                        if (actualWidth > viewportMaxWidth) {
                            actualWidth = viewportMaxWidth;
                            actualHeight = actualWidth / imgAspect;
                            previewImg.style.width = actualWidth + 'px';
                            previewImg.style.height = actualHeight + 'px';
                            if (container) {
                                container.style.width = actualWidth + 'px';
                            }
                        }
                        
                        // Update display info with actual rendered dimensions
                        previewImg._cropDisplayInfo.width = actualWidth;
                        previewImg._cropDisplayInfo.height = actualHeight;
                        previewImg._cropDisplayInfo.containerWidth = actualWidth;
                        previewImg._cropDisplayInfo.containerHeight = actualHeight;
                        
                        // Set canvas to cover entire image (match actual rendered size exactly)
                        cropCanvas.style.width = actualWidth + 'px';
                        cropCanvas.style.height = actualHeight + 'px';
                        cropCanvas.style.left = '0px';
                        cropCanvas.style.top = '0px';
                        cropCanvas.style.display = 'block';
                cropCanvas.style.pointerEvents = 'auto';
                cropCanvas.style.cursor = 'move';
                cropCanvas.style.zIndex = '10';
                cropCanvas.style.position = 'absolute';
                cropCanvas.style.touchAction = 'none';
                        
                        // Set canvas internal resolution (device pixel ratio for crisp lines)
                        const dpr = window.devicePixelRatio || 1;
                        cropCanvas.width = actualWidth * dpr;
                        cropCanvas.height = actualHeight * dpr;
                        
                        // Initialize crop area - ONLY if never initialized before (preserve position forever after first use)
                        if (!cropInitialized) {
                            // First time - center it on the displayed image, 80% of image size, snapped to grid
                            const gridSize = selectedGridSize;
                            const cellSize = actualWidth / gridSize;
                            
                            let initialSize = Math.min(actualWidth, actualHeight) * 0.8;
                            const numCells = Math.round(initialSize / cellSize);
                            cropSize = Math.max(1, numCells) * cellSize;
                            
                            // Center on the actual image display area (accounting for offsets)
                            const centerX = imgOffsetX + (actualWidth - cropSize) / 2;
                            const centerY = imgOffsetY + (actualHeight - cropSize) / 2;
                            const centerCellX = Math.round(centerX / cellSize);
                            const centerCellY = Math.round(centerY / cellSize);
                            cropX = centerCellX * cellSize;
                            cropY = centerCellY * cellSize;
                            
                            // Ensure crop box stays within image bounds (the actual displayed image area)
                            const minX = imgOffsetX;
                            const minY = imgOffsetY;
                            const maxX = imgOffsetX + actualWidth - cropSize;
                            const maxY = imgOffsetY + actualHeight - cropSize;
                            cropX = Math.max(minX, Math.min(cropX, maxX));
                            cropY = Math.max(minY, Math.min(cropY, maxY));
                            
                            cropInitialized = true; // Mark as initialized - never reset again
                        }
                        
                        cropperVisible = true;
                        document.getElementById('show-cropper-btn').style.display = 'none';
                        document.getElementById('hide-cropper-btn').style.display = 'block';
                        // Show the preview image
                        document.getElementById('png-preview').style.display = 'block';
                        
                        // Redraw crop box with correct dimensions
                        drawCropBox();
                    }, 50);
                };
                
                getImageDisplayInfo();
            }
        }
        
        function drawCropBox() {
            if (!cropperVisible) return;
            
            const cropCanvas = document.getElementById('crop-canvas');
            if (!cropCanvas) return;
            
            const previewImg = document.getElementById('png-preview-img');
            if (!previewImg) return;
            
            // Get image display info if available, or use actual rendered dimensions
            const displayInfo = previewImg._cropDisplayInfo;
            let imgDisplayWidth, imgDisplayHeight;
            
            if (displayInfo) {
                imgDisplayWidth = displayInfo.width;
                imgDisplayHeight = displayInfo.height;
                
                // Get actual rendered dimensions as a fallback check
                const imgRect = previewImg.getBoundingClientRect();
                if (imgRect.width > 0 && Math.abs(imgRect.width - imgDisplayWidth) > 1) {
                    imgDisplayWidth = imgRect.width;
                    imgDisplayHeight = imgRect.height || imgDisplayHeight;
                    // Update display info
                    previewImg._cropDisplayInfo.width = imgDisplayWidth;
                    previewImg._cropDisplayInfo.height = imgDisplayHeight;
                }
                
                // Constrain crop box to the actual image display area
                const minX = displayInfo.offsetX;
                const minY = displayInfo.offsetY;
                const maxX = displayInfo.offsetX + imgDisplayWidth - cropSize;
                const maxY = displayInfo.offsetY + imgDisplayHeight - cropSize;
                
                // Clamp crop position to image bounds
                cropX = Math.max(minX, Math.min(cropX, maxX));
                cropY = Math.max(minY, Math.min(cropY, maxY));
                
                // Ensure crop size doesn't exceed image
                const maxCropSize = Math.min(imgDisplayWidth, imgDisplayHeight);
                if (cropSize > maxCropSize) {
                    cropSize = maxCropSize;
                }
            } else {
                // Fallback: get actual rendered dimensions
                const imgRect = previewImg.getBoundingClientRect();
                if (imgRect.width > 0) {
                    imgDisplayWidth = imgRect.width;
                    imgDisplayHeight = imgRect.height || imgDisplayWidth;
                } else {
                    imgDisplayWidth = 400;
                    imgDisplayHeight = 400;
                }
            }
            
            // Ensure canvas is visible and properly configured for touch
            cropCanvas.style.display = 'block';
            cropCanvas.style.pointerEvents = 'auto';
            cropCanvas.style.touchAction = 'none';
            cropCanvas.style.userSelect = 'none';
            cropCanvas.style.webkitUserSelect = 'none';
            
            // Ensure canvas matches image size FIRST (before getting context)
            const canvasRect = cropCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            if (Math.abs(canvasRect.width - imgDisplayWidth) > 1 || Math.abs(canvasRect.height - imgDisplayHeight) > 1 || canvasRect.width === 0 || canvasRect.height === 0) {
                cropCanvas.style.width = imgDisplayWidth + 'px';
                cropCanvas.style.height = imgDisplayHeight + 'px';
                cropCanvas.style.left = '0px';
                cropCanvas.style.top = '0px';
                cropCanvas.style.position = 'absolute';
                cropCanvas.style.zIndex = '10';
                cropCanvas.width = imgDisplayWidth * dpr;
                cropCanvas.height = imgDisplayHeight * dpr;
            }
            
            // Now get context AFTER canvas is properly sized
            const ctx = cropCanvas.getContext('2d');
            
            // Disable image smoothing for crisp pixels
            ctx.imageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;
            
            // Clear canvas completely
            ctx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            
            // Reset transform to identity first
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Scale to device pixel ratio for crisp rendering
            ctx.scale(dpr, dpr);
            
            // Draw blue dotted square border
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3; // Make it slightly thicker to be more visible
            ctx.setLineDash([8, 4]); // Dash pattern: 8px dash, 4px gap
            ctx.lineDashOffset = 0;
            
            // Ensure cropSize is valid
            if (!cropSize || cropSize <= 0) {
                console.warn('Invalid cropSize, skipping draw:', cropSize);
                return;
            }
            
            // Ensure crop coordinates are within image bounds
            const maxX = Math.min(cropX + cropSize, imgDisplayWidth);
            const maxY = Math.min(cropY + cropSize, imgDisplayHeight);
            const clampedX = Math.max(0, Math.min(cropX, imgDisplayWidth));
            const clampedY = Math.max(0, Math.min(cropY, imgDisplayHeight));
            const clampedSizeX = Math.max(1, maxX - clampedX);
            const clampedSizeY = Math.max(1, maxY - clampedY);
            
            // Ensure we have valid dimensions
            if (clampedSizeX <= 0 || clampedSizeY <= 0) {
                console.warn('Invalid crop dimensions, skipping draw:', clampedSizeX, clampedSizeY);
                return;
            }
            
            // Draw the rectangle
            ctx.beginPath();
            ctx.rect(clampedX, clampedY, clampedSizeX, clampedSizeY);
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            console.log('Drew crop box at:', clampedX, clampedY, clampedSizeX, clampedSizeY, 'on canvas', imgDisplayWidth, 'x', imgDisplayHeight);
        }
        
        // Make the canvas interactive
        document.getElementById('crop-canvas').addEventListener('mousedown', (e) => {
            if (!cropperVisible) return;
            
            const cropCanvas = document.getElementById('crop-canvas');
            const rect = cropCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Check if clicking on edge (for resize) or center (for drag)
            const edgeThreshold = 15;
            const onLeftEdge = Math.abs(mouseX - cropX) < edgeThreshold;
            const onRightEdge = Math.abs(mouseX - (cropX + cropSize)) < edgeThreshold;
            const onTopEdge = Math.abs(mouseY - cropY) < edgeThreshold;
            const onBottomEdge = Math.abs(mouseY - (cropY + cropSize)) < edgeThreshold;
            
            // Check corners first
            const onTopLeft = onTopEdge && onLeftEdge;
            const onTopRight = onTopEdge && onRightEdge;
            const onBottomLeft = onBottomEdge && onLeftEdge;
            const onBottomRight = onBottomEdge && onRightEdge;
            
            if (onTopLeft || onTopRight || onBottomLeft || onBottomRight) {
                // Resize from corner
                isResizingCrop = true;
                if (onTopLeft) resizeEdge = 'topleft';
                else if (onTopRight) resizeEdge = 'topright';
                else if (onBottomLeft) resizeEdge = 'bottomleft';
                else if (onBottomRight) resizeEdge = 'bottomright';
                cropStartX = cropX;
                cropStartY = cropY;
                cropStartSize = cropSize;
                dragStartX = mouseX;
                dragStartY = mouseY;
                cropCanvas.style.cursor = 'nwse-resize';
            } else if (onLeftEdge || onRightEdge || onTopEdge || onBottomEdge) {
                // Resize from edge
                isResizingCrop = true;
                if (onLeftEdge) resizeEdge = 'left';
                else if (onRightEdge) resizeEdge = 'right';
                else if (onTopEdge) resizeEdge = 'top';
                else if (onBottomEdge) resizeEdge = 'bottom';
                cropStartX = cropX;
                cropStartY = cropY;
                cropStartSize = cropSize;
                dragStartX = mouseX;
                dragStartY = mouseY;
                cropCanvas.style.cursor = onLeftEdge || onRightEdge ? 'ew-resize' : 'ns-resize';
            } else if (isPanningCropper) {
                // Start panning
                panStartX = mouseX;
                panStartY = mouseY;
            } else if (mouseX >= cropX && mouseX <= cropX + cropSize &&
                      mouseY >= cropY && mouseY <= cropY + cropSize) {
                // Drag from center (only if not panning)
                isDraggingCrop = true;
                dragStartX = mouseX - cropX * cropperZoom;
                dragStartY = mouseY - cropY * cropperZoom;
                cropCanvas.style.cursor = 'move';
            }
        });
        
        // Add touch event handlers for mobile/touchscreen support
        const cropCanvasEl = document.getElementById('crop-canvas');
        if (!cropCanvasEl) {
            console.error('Crop canvas not found when attaching touch handlers');
        } else {
            cropCanvasEl.addEventListener('touchstart', (e) => {
                if (!cropperVisible) {
                    console.log('Touch ignored - cropper not visible');
                    return;
                }
                e.preventDefault(); // Prevent scrolling
                e.stopPropagation(); // Prevent event from bubbling
                
                const cropCanvas = document.getElementById('crop-canvas');
                if (!cropCanvas) return;
                const rect = cropCanvas.getBoundingClientRect();
                if (!e.touches || !e.touches[0]) return;
                const touch = e.touches[0];
                const mouseX = touch.clientX - rect.left;
                const mouseY = touch.clientY - rect.top;
                
                console.log('Touch start at:', mouseX, mouseY, 'cropX:', cropX, 'cropY:', cropY, 'cropSize:', cropSize, 'rect:', rect);
                
                // Larger edge threshold for touch (easier to grab on mobile)
                const edgeThreshold = 30;
                const onLeftEdge = Math.abs(mouseX - cropX) < edgeThreshold;
                const onRightEdge = Math.abs(mouseX - (cropX + cropSize)) < edgeThreshold;
                const onTopEdge = Math.abs(mouseY - cropY) < edgeThreshold;
                const onBottomEdge = Math.abs(mouseY - (cropY + cropSize)) < edgeThreshold;
                
                const onTopLeft = onTopEdge && onLeftEdge;
                const onTopRight = onTopEdge && onRightEdge;
                const onBottomLeft = onBottomEdge && onLeftEdge;
                const onBottomRight = onBottomEdge && onRightEdge;
                
                if (onTopLeft || onTopRight || onBottomLeft || onBottomRight) {
                    isResizingCrop = true;
                    if (onTopLeft) resizeEdge = 'topleft';
                    else if (onTopRight) resizeEdge = 'topright';
                    else if (onBottomLeft) resizeEdge = 'bottomleft';
                    else if (onBottomRight) resizeEdge = 'bottomright';
                    cropStartX = cropX;
                    cropStartY = cropY;
                    cropStartSize = cropSize;
                    dragStartX = mouseX;
                    dragStartY = mouseY;
                    cropCanvas.style.cursor = 'nwse-resize';
                } else if (onLeftEdge || onRightEdge || onTopEdge || onBottomEdge) {
                    isResizingCrop = true;
                    if (onLeftEdge) resizeEdge = 'left';
                    else if (onRightEdge) resizeEdge = 'right';
                    else if (onTopEdge) resizeEdge = 'top';
                    else if (onBottomEdge) resizeEdge = 'bottom';
                    cropStartX = cropX;
                    cropStartY = cropY;
                    cropStartSize = cropSize;
                    dragStartX = mouseX;
                    dragStartY = mouseY;
                    cropCanvas.style.cursor = onLeftEdge || onRightEdge ? 'ew-resize' : 'ns-resize';
                } else if (isPanningCropper) {
                    panStartX = mouseX;
                    panStartY = mouseY;
                } else if (mouseX >= cropX && mouseX <= cropX + cropSize &&
                          mouseY >= cropY && mouseY <= cropY + cropSize) {
                    isDraggingCrop = true;
                    dragStartX = mouseX - cropX * cropperZoom;
                    dragStartY = mouseY - cropY * cropperZoom;
                    cropCanvas.style.cursor = 'move';
                    console.log('Started dragging crop box');
                } else {
                    console.log('Touch not on crop box - mouseX:', mouseX, 'mouseY:', mouseY, 'crop box:', cropX, cropY, cropSize);
                }
            }, { passive: false });
        }
        
        document.addEventListener('mousemove', (e) => {
            if (!cropperVisible && !isDraggingCrop && !isResizingCrop && !isPanningCropper) return;
            
            const cropCanvas = document.getElementById('crop-canvas');
            const rect = cropCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (isPanningCropper) {
                // Pan the cropper view
                const deltaX = mouseX - panStartX;
                const deltaY = mouseY - panStartY;
                cropperPanX += deltaX;
                cropperPanY += deltaY;
                panStartX = mouseX;
                panStartY = mouseY;
                updateCropperTransform();
            } else if (isDraggingCrop) {
                // Move crop box - need to convert mouse coordinates to image coordinates
                // Account for zoom/pan transform
                const cropCanvas = document.getElementById('crop-canvas');
                const rect = cropCanvas.getBoundingClientRect();
                const canvasMouseX = (e.clientX - rect.left) / cropperZoom - cropperPanX / cropperZoom;
                const canvasMouseY = (e.clientY - rect.top) / cropperZoom - cropperPanY / cropperZoom;
                
                let newX = canvasMouseX - dragStartX;
                let newY = canvasMouseY - dragStartY;
                
                // Get image display info if available (for object-fit: contain positioning)
                const previewImg = document.getElementById('png-preview-img');
                const displayInfo = previewImg._cropDisplayInfo;
                let imgWidth, imgHeight, minX, minY;
                if (displayInfo) {
                    imgWidth = displayInfo.width;
                    imgHeight = displayInfo.height;
                    minX = displayInfo.offsetX;
                    minY = displayInfo.offsetY;
                    newX = Math.max(minX, Math.min(newX, minX + imgWidth - cropSize));
                    newY = Math.max(minY, Math.min(newY, minY + imgHeight - cropSize));
                } else {
                    imgWidth = 400;
                    imgHeight = 400;
                    minX = 0;
                    minY = 0;
                    newX = Math.max(0, Math.min(newX, imgWidth - cropSize));
                    newY = Math.max(0, Math.min(newY, imgHeight - cropSize));
                }
                
                // Snap to pixel grid
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize;
                
                // Snap position to grid cell boundaries
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                cropX = cellX * cellSize;
                cropY = cellY * cellSize;
                
                // Ensure it stays within image bounds
                const maxCellX = Math.floor((minX + imgWidth - cropSize) / cellSize);
                const maxCellY = Math.floor((minY + imgHeight - cropSize) / cellSize);
                cropX = Math.max(minX, Math.min(cropX, maxCellX * cellSize));
                cropY = Math.max(minY, Math.min(cropY, maxCellY * cellSize));
                
                // Ensure final bounds check
                cropX = Math.max(minX, Math.min(cropX, minX + imgWidth - cropSize));
                cropY = Math.max(minY, Math.min(cropY, minY + imgHeight - cropSize));
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you drag (like the reference)
                applyCropFromBox(true);
            } else if (isResizingCrop) {
                // Resize crop box (keep square) based on which edge/corner
                // Get image display info if available (for object-fit: contain positioning)
                const previewImg = document.getElementById('png-preview-img');
                const displayInfo = previewImg._cropDisplayInfo;
                let imgWidth, imgHeight, minX, minY;
                if (displayInfo) {
                    imgWidth = displayInfo.width;
                    imgHeight = displayInfo.height;
                    minX = displayInfo.offsetX;
                    minY = displayInfo.offsetY;
                } else {
                    imgWidth = 400;
                    imgHeight = 400;
                    minX = 0;
                    minY = 0;
                }
                
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize; // Each cell size in screen pixels
                
                // Calculate resize direction - fix inverted logic
                let deltaX = mouseX - dragStartX;
                let deltaY = mouseY - dragStartY;
                
                // For corners, use the dominant direction
                let delta = 0;
                if (resizeEdge.includes('left') && resizeEdge.includes('top')) {
                    // Top-left: dragging right/down = larger, left/up = smaller
                    delta = Math.max(-deltaX, -deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('top')) {
                    // Top-right: dragging right/down = larger, left/up = smaller
                    delta = Math.max(deltaX, -deltaY);
                } else if (resizeEdge.includes('left') && resizeEdge.includes('bottom')) {
                    // Bottom-left: dragging right/down = larger, left/up = smaller
                    delta = Math.max(-deltaX, deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('bottom')) {
                    // Bottom-right: dragging right/down = larger, left/up = smaller
                    delta = Math.max(deltaX, deltaY);
                } else if (resizeEdge === 'left') {
                    // Left edge: dragging right = larger, left = smaller
                    delta = -deltaX;
                } else if (resizeEdge === 'right') {
                    // Right edge: dragging right = larger, left = smaller
                    delta = deltaX;
                } else if (resizeEdge === 'top') {
                    // Top edge: dragging down = larger, up = smaller
                    delta = -deltaY;
                } else if (resizeEdge === 'bottom') {
                    // Bottom edge: dragging down = larger, up = smaller
                    delta = deltaY;
                }
                
                // Calculate new size (delta > 0 means larger, delta < 0 means smaller)
                let newSize = cropStartSize + delta;
                
                // Constrain size to image bounds
                newSize = Math.max(cellSize, Math.min(newSize, imgWidth, imgHeight));
                
                // Snap size to grid cells (must be multiple of cellSize) - use precise calculation
                const numCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, numCells) * cellSize;
                
                // Calculate new position based on which edge is being resized
                let newX = cropStartX;
                let newY = cropStartY;
                
                if (resizeEdge.includes('left')) {
                    newX = cropStartX + cropStartSize - newSize;
                    newX = Math.max(minX, Math.min(newX, minX + imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    newY = cropStartY + cropStartSize - newSize;
                    newY = Math.max(minY, Math.min(newY, minY + imgHeight - newSize));
                }
                if (resizeEdge.includes('right')) {
                    newX = cropStartX;
                }
                if (resizeEdge.includes('bottom')) {
                    newY = cropStartY;
                }
                
                // Snap position to grid with better precision
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                newX = cellX * cellSize;
                newY = cellY * cellSize;
                
                // Adjust size if needed after snapping position - with precise snapping
                if (resizeEdge.includes('left')) {
                    const actualX = Math.max(minX, Math.min(newX, minX + imgWidth - newSize));
                    let adjustedSize = cropStartX + cropStartSize - actualX;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedX = cropStartX + cropStartSize - adjustedSize;
                    const cellX2 = Math.round(adjustedX / cellSize);
                    newX = cellX2 * cellSize;
                    newSize = cropStartX + cropStartSize - newX;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newX = cropStartX + cropStartSize - newSize;
                    const cellX3 = Math.round(newX / cellSize);
                    newX = Math.max(minX, Math.min(cellX3 * cellSize, minX + imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    const actualY = Math.max(minY, Math.min(newY, minY + imgHeight - newSize));
                    let adjustedSize = cropStartY + cropStartSize - actualY;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedY = cropStartY + cropStartSize - adjustedSize;
                    const cellY2 = Math.round(adjustedY / cellSize);
                    newY = cellY2 * cellSize;
                    newSize = cropStartY + cropStartSize - newY;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newY = cropStartY + cropStartSize - newSize;
                    const cellY3 = Math.round(newY / cellSize);
                    newY = Math.max(minY, Math.min(cellY3 * cellSize, minY + imgHeight - newSize));
                }
                
                // Final constraints with precise snapping (account for image offset)
                newSize = Math.max(cellSize, Math.min(newSize, minX + imgWidth - newX, minY + imgHeight - newY));
                const finalNumCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, finalNumCells) * cellSize;
                
                // Final position snap
                const finalCellX = Math.round(newX / cellSize);
                const finalCellY = Math.round(newY / cellSize);
                cropX = Math.max(minX, Math.min(finalCellX * cellSize, minX + imgWidth - newSize));
                cropY = Math.max(minY, Math.min(finalCellY * cellSize, minY + imgHeight - newSize));
                cropSize = newSize;
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you resize (like the reference)
                applyCropFromBox(true);
            } else if (cropperVisible) {
                // Update cursor when hovering
                const edgeThreshold = 15;
                const onLeftEdge = Math.abs(mouseX - cropX) < edgeThreshold;
                const onRightEdge = Math.abs(mouseX - (cropX + cropSize)) < edgeThreshold;
                const onTopEdge = Math.abs(mouseY - cropY) < edgeThreshold;
                const onBottomEdge = Math.abs(mouseY - (cropY + cropSize)) < edgeThreshold;
                
                if ((onTopEdge && onLeftEdge) || (onBottomEdge && onRightEdge)) {
                    cropCanvas.style.cursor = 'nwse-resize';
                } else if ((onTopEdge && onRightEdge) || (onBottomEdge && onLeftEdge)) {
                    cropCanvas.style.cursor = 'nesw-resize';
                } else if (onLeftEdge || onRightEdge) {
                    cropCanvas.style.cursor = 'ew-resize';
                } else if (onTopEdge || onBottomEdge) {
                    cropCanvas.style.cursor = 'ns-resize';
                } else if (mouseX >= cropX && mouseX <= cropX + cropSize &&
                          mouseY >= cropY && mouseY <= cropY + cropSize) {
                    cropCanvas.style.cursor = 'move';
                } else {
                    cropCanvas.style.cursor = 'default';
                }
            }
        });
        
        // Touch move handler for mobile/touchscreen support
        document.addEventListener('touchmove', (e) => {
            if (!cropperVisible) return;
            if (!isDraggingCrop && !isResizingCrop && !isPanningCropper) return;
            e.preventDefault(); // Prevent scrolling
            e.stopPropagation(); // Prevent event from bubbling
            
            const cropCanvas = document.getElementById('crop-canvas');
            if (!cropCanvas) return;
            const rect = cropCanvas.getBoundingClientRect();
            if (!e.touches || !e.touches[0]) return;
            const touch = e.touches[0];
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            
            console.log('Touch move:', mouseX, mouseY, 'isDragging:', isDraggingCrop, 'isResizing:', isResizingCrop);
            
            if (isPanningCropper) {
                // Pan the cropper view
                const deltaX = mouseX - panStartX;
                const deltaY = mouseY - panStartY;
                cropperPanX += deltaX;
                cropperPanY += deltaY;
                panStartX = mouseX;
                panStartY = mouseY;
                updateCropperTransform();
            } else if (isDraggingCrop) {
                // Move crop box - need to convert touch coordinates to image coordinates
                // Account for zoom/pan transform (same as desktop)
                const cropCanvas = document.getElementById('crop-canvas');
                const rect = cropCanvas.getBoundingClientRect();
                const canvasMouseX = (mouseX) / cropperZoom - cropperPanX / cropperZoom;
                const canvasMouseY = (mouseY) / cropperZoom - cropperPanY / cropperZoom;
                
                let newX = canvasMouseX - dragStartX;
                let newY = canvasMouseY - dragStartY;
                
                console.log('Dragging: mouseX=', mouseX, 'canvasMouseX=', canvasMouseX, 'dragStartX=', dragStartX, 'newX=', newX);
                
                // Get image display info if available (for object-fit: contain positioning)
                const previewImg = document.getElementById('png-preview-img');
                const displayInfo = previewImg && previewImg._cropDisplayInfo ? previewImg._cropDisplayInfo : null;
                let imgWidth, imgHeight, minX, minY;
                if (displayInfo) {
                    imgWidth = displayInfo.width;
                    imgHeight = displayInfo.height;
                    minX = displayInfo.offsetX;
                    minY = displayInfo.offsetY;
                    newX = Math.max(minX, Math.min(newX, minX + imgWidth - cropSize));
                    newY = Math.max(minY, Math.min(newY, minY + imgHeight - cropSize));
                } else {
                    // Fallback: get actual rendered dimensions
                    if (previewImg) {
                        const imgRect = previewImg.getBoundingClientRect();
                        imgWidth = imgRect.width || 400;
                        imgHeight = imgRect.height || 400;
                    } else {
                        imgWidth = 400;
                        imgHeight = 400;
                    }
                    minX = 0;
                    minY = 0;
                    newX = Math.max(0, Math.min(newX, imgWidth - cropSize));
                    newY = Math.max(0, Math.min(newY, imgHeight - cropSize));
                }
                
                // Snap to pixel grid
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize;
                
                // Snap position to grid cell boundaries
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                cropX = cellX * cellSize;
                cropY = cellY * cellSize;
                
                // Ensure it stays within image bounds
                const maxCellX = Math.floor((minX + imgWidth - cropSize) / cellSize);
                const maxCellY = Math.floor((minY + imgHeight - cropSize) / cellSize);
                cropX = Math.max(minX, Math.min(cropX, maxCellX * cellSize));
                cropY = Math.max(minY, Math.min(cropY, maxCellY * cellSize));
                
                // Ensure final bounds check
                cropX = Math.max(minX, Math.min(cropX, minX + imgWidth - cropSize));
                cropY = Math.max(minY, Math.min(cropY, minY + imgHeight - cropSize));
                
                console.log('Touch drag final: cropX/cropY:', cropX, cropY);
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you drag
                applyCropFromBox(true);
            } else if (isResizingCrop) {
                // Resize crop box (keep square) based on which edge/corner
                // Get image display info if available (for object-fit: contain positioning)
                const previewImg = document.getElementById('png-preview-img');
                const displayInfo = previewImg && previewImg._cropDisplayInfo ? previewImg._cropDisplayInfo : null;
                let imgWidth, imgHeight, minX, minY;
                if (displayInfo) {
                    imgWidth = displayInfo.width;
                    imgHeight = displayInfo.height;
                    minX = displayInfo.offsetX;
                    minY = displayInfo.offsetY;
                } else {
                    // Fallback: get actual rendered dimensions
                    if (previewImg) {
                        const imgRect = previewImg.getBoundingClientRect();
                        imgWidth = imgRect.width || 400;
                        imgHeight = imgRect.height || 400;
                    } else {
                        imgWidth = 400;
                        imgHeight = 400;
                    }
                    minX = 0;
                    minY = 0;
                }
                
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize; // Each cell size in screen pixels
                
                // Calculate resize direction
                let deltaX = mouseX - dragStartX;
                let deltaY = mouseY - dragStartY;
                
                // For corners, use the dominant direction
                let delta = 0;
                if (resizeEdge.includes('left') && resizeEdge.includes('top')) {
                    delta = Math.max(-deltaX, -deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('top')) {
                    delta = Math.max(deltaX, -deltaY);
                } else if (resizeEdge.includes('left') && resizeEdge.includes('bottom')) {
                    delta = Math.max(-deltaX, deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('bottom')) {
                    delta = Math.max(deltaX, deltaY);
                } else if (resizeEdge === 'left') {
                    delta = -deltaX;
                } else if (resizeEdge === 'right') {
                    delta = deltaX;
                } else if (resizeEdge === 'top') {
                    delta = -deltaY;
                } else if (resizeEdge === 'bottom') {
                    delta = deltaY;
                }
                
                // Calculate new size (delta > 0 means larger, delta < 0 means smaller)
                let newSize = cropStartSize + delta;
                
                // Constrain size
                newSize = Math.max(cellSize, Math.min(newSize, imgWidth, imgHeight));
                
                // Snap size to grid cells (must be multiple of cellSize)
                const numCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, numCells) * cellSize;
                
                // Calculate new position based on which edge is being resized
                let newX = cropStartX;
                let newY = cropStartY;
                
                if (resizeEdge.includes('left')) {
                    newX = cropStartX + cropStartSize - newSize;
                    newX = Math.max(minX, Math.min(newX, minX + imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    newY = cropStartY + cropStartSize - newSize;
                    newY = Math.max(minY, Math.min(newY, minY + imgHeight - newSize));
                }
                if (resizeEdge.includes('right')) {
                    newX = cropStartX;
                }
                if (resizeEdge.includes('bottom')) {
                    newY = cropStartY;
                }
                
                // Snap position to grid with better precision
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                newX = cellX * cellSize;
                newY = cellY * cellSize;
                
                // Adjust size if needed after snapping position - with precise snapping
                if (resizeEdge.includes('left')) {
                    const actualX = Math.max(minX, Math.min(newX, minX + imgWidth - newSize));
                    let adjustedSize = cropStartX + cropStartSize - actualX;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedX = cropStartX + cropStartSize - adjustedSize;
                    const cellX2 = Math.round(adjustedX / cellSize);
                    newX = cellX2 * cellSize;
                    newSize = cropStartX + cropStartSize - newX;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newX = cropStartX + cropStartSize - newSize;
                    const cellX3 = Math.round(newX / cellSize);
                    newX = Math.max(minX, Math.min(cellX3 * cellSize, minX + imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    const actualY = Math.max(minY, Math.min(newY, minY + imgHeight - newSize));
                    let adjustedSize = cropStartY + cropStartSize - actualY;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedY = cropStartY + cropStartSize - adjustedSize;
                    const cellY2 = Math.round(adjustedY / cellSize);
                    newY = cellY2 * cellSize;
                    newSize = cropStartY + cropStartSize - newY;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newY = cropStartY + cropStartSize - newSize;
                    const cellY3 = Math.round(newY / cellSize);
                    newY = Math.max(minY, Math.min(cellY3 * cellSize, minY + imgHeight - newSize));
                }
                
                // Final constraints with precise snapping (account for image offset)
                newSize = Math.max(cellSize, Math.min(newSize, minX + imgWidth - newX, minY + imgHeight - newY));
                const finalNumCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, finalNumCells) * cellSize;
                
                // Final position snap
                const finalCellX = Math.round(newX / cellSize);
                const finalCellY = Math.round(newY / cellSize);
                cropX = Math.max(minX, Math.min(finalCellX * cellSize, minX + imgWidth - newSize));
                cropY = Math.max(minY, Math.min(finalCellY * cellSize, minY + imgHeight - newSize));
                cropSize = newSize;
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you resize
                applyCropFromBox(true);
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDraggingCrop || isResizingCrop) {
                // Redraw crop box
                drawCropBox();
                // Auto-apply crop when done dragging/resizing to update editor section
                setTimeout(() => {
                    applyCropFromBox(true);
                }, 50);
            }
            isDraggingCrop = false;
            isResizingCrop = false;
            isPanningCropper = false;
            resizeEdge = '';
            const cropCanvas = document.getElementById('crop-canvas');
            if (cropCanvas) {
                cropCanvas.style.cursor = isPanningCropper ? 'grab' : 'move';
            }
        });
        
        // Touch end handler for mobile/touchscreen support
        document.addEventListener('touchend', () => {
            if (isDraggingCrop || isResizingCrop) {
                // Redraw crop box
                drawCropBox();
                // Auto-apply crop when done dragging/resizing to update editor section
                setTimeout(() => {
                    applyCropFromBox(true);
                }, 50);
            }
            isDraggingCrop = false;
            isResizingCrop = false;
            isPanningCropper = false;
            resizeEdge = '';
            const cropCanvas = document.getElementById('crop-canvas');
            if (cropCanvas) {
                cropCanvas.style.cursor = isPanningCropper ? 'grab' : 'move';
            }
        }, { passive: false });
        
        // Hide cropper and image preview
        function hideCropper() {
            // Hide the cropper overlay and the entire preview image
            cropperVisible = false;
            cropperManuallyHidden = true; // Mark that user manually hid it
            isPanningCropper = false;
            document.getElementById('crop-canvas').style.display = 'none';
            document.getElementById('png-preview').style.display = 'none';
            document.getElementById('show-cropper-btn').style.display = 'block';
            document.getElementById('hide-cropper-btn').style.display = 'none';
            // Keep upload panel visible so user can show cropper again via button
        }
        
        // Cropper zoom/pan functions
        function cropperZoomIn() {
            cropperZoom = Math.min(cropperZoom * 1.5, 5.0);
            updateCropperTransform();
        }
        
        function cropperZoomOut() {
            cropperZoom = Math.max(cropperZoom / 1.5, 0.5);
            updateCropperTransform();
        }
        
        function cropperResetView() {
            cropperZoom = 1.0;
            cropperPanX = 0;
            cropperPanY = 0;
            updateCropperTransform();
        }
        
        function cropperTogglePan() {
            const btn = document.getElementById('cropper-pan-btn');
            const cropCanvas = document.getElementById('crop-canvas');
            if (isPanningCropper) {
                isPanningCropper = false;
                btn.style.background = 'white';
                if (cropCanvas) cropCanvas.style.cursor = 'move';
            } else {
                isPanningCropper = true;
                btn.style.background = '#e0e0e0';
                if (cropCanvas) cropCanvas.style.cursor = 'grab';
            }
        }
        
        function updateCropperTransform() {
            const previewImg = document.getElementById('png-preview-img');
            if (previewImg) {
                const transform = `translate(${cropperPanX}px, ${cropperPanY}px) scale(${cropperZoom})`;
                previewImg.style.transform = transform;
                
                // Also update crop canvas to match
                const cropCanvas = document.getElementById('crop-canvas');
                if (cropCanvas) {
                    cropCanvas.style.transform = transform;
                }
                
                // Redraw crop box with new transform
                drawCropBox();
            }
        }
        
        function applyCropFromBox(skipVisibilityCheck = false) {
            // Only proceed if we have the full original image
            if (!fullOriginalImage) {
                // If no fullOriginalImage but we have rawUploadedImage, use that
                if (!rawUploadedImage || (!cropperVisible && !skipVisibilityCheck)) return;
            } else if (!cropperVisible && !skipVisibilityCheck) {
                return;
            }
            
            // IMPORTANT: While cropper is visible, we need to use the stored full processed image dimensions
            // NOT the cropper preview image dimensions (which might change)
            const previewImg = document.getElementById('png-preview-img');
            if (!previewImg) return;
            
            // Use fullOriginalImage if available, otherwise fall back to rawUploadedImage
            const sourceImage = fullOriginalImage || rawUploadedImage;
            
            // Get image display info if available (for object-fit: contain positioning)
            const displayInfo = previewImg._cropDisplayInfo;
            let imgDisplayWidth, imgDisplayHeight, imgOffsetX, imgOffsetY;
            
            if (cropperVisible && displayInfo) {
                // Use actual image display area from object-fit: contain
                imgDisplayWidth = displayInfo.width;
                imgDisplayHeight = displayInfo.height;
                imgOffsetX = displayInfo.offsetX;
                imgOffsetY = displayInfo.offsetY;
            } else if (cropperVisible) {
                // Fallback: use fixed dimensions - preview is always 400px max with aspect ratio 1:1
                imgDisplayWidth = 400;
                imgDisplayHeight = 400;
                imgOffsetX = 0;
                imgOffsetY = 0;
            } else {
                // Normal case: get dimensions from preview image
                const imgRect = previewImg.getBoundingClientRect();
                if (imgRect.width === 0 || imgRect.height === 0) return;
                imgDisplayWidth = imgRect.width;
                imgDisplayHeight = imgRect.height;
                imgOffsetX = 0;
                imgOffsetY = 0;
            }
            
            // Calculate scale from preview display size to actual image size
            const scale = sourceImage.width / imgDisplayWidth;
            
            // Convert crop coordinates from container coordinates to image display coordinates
            // Account for the offset when image uses object-fit: contain
            const cropXInImage = cropX - imgOffsetX;
            const cropYInImage = cropY - imgOffsetY;
            
            // Check if crop covers the entire displayed image (within a small threshold)
            // Check in displayed coordinates first, before converting to source coordinates
            const threshold = 10; // pixels tolerance in displayed coordinates
            const coversFullWidth = Math.abs(cropXInImage) < threshold && Math.abs(cropXInImage + cropSize - imgDisplayWidth) < threshold;
            const coversFullHeight = Math.abs(cropYInImage) < threshold && Math.abs(cropYInImage + cropSize - imgDisplayHeight) < threshold;
            const isFullSize = Math.abs(cropSize - imgDisplayWidth) < threshold && Math.abs(cropSize - imgDisplayHeight) < threshold;
            
            // If crop covers the full displayed image, reset crop coordinates to null (no crop)
            if (coversFullWidth && coversFullHeight && isFullSize) {
                cropCoordinates = null;
            } else {
                // Calculate actual pixel coordinates in the full original image
                // Use the crop position relative to the image display area
                const x = cropXInImage * scale;
                const y = cropYInImage * scale;
                const size = cropSize * scale;
                
                // Snap to grid cells
                const gridSize = selectedGridSize;
                const cellSize = size / gridSize;
                const snappedSize = Math.floor(size / cellSize) * cellSize;
                
                // Ensure we have valid crop dimensions
                if (snappedSize <= 0 || x < 0 || y < 0 || x + snappedSize > sourceImage.width || y + snappedSize > sourceImage.height) {
                    return;
                }
                
                // Store crop coordinates for use in processImage
                // DO NOT modify rawUploadedImage - keep it as the full original always
                cropCoordinates = { x, y, size: snappedSize };
            }
            
            // IMPORTANT: Prevent fullProcessedImageDataURL from being overwritten during cropping
            const savedFullProcessedImageDataURL = fullProcessedImageDataURL;
            
            // Process image with current crop settings
            processImage();
            
            // Restore fullProcessedImageDataURL after processing
            fullProcessedImageDataURL = savedFullProcessedImageDataURL;
            
            // Update preview image if needed (but don't modify rawUploadedImage)
            const img = new Image();
            img.onload = () => {
                // Don't update rawUploadedImage - keep it as full original
                // rawUploadedImage stays as the full original image
                
                // Keep the full original image visible (don't update it)
                // Processed image is shown in the canvas
                // IMPORTANT: Do NOT update the cropper preview image here!
                // The cropper preview should always stay showing the FULL processed image at fixed size
                // Only the editor panel (processed-canvas) will show the cropped/zoomed version
                
                // IMPORTANT: Prevent fullProcessedImageDataURL from being overwritten during cropping
                // Save it temporarily and restore it after processing
                const savedFullProcessedImageDataURL = fullProcessedImageDataURL;
                
                // Reprocess image with cropped version - this will update processed view in editor only
                processImage();
                
                // Restore the frozen cropper preview snapshot - it must NEVER change
                fullProcessedImageDataURL = savedFullProcessedImageDataURL;
                // Also update the processed canvas in the left editor
                const processedCanvas = document.getElementById('processed-canvas');
                if (processedCanvas) {
                    const ctx = processedCanvas.getContext('2d');
                    // Draw the cropped image processed at the selected grid size
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = selectedGridSize;
                    tempCanvas.height = selectedGridSize;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0, selectedGridSize, selectedGridSize);
                    
                    // Apply same processing as processImage
                    const imageData = tempCtx.getImageData(0, 0, selectedGridSize, selectedGridSize);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                        const bp = editorSettings.blackPoint ?? 0;
                        const wp = editorSettings.whitePoint ?? 255;
                        gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                        gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                        gray = gray * editorSettings.brightness;
                        gray = Math.max(0, Math.min(255, gray));

                        const base = [0,85,170,255];
                        const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                        const indices = [];
                        for (let k = 0; k < n; k++) {
                            const idx = Math.round((k*(base.length-1))/(n-1));
                            indices.push(base[idx]);
                        }
                        let finalColor = indices[indices.length-1];
                        for (let t = 0; t < indices.length-1; t++) {
                            const mid = (indices[t] + indices[t+1]) / 2;
                            if (gray < mid) { finalColor = indices[t]; break; }
                        }

                        data[i] = finalColor;
                        data[i + 1] = finalColor;
                        data[i + 2] = finalColor;
                    }
                    
                    tempCtx.putImageData(imageData, 0, 0);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(tempCanvas, 0, 0, processedCanvas.width, processedCanvas.height);
                }
                // Redraw crop box with new image
                setTimeout(() => {
                    if (cropperVisible) {
                        showCropper(); // Reinitialize cropper
                    }
                }, 100);
            };
            img.src = newCanvas.toDataURL();
        }

        // Paint Functions
        function selectPaintColor(r, g, b, element) {
            selectedPaintColor = { r, g, b };
            // Update selected state
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.classList.remove('selected');
            });
            element.classList.add('selected');
            console.log('Selected paint color:', selectedPaintColor);
            
            // When selecting a color, automatically switch to paint mode
            if (eraserMode) {
                togglePaintMode();
            }
        }
        
        // Toggle paint mode
        function togglePaintMode() {
            paintMode = true;
            eraserMode = false;
            
            // Update button styles
            const paintBtn = document.getElementById('mobile-paint-mode-btn');
            const eraserBtn = document.getElementById('mobile-eraser-btn');
            
            if (paintBtn) {
                paintBtn.style.background = '#E87D3E';
                paintBtn.style.borderColor = '#E87D3E';
                paintBtn.querySelector('span').style.color = '#FFFFFF';
            }
            if (eraserBtn) {
                eraserBtn.style.background = 'transparent';
                eraserBtn.style.borderColor = '#333';
                eraserBtn.querySelectorAll('span').forEach(span => span.style.color = '#333');
            }
            
            console.log('Paint mode activated');
        }
        
        // Toggle eraser mode
        function toggleEraserMode() {
            eraserMode = true;
            paintMode = false;
            
            // Update button styles
            const paintBtn = document.getElementById('mobile-paint-mode-btn');
            const eraserBtn = document.getElementById('mobile-eraser-btn');
            
            if (paintBtn) {
                paintBtn.style.background = 'transparent';
                paintBtn.style.borderColor = '#333';
                paintBtn.querySelector('span').style.color = '#E87D3E';
            }
            if (eraserBtn) {
                eraserBtn.style.background = '#333';
                eraserBtn.style.borderColor = '#333';
                eraserBtn.querySelectorAll('span').forEach(span => span.style.color = '#FFFFFF');
            }
            
            console.log('Eraser mode activated');
        }

        function zoomInProcessed() {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            // Zoom in at the center of the canvas
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            
            // Zoom factor
            const zoomFactor = 1.5;
            const newZoom = Math.min(processedZoom * zoomFactor, 10);
            
            // Calculate new offset so center stays at center
            const imageX = (centerX - w/2 - processedZoomOffsetX) / processedZoom;
            const imageY = (centerY - h/2 - processedZoomOffsetY) / processedZoom;
            const newOffsetX = centerX - w/2 - imageX * newZoom;
            const newOffsetY = centerY - h/2 - imageY * newZoom;
            
            processedZoom = newZoom;
            processedZoomOffsetX = newOffsetX;
            processedZoomOffsetY = newOffsetY;
            
            constrainPanBounds(processedZoom);
            redrawProcessedCanvas();
            
            // Deactivate any modes
            zoomMode = null;
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            if (zoomInBtn) zoomInBtn.style.background = '#E0E0E0';
            if (zoomOutBtn) zoomOutBtn.style.background = '#E0E0E0';
        }

        function zoomOutProcessed() {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            // Zoom out at the center of the canvas
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            
            // Zoom factor
            const zoomFactor = 1.5;
            const minZoom = 1.0;
            const newZoom = Math.max(processedZoom / zoomFactor, minZoom);
            
            // Calculate new offset so center stays at center
            const imageX = (centerX - w/2 - processedZoomOffsetX) / processedZoom;
            const imageY = (centerY - h/2 - processedZoomOffsetY) / processedZoom;
            const newOffsetX = centerX - w/2 - imageX * newZoom;
            const newOffsetY = centerY - h/2 - imageY * newZoom;
            
            processedZoom = newZoom;
            processedZoomOffsetX = newOffsetX;
            processedZoomOffsetY = newOffsetY;
            
            constrainPanBounds(processedZoom);
            redrawProcessedCanvas();
            
            // Deactivate any modes
            zoomMode = null;
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            if (zoomInBtn) zoomInBtn.style.background = '#E0E0E0';
            if (zoomOutBtn) zoomOutBtn.style.background = '#E0E0E0';
        }

        function resetZoomProcessed() {
            processedZoom = 1.0;
            processedZoomOffsetX = 0;
            processedZoomOffsetY = 0;
            zoomMode = null;
            
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const resetBtn = document.getElementById('processed-reset-btn');
            
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            if (zoomInBtn) zoomInBtn.style.background = '#E0E0E0';
            if (zoomOutBtn) zoomOutBtn.style.background = '#E0E0E0';
            if (resetBtn) resetBtn.style.background = '#E0E0E0';
            
            redrawProcessedCanvas();
        }
        
        // Function to deactivate all zoom/pan modes
        function deactivateZoomPanModes() {
            zoomMode = null;
            
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            if (zoomInBtn) zoomInBtn.style.background = '#E0E0E0';
            if (zoomOutBtn) zoomOutBtn.style.background = '#E0E0E0';
        }
        
        function zoomToPoint(x, y, zoomFactor) {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            const rect = processedCanvas.getBoundingClientRect();
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            
            // Convert click position to canvas coordinates (absolute, not relative to center)
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            
            // Calculate the point in image space that corresponds to this canvas click
            // In redrawProcessedCanvas, transforms are:
            // 1. translate(w/2, h/2) - center
            // 2. translate(offsetX, offsetY) - pan
            // 3. scale(zoom, zoom)
            // 4. draw at (-w/2, -h/2)
            // So: canvasX = imageX * zoom + offsetX + w/2
            // Therefore: imageX = (canvasX - w/2 - offsetX) / zoom
            const imageX = (canvasX - w/2 - processedZoomOffsetX) / processedZoom;
            const imageY = (canvasY - h/2 - processedZoomOffsetY) / processedZoom;
            
            // Calculate new zoom level
            // For zoom out, limit to minimum zoom that doesn't show whitespace (image should fill at least the canvas)
            const minZoom = 1.0; // Don't zoom out past original size
            const newZoom = zoomMode === 'zoom-in' 
                ? Math.min(processedZoom * zoomFactor, 10)
                : Math.max(processedZoom / zoomFactor, minZoom);
            
            // Calculate new offset so the clicked image point stays at the same canvas position
            // After zoom: canvasX = imageX * newZoom + newOffsetX + w/2
            // So: newOffsetX = canvasX - w/2 - imageX * newZoom
            const newOffsetX = canvasX - w/2 - imageX * newZoom;
            const newOffsetY = canvasY - h/2 - imageY * newZoom;
            
            // Constrain offsets to prevent showing whitespace
            constrainPanBounds(newZoom);
            
            // Update zoom and offset
            processedZoom = newZoom;
            processedZoomOffsetX = newOffsetX;
            processedZoomOffsetY = newOffsetY;
            
            // Apply bounds again after setting
            constrainPanBounds(processedZoom);
            
            redrawProcessedCanvas();
        }
        
        function constrainPanBounds(zoom) {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            
            // Calculate the maximum allowed offset to keep image within bounds
            // When zoomed, the image is scaled, so we need to prevent panning too far
            // Image is drawn at (-w/2, -h/2) with size (w, h) before transforms
            // After scale(zoom), the visible image size becomes w*zoom, h*zoom
            // We want to constrain so that image edges stay within canvas bounds
            
            // Maximum offset should keep the image edges visible
            // If zoom >= 1, we can pan more freely
            // If zoom < 1, we should limit panning to keep image centered
            if (zoom >= 1.0) {
                // When zoomed in, allow more panning
                const maxOffset = (w * zoom - w) / 2;
                processedZoomOffsetX = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetX));
                processedZoomOffsetY = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetY));
            } else {
                // When zoomed out, limit panning to keep image visible
                // At zoom 1.0, offset should be 0
                const maxOffset = w * (1 - zoom) / 2;
                processedZoomOffsetX = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetX));
                processedZoomOffsetY = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetY));
            }
        }

        function redrawProcessedCanvas() {
            if (!processedImageData) return;
            
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            const processedCtx = processedCanvas.getContext('2d');
            
            // Create temp canvas at actual image size (full resolution for posterized, pixel size for others)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = processedImageData.width;
            tempCanvas.height = processedImageData.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(processedImageData, 0, 0);
            
            // Get display size (may be different from canvas internal size)
            const displayWidth = processedCanvas.width;
            const displayHeight = processedCanvas.height;
            
            // Clear and redraw with zoom
            processedCtx.clearRect(0, 0, displayWidth, displayHeight);
            
            if (processedZoom === 1.0 && processedZoomOffsetX === 0 && processedZoomOffsetY === 0) {
                // No zoom, just draw normally
                processedCtx.imageSmoothingEnabled = false;
                processedCtx.drawImage(tempCanvas, 0, 0, displayWidth, displayHeight);
            } else {
                // Draw with zoom and offset
                // The image is drawn centered, then scaled and translated
                processedCtx.save();
                // Translate to center, then apply offset, then scale
                processedCtx.translate(displayWidth / 2, displayHeight / 2);
                processedCtx.translate(processedZoomOffsetX, processedZoomOffsetY);
                processedCtx.scale(processedZoom, processedZoom);
                processedCtx.imageSmoothingEnabled = false;
                // Draw image centered at origin (before transforms)
                processedCtx.drawImage(tempCanvas, -displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                processedCtx.restore();
            }
        }

        // Paint pixel function with brush size support
        function paintPixelAt(clickX, clickY, processedCanvas) {
            if (!processedImageData) return false;
            
            const imageWidth = processedImageData.width;
            const imageHeight = processedImageData.height;
            
            // Convert to pixel coordinates
            const pixelX = Math.floor((clickX / processedCanvas.width) * imageWidth);
            const pixelY = Math.floor((clickY / processedCanvas.height) * imageHeight);
            
            let painted = false;
            
            // Use square brush for all pixelated modes
            {
                // Square brush for pixelated mode
                // Calculate the start position (top-left corner of the square)
                // Center the brush on the click position
                const startX = pixelX - Math.floor(brushSize / 2);
                const startY = pixelY - Math.floor(brushSize / 2);
                
                // Paint all pixels in the NxN square
                for (let dy = 0; dy < brushSize; dy++) {
                    for (let dx = 0; dx < brushSize; dx++) {
                        const x = startX + dx;
                        const y = startY + dy;
                        
                        // Ensure within bounds
                        if (x >= 0 && x < imageWidth && y >= 0 && y < imageHeight) {
                            // Update pixel color in image data
                            const index = (y * imageWidth + x) * 4;
                            
                            if (eraserMode && originalProcessedImageData) {
                                // Eraser mode: restore original pixel color
                                processedImageData.data[index] = originalProcessedImageData.data[index];         // R
                                processedImageData.data[index + 1] = originalProcessedImageData.data[index + 1]; // G
                                processedImageData.data[index + 2] = originalProcessedImageData.data[index + 2]; // B
                                processedImageData.data[index + 3] = originalProcessedImageData.data[index + 3]; // A
                            } else {
                                // Paint mode: use selected color
                                processedImageData.data[index] = selectedPaintColor.r;     // R
                                processedImageData.data[index + 1] = selectedPaintColor.g; // G
                                processedImageData.data[index + 2] = selectedPaintColor.b; // B
                                processedImageData.data[index + 3] = 255;                  // A
                            }
                            painted = true;
                        }
                    }
                }
            }
            
            return painted;
        }

        // Add click and drag handlers to processed canvas for pixel painting
        let isPainting = false;
        
        // Helper function to check if paint panel is active
        function isPaintPanelActive() {
            const paintPanel = document.getElementById('paint-panel');
            return paintPanel && paintPanel.classList.contains('active');
        }
        
        // Helper function to check if adjust or size panel is active (for zoom/drag)
        function isAdjustOrSizePanelActive() {
            const adjustPanel = document.getElementById('adjust-panel');
            const sizePanel = document.getElementById('size-panel');
            return (adjustPanel && adjustPanel.classList.contains('active')) ||
                   (sizePanel && sizePanel.classList.contains('active'));
        }
        
        // Set up paint event listeners (called after DOM loads and when canvas is recreated)
        function setupPaintHandlers() {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            // Use a flag to prevent duplicate listeners
            if (processedCanvas.dataset.paintHandlersSetup === 'true') return;
            processedCanvas.dataset.paintHandlersSetup = 'true';
            
            let isDraggingPan = false;
            
            processedCanvas.addEventListener('mousedown', (e) => {
                if (zoomMode === 'zoom-in') {
                    // Zoom in to the clicked point
                    zoomToPoint(e.clientX, e.clientY, 1.3);
                } else if (zoomMode === 'zoom-out') {
                    // Zoom out from the clicked point
                    zoomToPoint(e.clientX, e.clientY, 1.3);
                } else if (processedZoom > 1.0 && isAdjustOrSizePanelActive() && !isDraggingPan) {
                    // On Adjust/Size tabs when zoomed: start panning
                    isDraggingPan = true;
                    isPainting = false;
                    processedPanStartX = e.clientX;
                    processedPanStartY = e.clientY;
                    processedCanvas.dataset.panStartOffsetX = processedZoomOffsetX;
                    processedCanvas.dataset.panStartOffsetY = processedZoomOffsetY;
                } else if (processedImageData && !isDraggingPan && isPaintPanelActive()) {
                    // Start painting (only if paint panel is active and not in pan mode)
                    // Save state to undo stack before starting to paint
                    if (!isPainting) {
                        savePaintState();
                    }
                    isPainting = true;
                    const rect = processedCanvas.getBoundingClientRect();
                    
                    // Get actual displayed size and internal canvas size
                    const displayWidth = rect.width;
                    const displayHeight = rect.height;
                    const canvasWidth = processedCanvas.width;
                    const canvasHeight = processedCanvas.height;
                    
                    // Convert mouse position to canvas coordinates (accounting for display vs internal size)
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Scale to internal canvas coordinates
                    const canvasX = (mouseX / displayWidth) * canvasWidth;
                    const canvasY = (mouseY / displayHeight) * canvasHeight;
                    
                    // Convert to coordinates relative to center (image is drawn centered)
                    const centerRelativeX = canvasX - canvasWidth / 2;
                    const centerRelativeY = canvasY - canvasHeight / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert back to canvas coordinates (0 to canvasWidth/Height)
                    const normalizedX = imageSpaceX + canvasWidth / 2;
                    const normalizedY = imageSpaceY + canvasHeight / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                }
            });
        
            processedCanvas.addEventListener('mousemove', (e) => {
                if (isDraggingPan && !isPainting) {
                    // Pan the view - calculate delta from start position
                    const deltaX = e.clientX - processedPanStartX;
                    const deltaY = e.clientY - processedPanStartY;
                    const startOffsetX = parseFloat(processedCanvas.dataset.panStartOffsetX || 0);
                    const startOffsetY = parseFloat(processedCanvas.dataset.panStartOffsetY || 0);
                    
                    // Update offset based on drag delta
                    processedZoomOffsetX = startOffsetX + deltaX;
                    processedZoomOffsetY = startOffsetY + deltaY;
                    
                    // Constrain to bounds
                    constrainPanBounds(processedZoom);
                    
                    redrawProcessedCanvas();
                } else if (isPainting && processedImageData && !isDraggingPan && isPaintPanelActive()) {
                    // Continue painting (only if paint panel is active and not in pan mode)
                    const rect = processedCanvas.getBoundingClientRect();
                    
                    // Get actual displayed size and internal canvas size
                    const displayWidth = rect.width;
                    const displayHeight = rect.height;
                    const canvasWidth = processedCanvas.width;
                    const canvasHeight = processedCanvas.height;
                    
                    // Convert mouse position to canvas coordinates
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Scale to internal canvas coordinates
                    const canvasX = (mouseX / displayWidth) * canvasWidth;
                    const canvasY = (mouseY / displayHeight) * canvasHeight;
                    
                    // Convert to coordinates relative to center
                    const centerRelativeX = canvasX - canvasWidth / 2;
                    const centerRelativeY = canvasY - canvasHeight / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert back to canvas coordinates
                    const normalizedX = imageSpaceX + canvasWidth / 2;
                    const normalizedY = imageSpaceY + canvasHeight / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                }
            });
            
            processedCanvas.addEventListener('mouseup', () => {
                if (isPainting) {
                    // Paint stroke finished - update undo/redo buttons
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
            
            processedCanvas.addEventListener('mouseleave', () => {
                if (isPainting) {
                    // Paint stroke finished - update undo/redo buttons
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
            
            // MOBILE TOUCH EVENTS - Add touch support for mobile devices
            processedCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                e.stopPropagation();
                
                if (!processedImageData) return;
                
                const touch = e.touches[0];
                const rect = processedCanvas.getBoundingClientRect();
                
                if (zoomMode === 'zoom-in') {
                    zoomToPoint(touch.clientX, touch.clientY, 1.3);
                } else if (zoomMode === 'zoom-out') {
                    zoomToPoint(touch.clientX, touch.clientY, 1.3);
                } else if (e.touches.length >= 2 && processedZoom > 1.0) {
                    // Two-finger start: always initialize pan (works on any tab when zoomed)
                    isPainting = false; // Stop any painting
                    isDraggingPan = true;
                    // Use center point between two fingers
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    processedPanStartX = (touch1.clientX + touch2.clientX) / 2;
                    processedPanStartY = (touch1.clientY + touch2.clientY) / 2;
                    processedCanvas.dataset.panStartOffsetX = processedZoomOffsetX;
                    processedCanvas.dataset.panStartOffsetY = processedZoomOffsetY;
                } else if (processedZoom > 1.0 && isAdjustOrSizePanelActive() && e.touches.length === 1 && !isDraggingPan) {
                    // On Adjust/Size tabs when zoomed: single-finger drag for panning
                    isDraggingPan = true;
                    isPainting = false;
                    const touch = e.touches[0];
                    processedPanStartX = touch.clientX;
                    processedPanStartY = touch.clientY;
                    processedCanvas.dataset.panStartOffsetX = processedZoomOffsetX;
                    processedCanvas.dataset.panStartOffsetY = processedZoomOffsetY;
                } else if (e.touches.length === 1 && !isDraggingPan && isPaintPanelActive()) {
                    // Single-finger paint (only if paint panel is active)
                    if (!isPainting) {
                        savePaintState();
                    }
                    isPainting = true;
                    
                    // Get actual displayed size and internal canvas size
                    const displayWidth = rect.width;
                    const displayHeight = rect.height;
                    const canvasWidth = processedCanvas.width;
                    const canvasHeight = processedCanvas.height;
                    
                    // Convert touch position to canvas coordinates
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Scale to internal canvas coordinates
                    const canvasX = (touchX / displayWidth) * canvasWidth;
                    const canvasY = (touchY / displayHeight) * canvasHeight;
                    
                    // Convert to coordinates relative to center
                    const centerRelativeX = canvasX - canvasWidth / 2;
                    const centerRelativeY = canvasY - canvasHeight / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert back to canvas coordinates
                    const normalizedX = imageSpaceX + canvasWidth / 2;
                    const normalizedY = imageSpaceY + canvasHeight / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                }
            });
            
            processedCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent scrolling
                e.stopPropagation();
                
                if (!processedImageData) return;
                
                const rect = processedCanvas.getBoundingClientRect();
                
                // Check for two-finger drag first (for panning)
                if (e.touches.length >= 2 && processedZoom > 1.0) {
                    // Two-finger pan: calculate center point between fingers
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentCenterX = (touch1.clientX + touch2.clientX) / 2;
                    const currentCenterY = (touch1.clientY + touch2.clientY) / 2;
                    
                    // Stop painting if we're panning
                    if (isPainting) {
                        isPainting = false;
                        updateUndoRedoButtons();
                    }
                    
                    // Start panning if not already
                    if (!isDraggingPan) {
                        isDraggingPan = true;
                        processedPanStartX = currentCenterX;
                        processedPanStartY = currentCenterY;
                        processedCanvas.dataset.panStartOffsetX = processedZoomOffsetX;
                        processedCanvas.dataset.panStartOffsetY = processedZoomOffsetY;
                    }
                    
                    // Calculate delta from start position
                    const deltaX = currentCenterX - processedPanStartX;
                    const deltaY = currentCenterY - processedPanStartY;
                    const startOffsetX = parseFloat(processedCanvas.dataset.panStartOffsetX || 0);
                    const startOffsetY = parseFloat(processedCanvas.dataset.panStartOffsetY || 0);
                    
                    // Update pan position
                    processedZoomOffsetX = startOffsetX + deltaX;
                    processedZoomOffsetY = startOffsetY + deltaY;
                    constrainPanBounds(processedZoom);
                    redrawProcessedCanvas();
                } else if (e.touches.length === 1 && isDraggingPan && isAdjustOrSizePanelActive()) {
                    // Continue one-finger pan on Adjust/Size tabs when zoomed
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - processedPanStartX;
                    const deltaY = touch.clientY - processedPanStartY;
                    const startOffsetX = parseFloat(processedCanvas.dataset.panStartOffsetX || 0);
                    const startOffsetY = parseFloat(processedCanvas.dataset.panStartOffsetY || 0);
                    
                    processedZoomOffsetX = startOffsetX + deltaX;
                    processedZoomOffsetY = startOffsetY + deltaY;
                    constrainPanBounds(processedZoom);
                    redrawProcessedCanvas();
                } else if (e.touches.length === 1 && !isDraggingPan && isPainting && isPaintPanelActive()) {
                    // Continue painting with single finger (only if paint panel is active)
                    const touch = e.touches[0];
                    // Get actual displayed size and internal canvas size
                    const displayWidth = rect.width;
                    const displayHeight = rect.height;
                    const canvasWidth = processedCanvas.width;
                    const canvasHeight = processedCanvas.height;
                    
                    // Convert touch position to canvas coordinates
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    // Scale to internal canvas coordinates
                    const canvasX = (touchX / displayWidth) * canvasWidth;
                    const canvasY = (touchY / displayHeight) * canvasHeight;
                    
                    // Convert to coordinates relative to center
                    const centerRelativeX = canvasX - canvasWidth / 2;
                    const centerRelativeY = canvasY - canvasHeight / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert back to canvas coordinates
                    const normalizedX = imageSpaceX + canvasWidth / 2;
                    const normalizedY = imageSpaceY + canvasHeight / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                } else if (e.touches.length === 1 && isDraggingPan) {
                    // Single finger while pan was active - stop panning
                    isDraggingPan = false;
                }
            });
            
            processedCanvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (isPainting) {
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
            
            processedCanvas.addEventListener('touchcancel', () => {
                if (isPainting) {
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
        }
        
        // Call setup when page loads
        // Detect Shopify embedded context and lock scrolling
        (function() {
            // Check if we're in an iframe (Shopify embedded)
            const isInIframe = window.self !== window.top;
            // Check if Shopify context is detected
            const isShopifyContext = window.Shopify || window.parent.Shopify || 
                                    window.location.search.includes('shopify') ||
                                    window.location.hostname.includes('myshopify.com');
            
            if (isInIframe || isShopifyContext) {
                document.documentElement.classList.add('shopify-embedded');
                document.body.classList.add('shopify-embedded');
                const mainContainer = document.querySelector('.main-container');
                if (mainContainer) {
                    mainContainer.classList.add('shopify-embedded');
                }
                const viewerPanel = document.querySelector('.viewer-panel');
                if (viewerPanel) {
                    viewerPanel.classList.add('shopify-embedded');
                }
                const controlPanel = document.querySelector('.control-panel');
                if (controlPanel) {
                    controlPanel.classList.add('shopify-embedded');
                }
                // Lock scrolling - prevent free scrolling
                document.body.style.overflow = 'hidden';
                document.documentElement.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                document.body.style.height = '100vh';
            }
        })();

        // Don't restore image state on page load - always start fresh
        // This ensures users always see the upload screen when they first visit
        // window.addEventListener('load', () => {
        //     console.log('üìÇ Page loaded, checking for saved image state...');
        //     const hasRestoredImage = restoreImageState();
        //     if (hasRestoredImage) {
        //         console.log('‚úÖ Image state restored, editor should be visible');
        //     } else {
        //         console.log('üìÇ No image state to restore, showing upload screen');
        //     }
        // });
        
        window.addEventListener('load', () => {
            setupPaintHandlers();
            
            // Deactivate zoom modes when clicking outside the canvas or buttons
            document.addEventListener('click', (e) => {
                const processedCanvas = document.getElementById('processed-canvas');
                const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
                const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
                const resetBtn = document.getElementById('processed-reset-btn');
                
                // Check if click is outside canvas and outside all zoom buttons
                const isClickOnCanvas = processedCanvas && processedCanvas.contains(e.target);
                const isClickOnZoomIn = zoomInBtn && (zoomInBtn.contains(e.target) || zoomInBtn === e.target);
                const isClickOnZoomOut = zoomOutBtn && (zoomOutBtn.contains(e.target) || zoomOutBtn === e.target);
                const isClickOnReset = resetBtn && (resetBtn.contains(e.target) || resetBtn === e.target);
                
                // If click is outside all these elements, deactivate modes
                if (!isClickOnCanvas && !isClickOnZoomIn && !isClickOnZoomOut && !isClickOnReset) {
                    deactivateZoomPanModes();
                }
            });
            
            // Reset dragging when mouse is released
            const processedCanvasForEvents = document.getElementById('processed-canvas');
            if (processedCanvasForEvents) {
                processedCanvasForEvents.addEventListener('mouseup', () => {
                    isDraggingPan = false;
                });
                
                processedCanvasForEvents.addEventListener('mouseleave', () => {
                    isDraggingPan = false;
                });
            }
        });

        // Brush size slider
        document.getElementById('brush-size-slider').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brush-size-value').textContent = brushSize;
        });

        // Reset processed image to original state
        function resetProcessedImage() {
            if (!originalProcessedImageData) {
                console.log('No original image data to reset to');
                return;
            }
            
            // Restore the original image data
            processedImageData = new ImageData(
                new Uint8ClampedArray(originalProcessedImageData.data),
                originalProcessedImageData.width,
                originalProcessedImageData.height
            );
            
            // Redraw the canvas
            redrawProcessedCanvas();
            
            // Clear undo/redo stacks on reset
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
            
            console.log('‚úÖ Image reset to original state');
        }

        // Save current paint state to undo stack
        function savePaintState() {
            if (!processedImageData) return;
            
            // Create a deep copy of the current image data
            const stateCopy = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            
            // Save to undo stack
            undoStack.push(stateCopy);
            
            // Clear redo stack when new paint happens
            redoStack = [];
            
            // Limit undo stack size to prevent memory issues (keep last 50 states)
            if (undoStack.length > 50) {
                undoStack.shift();
            }
            
            // Show undo/redo buttons
            document.getElementById('undo-redo-buttons').style.display = 'flex';
            updateUndoRedoButtons();
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const undoRedoContainer = document.getElementById('undo-redo-buttons');
            
            if (!undoBtn || !redoBtn || !undoRedoContainer) return;
            
            if (undoStack.length === 0 && redoStack.length === 0) {
                // Hide buttons if no history
                undoRedoContainer.style.display = 'none';
            } else {
                // Show buttons if there's history
                undoRedoContainer.style.display = 'flex';
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
        }

        // Undo last paint operation
        function undoPaint() {
            if (undoStack.length === 0 || !processedImageData) return;
            
            // Save current state to redo stack before undoing
            const currentState = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            redoStack.push(currentState);
            
            // Restore previous state from undo stack
            const previousState = undoStack.pop();
            processedImageData = new ImageData(
                new Uint8ClampedArray(previousState.data),
                previousState.width,
                previousState.height
            );
            
            // Redraw canvas
            redrawProcessedCanvas();
            
            // Update button states
            updateUndoRedoButtons();
        }

        // Redo last undone paint operation
        function redoPaint() {
            if (redoStack.length === 0 || !processedImageData) return;
            
            // Save current state to undo stack before redoing
            const currentState = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            undoStack.push(currentState);
            
            // Restore next state from redo stack
            const nextState = redoStack.pop();
            processedImageData = new ImageData(
                new Uint8ClampedArray(nextState.data),
                nextState.width,
                nextState.height
            );
            
            // Redraw canvas
            redrawProcessedCanvas();
            
            // Update button states
            updateUndoRedoButtons();
        }

        // Keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            // Check if we're in the editor panel (painting is active)
            const editorPanel = document.getElementById('editor-panel');
            if (!editorPanel || editorPanel.style.display === 'none') return;
            
            // Check if user is typing in an input field (don't intercept)
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                return;
            }
            
            // Cmd+Z (Mac) or Ctrl+Z (Windows/Linux) for undo
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoPaint();
            }
            
            // Cmd+Shift+Z (Mac) or Ctrl+Y (Windows/Linux) for redo
            if ((e.metaKey && e.shiftKey && e.key === 'z') || (e.ctrlKey && e.key === 'y')) {
                e.preventDefault();
                redoPaint();
            }
        });

        // Slider event listeners
        document.getElementById('contrast-slider').addEventListener('input', (e) => {
            editorSettings.contrast = parseFloat(e.target.value);
            document.getElementById('contrast-value').textContent = e.target.value;
            processImage();
        });

        document.getElementById('brightness-slider').addEventListener('input', (e) => {
            editorSettings.brightness = parseFloat(e.target.value);
            document.getElementById('brightness-value').textContent = e.target.value;
            processImage();
        });

        document.getElementById('tones-slider').addEventListener('input', (e) => {
            editorSettings.tones = parseInt(e.target.value);
            document.getElementById('tones-value').textContent = `${editorSettings.tones}`;
            processImage();
        });

        document.getElementById('denoise-slider').addEventListener('input', (e) => {
            editorSettings.denoise = parseFloat(e.target.value);
            document.getElementById('denoise-value').textContent = editorSettings.denoise.toFixed(1);
            processImage();
        });

        // Initialize Three.js
        function initThree() {
            // Don't reinitialize if already initialized
            if (scene && camera && renderer) {
                console.log('Three.js already initialized');
                return;
            }
            
            const container = document.getElementById('canvas-container');
            if (!container) {
                console.error('‚ùå canvas-container not found');
                return;
            }
            
            const width = container.clientWidth || window.innerWidth;
            const height = container.clientHeight || window.innerHeight;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfafafa);
            
            // Add lights to show geometry details and textures
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft overall lighting
            scene.add(ambientLight);
            
            // Main directional light from above-left
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(50, 100, 50);
            directionalLight1.castShadow = false;
            scene.add(directionalLight1);
            
            // Secondary directional light from opposite side for fill
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-50, 50, -50);
            directionalLight2.castShadow = false;
            scene.add(directionalLight2);

            // Camera
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(100, 100, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width || window.innerWidth, height || 600, true);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Grid - REMOVED per user request (no grid plane in 3D viewer)
            // const gridHelper = new THREE.GridHelper(200, 20, 0xcccccc, 0xe0e0e0);
            // scene.add(gridHelper);

            // Animate
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                const w = container.clientWidth || window.innerWidth;
                const h = container.clientHeight || window.innerHeight - 200;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h, true);
            });
        }

        // Auto tune contrast/brightness using percentile stretch (P5..P95)
        function autoTuneSettingsFromImage(img) {
            try {
                const tmp = document.createElement('canvas');
                const s = 128;
                tmp.width = s; tmp.height = s;
                const ctx = tmp.getContext('2d');
                ctx.drawImage(img, 0, 0, s, s);
                const d = ctx.getImageData(0, 0, s, s).data;
                const values = [];
                for (let i = 0; i < d.length; i += 4) {
                    values.push(0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]);
                }
                values.sort((a,b)=>a-b);
                const q = (p)=> values[Math.max(0, Math.min(values.length-1, Math.floor(p*(values.length-1))))];
                const p5 = q(0.05);
                const p95 = q(0.95);
                editorSettings.blackPoint = Math.max(0, Math.min(254, Math.round(p5)));
                editorSettings.whitePoint = Math.max(editorSettings.blackPoint+1, Math.min(255, Math.round(p95)));
                // Keep C/B neutral post stretch
                editorSettings.contrast = 1.0;
                editorSettings.brightness = 1.0;
                saveSimpleState();
            } catch (e) {
                editorSettings.blackPoint = 0;
                editorSettings.whitePoint = 255;
                editorSettings.contrast = 1.0;
                editorSettings.brightness = 1.0;
            }
        }

        // Load STL file (returns Promise)
        function loadSTL(file) {
            return new Promise((resolve, reject) => {
                if (!file) {
                    reject(new Error('No STL file provided'));
                    return;
                }
                
                // Ensure Three.js is initialized before loading STL
                if (!scene || !camera || !renderer) {
                    console.log('‚ö†Ô∏è Three.js not initialized yet, initializing now...');
                    try {
                        initThree();
                    } catch (error) {
                        console.error('‚ùå Failed to initialize Three.js:', error);
                        reject(new Error('Failed to initialize Three.js: ' + error.message));
                        return;
                    }
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const loader = new THREE.STLLoader();
                        let geometry = loader.parse(event.target.result);

                        // Ensure per-triangle unique vertices so colors don't bleed across shared vertices
                        if (geometry.index) {
                            geometry = geometry.toNonIndexed();
                        }

                        // Store original geometry
                        originalGeometry = geometry.clone();

                        // Remove old mesh
                        if (currentMesh && scene) {
                            scene.remove(currentMesh);
                        }

                        // Use vertex colors with MeshStandardMaterial for all pixelated modes (48x48, 75x75, 96x96)
                        let material = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            vertexColors: true,
                            side: THREE.DoubleSide,
                            flatShading: false,
                            metalness: 0.1,
                            roughness: 0.7
                        });
                        currentMesh = new THREE.Mesh(geometry, material);

                        // Center the mesh
                        geometry.computeBoundingBox();
                        const center = new THREE.Vector3();
                        geometry.boundingBox.getCenter(center);
                        currentMesh.position.sub(center);

                        if (!scene) {
                            reject(new Error('Scene not initialized'));
                            return;
                        }
                        
                        scene.add(currentMesh);

                        // Hide placeholder
                        const placeholder = document.getElementById('three-placeholder');
                        if (placeholder) {
                            placeholder.style.display = 'none';
                        }

                        // Fit camera
                        if (camera && controls) {
                            const box = new THREE.Box3().setFromObject(currentMesh);
                            const size = box.getSize(new THREE.Vector3());
                            const maxDim = Math.max(size.x, size.y, size.z);
                            camera.position.set(maxDim, maxDim, maxDim);
                            controls.target.set(0, 0, 0);
                            controls.update();
                        }

                        // Apply colors if PNG is already loaded
                        if (pngImage) {
                            applyColorsToMesh();
                        }
                        
                        console.log('‚úÖ STL mesh loaded and displayed successfully');
                        resolve(currentMesh);
                    } catch (error) {
                        console.error('‚ùå Error parsing STL file:', error);
                        reject(error);
                    }
                };
                reader.onerror = function(error) {
                    console.error('‚ùå Error reading STL file:', error);
                    reject(error);
                };
                reader.readAsArrayBuffer(file);
            });
        }

        // Apply PNG colors to the 3D mesh
        function applyColorsToMesh() {
            if (!currentMesh || !pngImage || !originalGeometry) return;

            console.log('Applying colors to mesh...');

            const geometry = currentMesh.geometry;
            const positions = geometry.attributes.position;
            const vertices = [];
            
            // Get all vertices
            for (let i = 0; i < positions.count; i++) {
                vertices.push(new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                ));
            }

            // Compute XY bounds based ONLY on near-horizontal (top) faces to avoid side thickness skew
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const faceCount = positions.count / 3;
            for (let f = 0; f < faceCount; f++) {
                const a = f * 3, b = a + 1, c = a + 2;
                const v0 = vertices[a], v1 = vertices[b], v2 = vertices[c];
                // Face normal
                const abx = v1.x - v0.x, aby = v1.y - v0.y, abz = v1.z - v0.z;
                const acx = v2.x - v0.x, acy = v2.y - v0.y, acz = v2.z - v0.z;
                const nx = aby * acz - abz * acy;
                const ny = abz * acx - abx * acz;
                const nz = abx * acy - aby * acx;
                const len = Math.hypot(nx, ny, nz) || 1;
                const nzUnit = nz / len;
                if (nzUnit > 0.5) { // top-ish
                    minX = Math.min(minX, v0.x, v1.x, v2.x);
                    minY = Math.min(minY, v0.y, v1.y, v2.y);
                    maxX = Math.max(maxX, v0.x, v1.x, v2.x);
                    maxY = Math.max(maxY, v0.y, v1.y, v2.y);
                }
            }
            if (!isFinite(minX) || !isFinite(minY)) {
                // Fallback to bbox if no top faces detected
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                minX = bbox.min.x; minY = bbox.min.y; maxX = bbox.max.x; maxY = bbox.max.y;
            }
            const sizeX = Math.max(1e-9, maxX - minX);
            const sizeY = Math.max(1e-9, maxY - minY);
            
            // Use vertex colors for all pixelated modes (48x48, 75x75, 96x96)
            // Create canvas to read pixel data
            const canvas = document.createElement('canvas');
            canvas.width = pngImage.width;
            canvas.height = pngImage.height;
            const ctx = canvas.getContext('2d');
            
            // Ensure image is fully loaded and not tainted
            if (!pngImage.complete || pngImage.naturalWidth === 0) {
                console.error('Image not fully loaded');
                return;
            }
            
            let imageData;
            try {
                ctx.drawImage(pngImage, 0, 0);
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Verify image data is valid (check first pixel isn't all zeros or all 255s unexpectedly)
                if (!imageData || !imageData.data || imageData.data.length === 0) {
                    console.error('Failed to get image data from canvas');
                    return;
                }
            } catch (error) {
                console.error('Canvas security error or image read error:', error);
                return;
            }

            // Create color array for each face (triangle)
            const numFaces = positions.count / 3;
            const colors = new Float32Array(positions.count * 3);

            for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
                const i0 = faceIndex * 3;
                const i1 = faceIndex * 3 + 1;
                const i2 = faceIndex * 3 + 2;

                // Get triangle centroid
                const v0 = vertices[i0];
                const v1 = vertices[i1];
                const v2 = vertices[i2];
                
                const cx = (v0.x + v1.x + v2.x) / 3;
                const cy = (v0.y + v1.y + v2.y) / 3;
                
                // DIRECT 1:1 MAPPING OVERRIDE - Force perfect grid cell to pixel mapping
                const u = Math.max(0, Math.min(0.999999, (cx - minX) / sizeX));
                const v = Math.max(0, Math.min(0.999999, (cy - minY) / sizeY));
                const grid = selectedGridSize || pngImage?.width || 75;
                
                // Direct mapping: Map normalized coords directly to grid cell index
                let cell_x = Math.floor(u * grid);
                let cell_y = Math.floor(v * grid);
                
                // Clamp to valid grid range
                cell_x = Math.max(0, Math.min(grid - 1, cell_x));
                cell_y = Math.max(0, Math.min(grid - 1, cell_y));
                
                // OVERRIDE: Direct cell-to-pixel mapping (no complex calculations)
                let px, py;
                if (grid === pngImage.width) {
                    // Perfect 1:1 mapping when grid matches image size
                    px = cell_x;
                    py = grid - 1 - cell_y; // Flip Y axis
                } else {
                    // Fallback: Scale cell index to pixel index
                    px = Math.floor((cell_x * pngImage.width) / grid);
                    py = Math.floor(((grid - 1 - cell_y) * pngImage.height) / grid);
                }
                
                // Final clamp to valid pixel range
                px = Math.max(0, Math.min(pngImage.width - 1, px));
                py = Math.max(0, Math.min(pngImage.height - 1, py));

                // Get pixel color
                const pixelIndex = (py * pngImage.width + px) * 4;
                const r = imageData.data[pixelIndex] / 255;
                const g = imageData.data[pixelIndex + 1] / 255;
                const b = imageData.data[pixelIndex + 2] / 255;

                // Apply color to all 3 vertices of this triangle
                for (let j = 0; j < 3; j++) {
                    const vertexIndex = (i0 + j) * 3;
                    colors[vertexIndex] = r;
                    colors[vertexIndex + 1] = g;
                    colors[vertexIndex + 2] = b;
                }
            }

            // Apply colors to geometry (for pixelated modes only)
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Update material to use vertex colors
            currentMesh.material.vertexColors = true;
            currentMesh.material.map = null; // Remove texture if it exists
            currentMesh.material.needsUpdate = true;
            
            // Keep smooth shading to show geometry details (bumps, cubes, textures)
            // The geometry itself has the detail - lighting will show it naturally
            if ('flatShading' in currentMesh.material) {
                currentMesh.material.flatShading = false; // Smooth shading shows surface details better
            }
            // Ensure normals are computed for proper lighting
            geometry.computeVertexNormals();
            geometry.attributes.color.needsUpdate = true;

            console.log('Colors applied successfully!');
        }

        function resetCamera() {
            if (currentMesh) {
                const box = new THREE.Box3().setFromObject(currentMesh);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim, maxDim, maxDim);
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        function toggleWireframe() {
            if (currentMesh) {
                currentMesh.material.wireframe = !currentMesh.material.wireframe;
            }
        }

        // File upload handlers
        // Load STL from server based on grid size (auto-load from admin)
        // STL files are uploaded via admin page at /admin and stored in stl_files/{size}x{size}_grid.stl
        async function loadSTLFromServer(size) {
            try {
                console.log(`üì¶ Loading STL for ${size}√ó${size} grid from admin server...`);
                const url = getApiUrl(`/get-stl/${size}`);
                console.log(`üîó Loading STL from: ${url}`);
                console.log(`üåê Backend URL: ${BACKEND_URL}`);
                
                const response = await fetch(url, {
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (!response.ok) {
                    let errorText = '';
                    try {
                        errorText = await response.text();
                        // Try to parse as JSON for better error message
                        try {
                            const errorJson = JSON.parse(errorText);
                            errorText = errorJson.error || errorText;
                        } catch (e) {
                            // Not JSON, use as-is
                        }
                    } catch (e) {
                        errorText = 'Could not read error response';
                    }
                    
                    const errorMsg = `Failed to load STL file for ${size}√ó${size} grid.\n\n` +
                        `Backend URL: ${BACKEND_URL}\n` +
                        `Request URL: ${url}\n` +
                        `Status: ${response.status} ${response.statusText}\n` +
                        `Error: ${errorText}\n\n` +
                        `Please ensure:\n` +
                        `1. Backend server is running\n` +
                        `2. STL file is uploaded via admin panel\n` +
                        `3. Backend URL is correct in the code`;
                    
                    console.error(`‚ùå Failed to load STL for size ${size}:`);
                    console.error(`   Status: ${response.status} ${response.statusText}`);
                    console.error(`   URL: ${url}`);
                    console.error(`   Backend: ${BACKEND_URL}`);
                    console.error(`   Error: ${errorText}`);
                    
                    // Throw error with detailed message
                    const detailedError = new Error(errorMsg);
                    detailedError.status = response.status;
                    detailedError.url = url;
                    detailedError.backendUrl = BACKEND_URL;
                    throw detailedError;
                }
                
                const blob = await response.blob();
                if (blob.size === 0) {
                    const errorMsg = `STL file is empty for ${size}√ó${size} grid.\n\n` +
                        `Backend URL: ${BACKEND_URL}\n` +
                        `Request URL: ${url}\n` +
                        `Please re-upload the STL file via admin panel.`;
                    console.error(`‚ùå Received empty STL file for size ${size}`);
                    throw new Error(errorMsg);
                }
                
                stlFile = new File([blob], `${size}x${size}_grid.stl`, { type: 'application/octet-stream' });
                console.log(`‚úÖ Received STL file: ${stlFile.name} (${(blob.size / 1024).toFixed(2)} KB)`);
                
                // Clear old cache and save new STL to IndexedDB for caching
                await deleteFileFromDB(dbKey('stl', size));
                await saveFileToDB(dbKey('stl', size), stlFile);
                
                // Load the STL file (this will hide the placeholder automatically)
                await loadSTL(stlFile);
                console.log(`‚úÖ Successfully loaded and displayed STL for ${size}√ó${size} grid from admin`);
            } catch (error) {
                console.error('‚ùå Error loading STL from server:');
                console.error('   Error:', error.message);
                if (error.url) console.error('   URL:', error.url);
                if (error.backendUrl) console.error('   Backend:', error.backendUrl);
                if (error.status) console.error('   Status:', error.status);
                
                // Re-throw error so caller can fall back to cache
                throw error;
            }
        }

        // STL files are now pre-uploaded and auto-loaded from server
        // No manual upload needed

        // Timestamp to prevent double-triggering on mobile (both touch and click fire)
        let lastFileInputTrigger = 0;
        const FILE_INPUT_DEBOUNCE_MS = 500;

        // Function to trigger file input click (for mobile touchscreen compatibility)
        function triggerFileInput() {
            const now = Date.now();
            // Prevent double-triggering - if triggered recently, ignore
            if (now - lastFileInputTrigger < FILE_INPUT_DEBOUNCE_MS) {
                return;
            }
            
            // Update timestamp
            lastFileInputTrigger = now;
            
            const fileInput = document.getElementById('png-input');
            if (fileInput) {
                // For mobile, we need to make the input temporarily accessible
                // Move it to a visible position temporarily
                const originalStyle = {
                    position: fileInput.style.position,
                    top: fileInput.style.top,
                    left: fileInput.style.left,
                    width: fileInput.style.width,
                    height: fileInput.style.height,
                    opacity: fileInput.style.opacity,
                    pointerEvents: fileInput.style.pointerEvents
                };
                
                // Make it accessible for click
                fileInput.style.position = 'fixed';
                fileInput.style.top = '50%';
                fileInput.style.left = '50%';
                fileInput.style.width = '200px';
                fileInput.style.height = '200px';
                fileInput.style.opacity = '0.01'; // Nearly invisible but clickable
                fileInput.style.pointerEvents = 'auto';
                fileInput.style.zIndex = '9999';
                
                // Trigger the click
                setTimeout(() => {
                    fileInput.focus();
                    fileInput.click();
                    
                    // Restore original style after a delay
                    setTimeout(() => {
                        fileInput.style.position = originalStyle.position || 'fixed';
                        fileInput.style.top = originalStyle.top || '-9999px';
                        fileInput.style.left = originalStyle.left || '-9999px';
                        fileInput.style.width = originalStyle.width || '1px';
                        fileInput.style.height = originalStyle.height || '1px';
                        fileInput.style.opacity = originalStyle.opacity || '0';
                        fileInput.style.pointerEvents = originalStyle.pointerEvents || 'none';
                        fileInput.style.zIndex = '';
                    }, 100);
                }, 10);
            }
        }

        // Simple, direct file picker trigger - works on all mobile browsers
        function triggerFileInput() {
            const now = Date.now();
            if (now - lastFileInputTrigger < FILE_INPUT_DEBOUNCE_MS) {
                return;
            }
            lastFileInputTrigger = now;
            
            const fileInput = document.getElementById('png-input');
            if (!fileInput) {
                console.error('File input not found!');
                return;
            }
            
            // Direct click - most reliable method
            fileInput.click();
        }

        // Track if handlers are already set up to prevent duplicates
        let uploadHandlersSetup = false;
        // Also set on window to persist across script blocks
        window.uploadHandlersSetup = false;
        let isProcessingFile = false; // Prevent double processing

        // Attach handlers when DOM is ready
        function setupUploadHandlers() {
            // Prevent duplicate setup - use window to persist across script blocks
            if (window.uploadHandlersSetup) {
                console.log('‚ö†Ô∏è Upload handlers already setup, skipping');
                return;
            }
            
            const fileInput = document.getElementById('png-input');
            if (!fileInput) {
                console.error('‚ùå File input not found during setup! Retrying...');
                // Retry after a short delay
                setTimeout(setupUploadHandlers, 100);
                return;
            }

            console.log('‚úÖ Setting up upload handlers');
            console.log('‚úÖ Input element found:', fileInput.id, fileInput.type, fileInput.accept);
            window.uploadHandlersSetup = true; // Mark as setup globally
            uploadHandlersSetup = true; // Also set local variable
            
            // Main input handler - attach here to ensure it's set up properly
            const mainInputHandler = async (e) => {
                console.log('üìÅ CHANGE EVENT FIRED - Main input changed');
                console.log('üìÅ Files:', e.target.files);
                console.log('üìÅ File selected:', e.target.files[0]?.name, 'Size:', e.target.files[0]?.size, 'Type:', e.target.files[0]?.type);
                
                // Check if change event actually fired with a file
                if (!e || !e.target) {
                    const errorMsg = 'Error: File input change event did not fire properly';
                    console.error('‚ùå', errorMsg);
                    if (typeof showStatus === 'function') {
                        showStatus('error', errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    return;
                }
                
                if (isProcessingFile) {
                    console.log('‚ö†Ô∏è File already being processed, skipping duplicate');
                    const errorMsg = 'Error: File is already being processed. Please wait.';
                    if (typeof showStatus === 'function') {
                        showStatus('error', errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    return;
                }
                
                const file = e.target.files[0];
                if (!file) {
                    const errorMsg = 'Error: Could not read selected file. Please try selecting the file again.';
                    console.error('‚ùå', errorMsg);
                    console.warn('‚ö†Ô∏è Files array:', e.target.files);
                    console.warn('‚ö†Ô∏è Files length:', e.target.files?.length);
                    if (typeof showStatus === 'function') {
                        showStatus('error', errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    return;
                }
                
                console.log('üìÑ Main input file selected:', file.name, 'Size:', file.size, 'Type:', file.type);
                isProcessingFile = true;
                
                // Store reference to input for later reset
                const inputElement = e.target;
                
                try {
                    await processUploadedFile(file);
                    // Only reset input value AFTER successful processing and display
                    // This allows the same file to be selected again if needed
                    inputElement.value = '';
                    console.log('‚úÖ File input value reset after successful upload');
                } catch (error) {
                    console.error('‚ùå Error processing file:', error);
                    console.error('‚ùå Error stack:', error.stack);
                    const errorMsg = `Error processing image: ${error.message || 'Unknown error occurred'}`;
                    if (typeof showStatus === 'function') {
                        showStatus('error', errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    // Reset input on error so user can try again
                    inputElement.value = '';
                } finally {
                    isProcessingFile = false;
                }
            };
            
            // Remove existing handler if any
            if (fileInput._changeHandler) {
                console.log('üîÑ Removing existing main input change handler');
                fileInput.removeEventListener('change', fileInput._changeHandler);
            }
            fileInput._changeHandler = mainInputHandler;
            fileInput.addEventListener('change', mainInputHandler);
            console.log('‚úÖ Main input change handler attached');
            console.log('‚úÖ Handler reference stored:', !!fileInput._changeHandler);
            
            // Initial upload box - label handles it via 'for' attribute
            // No need for additional click handler
            
            // Upload button in toolbar - use the overlay input
            const uploadBtn = document.getElementById('upload-btn');
            const uploadBtnInput = document.getElementById('png-input-upload-btn');
            if (uploadBtn && uploadBtnInput) {
                // Ensure overlay input is properly positioned and clickable
                uploadBtnInput.style.position = 'absolute';
                uploadBtnInput.style.top = '0';
                uploadBtnInput.style.left = '0';
                uploadBtnInput.style.width = '100%';
                uploadBtnInput.style.height = '100%';
                uploadBtnInput.style.opacity = '0';
                uploadBtnInput.style.cursor = 'pointer';
                uploadBtnInput.style.zIndex = '10';
                uploadBtnInput.style.pointerEvents = 'auto';
                
                // Process file from overlay input - ONLY if main input hasn't processed it
                uploadBtnInput.addEventListener('change', async (e) => {
                    // Check if change event actually fired
                    if (!e || !e.target) {
                        const errorMsg = 'Error: Upload button file input change event did not fire properly';
                        console.error('‚ùå', errorMsg);
                        if (typeof showStatus === 'function') {
                            showStatus('error', errorMsg);
                        } else {
                            alert(errorMsg);
                        }
                        return;
                    }
                    
                    if (isProcessingFile) {
                        const errorMsg = 'Error: File is already being processed. Please wait.';
                        console.log('‚ö†Ô∏è', errorMsg);
                        if (typeof showStatus === 'function') {
                            showStatus('error', errorMsg);
                        } else {
                            alert(errorMsg);
                        }
                        return;
                    }
                    
                    const file = e.target.files[0];
                    if (!file) {
                        const errorMsg = 'Error: Could not read selected file from upload button. Please try again.';
                        console.error('‚ùå', errorMsg);
                        if (typeof showStatus === 'function') {
                            showStatus('error', errorMsg);
                        } else {
                            alert(errorMsg);
                        }
                        return;
                    }
                    
                    console.log('Upload button file selected:', file.name);
                    isProcessingFile = true;
                    
                    // Store references to inputs for later reset
                    const overlayInput = e.target;
                    const mainInput = document.getElementById('png-input');
                    
                    // Don't sync to main input - process directly from overlay input
                    // This prevents double processing (main input would also trigger if we synced)
                    // The overlay input handles the upload directly
                    
                    try {
                        await processUploadedFile(file);
                        // Only reset input values AFTER successful processing and display
                        overlayInput.value = '';
                        if (mainInput) mainInput.value = '';
                        console.log('‚úÖ File input values reset after successful upload');
                    } catch (error) {
                        console.error('‚ùå Error processing file from upload button:', error);
                        console.error('‚ùå Error stack:', error.stack);
                        const errorMsg = `Error processing image: ${error.message || 'Unknown error occurred'}`;
                        if (typeof showStatus === 'function') {
                            showStatus('error', errorMsg);
                        } else {
                            alert(errorMsg);
                        }
                        // Reset inputs on error so user can try again
                        overlayInput.value = '';
                        if (mainInput) mainInput.value = '';
                    } finally {
                        isProcessingFile = false;
                    }
                });
            }

            // Upload area in panel - label handles it via 'for' attribute
            // DO NOT add click handlers - the label's 'for' attribute automatically triggers the input
            // Adding click handlers causes double-triggering (file picker opens twice)
            // The labels with for="png-input" will automatically handle clicks
            const uploadArea = document.getElementById('png-upload-area');
            const initialUploadBox = document.getElementById('initial-upload-box');
            
            // No click handlers needed - labels handle it automatically via 'for' attribute
            // Removing these prevents the double-trigger issue
        }

        // Setup handlers once when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupUploadHandlers);
        } else {
            setupUploadHandlers();
        }

        // SIMPLIFIED: Process uploaded file and go directly to editor
        async function processUploadedFile(file) {
            if (!file) {
                const errorMsg = 'Error: No file provided to process';
                console.error('‚ùå', errorMsg);
                if (typeof showStatus === 'function') {
                    showStatus('error', errorMsg);
                } else {
                    alert(errorMsg);
                }
                throw new Error(errorMsg);
            }
            
            console.log('Processing file:', file.name, 'Type:', file.type);
            
            // Clear any previous error messages
            const statusMessage = document.getElementById('status-message');
            if (statusMessage) {
                statusMessage.style.display = 'none';
            }
            
            // Update global variables
            pngFile = file;
            
            // Detect file type
            let fileToProcess = file;
            const fileExtension = file.name.toLowerCase().split('.').pop();
            const fileType = file.type.toLowerCase();
            
            // List of formats that browsers can directly display (no conversion needed)
            const browserSupportedFormats = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp', 'image/bmp'];
            const browserSupportedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'];
            const isBrowserSupported = browserSupportedFormats.includes(fileType) || 
                                      browserSupportedExtensions.includes(fileExtension);
            
            // Check for HEIC/HEIF - comprehensive detection
            const isHeic = fileExtension === 'heic' || fileExtension === 'heif' || 
                           fileType === 'image/heic' || fileType === 'image/heif' ||
                           (file.name.toLowerCase().includes('heic') || file.name.toLowerCase().includes('heif'));
            
            // Get format name for error messages
            const formatName = isHeic ? 'HEIC' : (fileExtension.toUpperCase() || 'this format');
            
            // For HEIC files, try loading directly first (some browsers may support it)
            // Only convert if direct load fails
            let needsConversion = false;
            
            if (isHeic) {
                console.log('HEIC file detected - trying direct load first:', { 
                    name: file.name, 
                    type: file.type,
                    extension: fileExtension
                });
                
                // Quick test: try to load HEIC directly
                try {
                    const testUrl = URL.createObjectURL(file);
                    const testImg = new Image();
                    
                    const canLoadDirectly = await Promise.race([
                        new Promise((resolve, reject) => {
                            testImg.onload = () => {
                                URL.revokeObjectURL(testUrl);
                                resolve(true);
                            };
                            testImg.onerror = () => {
                                URL.revokeObjectURL(testUrl);
                                reject(new Error('HEIC direct load failed'));
                            };
                            testImg.src = testUrl;
                        }),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Load timeout')), 3000))
                    ]);
                    
                    if (canLoadDirectly) {
                        console.log('‚úÖ Browser supports HEIC directly - no conversion needed');
                        needsConversion = false;
                    }
                } catch (directLoadError) {
                    console.log('HEIC direct load failed, will convert:', directLoadError.message);
                    needsConversion = true;
                }
            } else if (!isBrowserSupported) {
                // For other non-supported formats, convert
                needsConversion = true;
            }
            
            // Universal image converter - automatically converts any non-standard format to JPEG
            // Works like Canva/CloudConvert - accepts all images and converts as needed
            if (needsConversion) {
                console.log('Non-standard image format detected - attempting automatic conversion:', { 
                    name: file.name, 
                    type: file.type, 
                    extension: fileExtension, 
                    size: file.size,
                    isHeic: isHeic,
                    formatName: formatName
                });
                
                showStatus('loading', `Converting ${formatName} image...`);
                
                let conversionSuccess = false;
                
                // METHOD 1: Try heic2any for HEIC/HEIF files
                if (isHeic) {
                    try {
                        console.log('Attempting HEIC conversion with heic2any...');
                        
                        // Wait for library to be available
                        let attempts = 0;
                        let heic2anyFunc = null;
                        while (attempts < 5 && !heic2anyFunc) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                            if (typeof heic2any !== 'undefined') {
                                heic2anyFunc = heic2any;
                            } else if (typeof window !== 'undefined' && window.heic2any) {
                                heic2anyFunc = window.heic2any;
                            } else if (typeof globalThis !== 'undefined' && globalThis.heic2any) {
                                heic2anyFunc = globalThis.heic2any;
                            }
                            attempts++;
                        }
                        
                        if (heic2anyFunc) {
                            console.log('heic2any library found, converting...');
                            
                            // Ensure file is a Blob
                            let fileBlob = file instanceof Blob ? file : await file.arrayBuffer().then(ab => new Blob([ab], { type: file.type || 'image/heic' }));
                            
                            // Convert HEIC to JPEG
                            const conversionResult = await Promise.race([
                                heic2anyFunc({
                                    blob: fileBlob,
                                    toType: 'image/jpeg',
                                    quality: 0.92,
                                    multiple: false
                                }),
                                new Promise((_, reject) => setTimeout(() => reject(new Error('HEIC conversion timeout')), 30000))
                            ]);
                            
                            // Handle result
                            let convertedBlob = Array.isArray(conversionResult) ? conversionResult[0] : conversionResult;
                            
                            if (convertedBlob && convertedBlob instanceof Blob) {
                                fileToProcess = new File([convertedBlob], file.name.replace(/\.(heic|heif)$/i, '.jpg'), { 
                                    type: 'image/jpeg' 
                                });
                                conversionSuccess = true;
                                console.log('‚úÖ HEIC conversion successful via heic2any');
                            }
                        }
                    } catch (heicError) {
                        console.warn('heic2any conversion failed, trying alternative methods:', heicError);
                    }
                }
                
                // METHOD 2: Canvas-based conversion (works for any format browser can decode)
                if (!conversionSuccess) {
                    try {
                        console.log('Attempting canvas-based conversion...');
                        
                        // Read file and try to load as image
                        const fileUrl = URL.createObjectURL(file);
                        const img = new Image();
                        
                        const imageLoadPromise = new Promise((resolve, reject) => {
                            img.onload = () => resolve();
                            img.onerror = () => reject(new Error('Image failed to load'));
                            img.src = fileUrl;
                            
                            // Timeout after 10 seconds
                            setTimeout(() => reject(new Error('Image load timeout')), 10000);
                        });
                        
                        await imageLoadPromise;
                        
                        // Image loaded successfully - convert to JPEG via canvas
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        // Convert canvas to JPEG blob
                        const blob = await new Promise(resolve => {
                            canvas.toBlob(resolve, 'image/jpeg', 0.92);
                        });
                        
                        if (blob) {
                            fileToProcess = new File([blob], file.name.replace(/\.[^/.]+$/, '.jpg'), { 
                                type: 'image/jpeg' 
                            });
                            conversionSuccess = true;
                            console.log('‚úÖ Image converted successfully via canvas');
                        }
                        
                        // Clean up object URL
                        URL.revokeObjectURL(fileUrl);
                        
                    } catch (canvasError) {
                        console.warn('Canvas conversion failed:', canvasError);
                    }
                }
                
                // METHOD 3: Server-side conversion (fallback if client-side fails)
                if (!conversionSuccess) {
                    try {
                        console.log('Attempting server-side conversion...');
                        showStatus('loading', `Converting ${formatName} image on server...`);
                        
                        // Upload file to server for conversion
                        const formData = new FormData();
                        formData.append('image', file);
                        
                        const serverResponse = await fetch('/api/convert-image', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (serverResponse.ok) {
                            // Get converted image blob from server
                            const convertedBlob = await serverResponse.blob();
                            
                            // Check if it's an image (either by type or size - JPEG should have size > 0)
                            if (convertedBlob && convertedBlob.size > 0) {
                                // Create File from blob with explicit JPEG type
                                fileToProcess = new File([convertedBlob], file.name.replace(/\.[^/.]+$/, '.jpg'), { 
                                    type: 'image/jpeg' 
                                });
                                conversionSuccess = true;
                                console.log('‚úÖ Image converted successfully via server', { 
                                    size: convertedBlob.size, 
                                    type: convertedBlob.type || 'image/jpeg' 
                                });
                            } else {
                                throw new Error('Server returned empty or invalid image data');
                            }
                        } else {
                            // Try to get error message from server
                            let errorMsg = 'Server conversion failed';
                            try {
                                const errorData = await serverResponse.json();
                                errorMsg = errorData.error || errorMsg;
                            } catch (e) {
                                errorMsg = `Server error: ${serverResponse.status} ${serverResponse.statusText}`;
                            }
                            throw new Error(errorMsg);
                        }
                    } catch (serverError) {
                        console.warn('Server-side conversion failed:', serverError);
                        // Don't set conversionSuccess = false here yet, let it fall through to final error
                    }
                }
                
                // If all conversion methods failed
                if (!conversionSuccess) {
                    console.error('All conversion methods failed for file:', file.name);
                    showStatus('error', `Sorry, unable to convert ${formatName} image. Please convert it to JPEG format using an online converter. Contact us if you need assistance.`);
                    return;
                }
                
                // Hide loading message after successful conversion
                if (statusMessage) {
                    statusMessage.style.display = 'none';
                }
            }
            
            // Load image with timeout
            console.log('üìñ Reading file with FileReader...');
            console.log('üìñ File to process:', fileToProcess.name, fileToProcess.size, fileToProcess.type);
            
            try {
                const reader = new FileReader();
                
                reader.onerror = (error) => {
                    const errorMsg = 'Error: Could not read file. The file may be corrupted or inaccessible. Please try selecting a different file.';
                    console.error('‚ùå FileReader error:', error);
                    console.error('‚ùå FileReader error event:', error);
                    console.error('‚ùå FileReader readyState:', reader.readyState);
                    isProcessingFile = false;
                    if (typeof showStatus === 'function') {
                        showStatus('error', errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    throw new Error(errorMsg);
                };
                
                reader.onloadstart = () => {
                    console.log('üìñ FileReader started reading file...');
                };
                
                reader.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const percentLoaded = Math.round((e.loaded / e.total) * 100);
                        console.log(`üìñ FileReader progress: ${percentLoaded}%`);
                    }
                };
                
                reader.onload = async (event) => {
                    console.log('‚úÖ FileReader loaded successfully');
                    console.log('‚úÖ FileReader result length:', event.target.result?.length);
                    console.log('‚úÖ FileReader result type:', typeof event.target.result);
                    
                    try {
                        console.log('üñºÔ∏è Creating Image object...');
                        const img = new Image();
                        
                        // Set up timeout for image loading
                        let imageLoadTimeout;
                        const imageLoadPromise = new Promise((resolve, reject) => {
                            img.onload = () => {
                                console.log('‚úÖ Image loaded successfully');
                                clearTimeout(imageLoadTimeout);
                                resolve();
                            };
                            img.onerror = (error) => {
                                const errorMsg = 'Error: Image failed to load. The file may be corrupted or in an unsupported format.';
                                console.error('‚ùå Image load error in promise:', error);
                                console.error('‚ùå Image src attempted:', img.src?.substring(0, 50));
                                clearTimeout(imageLoadTimeout);
                                reject(new Error(errorMsg));
                            };
                            imageLoadTimeout = setTimeout(() => {
                                console.error('‚ùå Image load timeout after 15 seconds');
                                reject(new Error('Image load timeout'));
                            }, 15000);
                            console.log('üñºÔ∏è Setting image src from FileReader result...');
                            img.src = event.target.result;
                            console.log('üñºÔ∏è Image src set, waiting for load...');
                        });
                        
                        try {
                            await imageLoadPromise;
                            console.log('‚úÖ Image load promise resolved');
                            
                            // Image loaded successfully - continue processing
                            // WRAP IN TRY-CATCH TO FORCE UI UPDATES EVEN IF PROCESSING FAILS
                            (async () => {
                    console.log('‚úÖ Image loaded, setting up editor...');
                    
                    try {
                        // Store image FIRST - this is critical
                        rawUploadedImage = img;
                        fullOriginalImage = img;
                        cropCoordinates = null;
                        
                        // Save image state immediately for persistence across views
                        try {
                            saveImageState(img, file);
                        } catch (saveError) {
                            console.warn('‚ö†Ô∏è Failed to save image state:', saveError);
                            // Continue even if save fails
                        }
                    
                    // Reset cropper state completely
                    fullProcessedImageDataURL = null;
                    cropperVisible = false;
                    cropperManuallyHidden = false;
                    cropInitialized = false;
                    cropperZoom = 1.0;
                    cropperPanX = 0;
                    cropperPanY = 0;
                    isDraggingCrop = false;
                    isResizingCrop = false;
                    isPanningCropper = false;
                    resizeEdge = '';
                    cropX = 0;
                    cropY = 0;
                    cropSize = 0;
                    
                    // RESET ALL SLIDERS TO DEFAULTS
                    editorSettings.denoise = 0;
                    editorSettings.brightness = 1.0;
                    editorSettings.contrast = 1.2;
                    editorSettings.tones = 4;
                    
                    // Update slider UI values
                    const denoiseSlider = document.getElementById('denoise-slider');
                    const brightnessSlider = document.getElementById('brightness-slider');
                    const contrastSlider = document.getElementById('contrast-slider');
                    const tonesSlider = document.getElementById('tones-slider');
                    
                    if (denoiseSlider) {
                        denoiseSlider.value = '0';
                        document.getElementById('denoise-value').textContent = '0.0';
                    }
                    if (brightnessSlider) {
                        brightnessSlider.value = '1.0';
                        document.getElementById('brightness-value').textContent = '1.0';
                    }
                    if (contrastSlider) {
                        contrastSlider.value = '1.2';
                        document.getElementById('contrast-value').textContent = '1.2';
                    }
                    if (tonesSlider) {
                        tonesSlider.value = '4';
                        document.getElementById('tones-value').textContent = '4';
                    }
                    
                    // Update UI elements
                    document.getElementById('png-upload-area').classList.add('has-file');
                    document.getElementById('png-upload-text').textContent = file.name;
                    document.getElementById('png-preview').style.display = 'none';
                    document.getElementById('crop-canvas').style.display = 'none';
                    document.getElementById('show-cropper-btn').style.display = 'block';
                    document.getElementById('hide-cropper-btn').style.display = 'none';
                    document.getElementById('crop-buttons').style.display = 'block';
                    
                    // HIDE initial upload box immediately
                    const initialUploadBox = document.getElementById('initial-upload-box');
                    if (initialUploadBox) {
                        initialUploadBox.style.display = 'none';
                        console.log('‚úÖ Initial upload box hidden');
                    }
                    
                    // SHOW action buttons
                    const actionButtonsContainer = document.getElementById('action-buttons-container');
                    if (actionButtonsContainer) {
                        actionButtonsContainer.style.display = 'flex';
                        console.log('‚úÖ Action buttons shown');
                    }
                    
                    // FORCE UI UPDATES FIRST - DO THIS REGARDLESS OF ERRORS
                    console.log('üîÑ Forcing UI updates...');
                    
                    // SHOW editor panel IMMEDIATELY - CRITICAL
                    const editorPanel = document.getElementById('editor-panel');
                    if (editorPanel) {
                        editorPanel.style.display = 'block';
                        editorPanel.style.visibility = 'visible';
                        editorPanel.style.opacity = '1';
                        console.log('‚úÖ Editor panel displayed');
                    } else {
                        const errorMsg = 'Error: Could not display editor panel. UI element not found.';
                        console.error('‚ùå', errorMsg);
                        if (typeof showStatus === 'function') {
                            showStatus('error', errorMsg);
                        } else {
                            alert(errorMsg);
                        }
                        throw new Error(errorMsg);
                    }
                    
                    // HIDE canvas container
                    const canvasContainer = document.getElementById('canvas-container');
                    if (canvasContainer) {
                        canvasContainer.style.display = 'none';
                    }
                        
                    // SHOW price section
                    const priceSection = document.getElementById('price-display-section');
                    if (priceSection) {
                        priceSection.style.display = 'block';
                        try {
                            updatePriceDisplay();
                        } catch (priceError) {
                            console.warn('‚ö†Ô∏è Price display update failed:', priceError);
                        }
                        console.log('‚úÖ Price section shown');
                    }
                    
                    // SHOW upload panel
                    const uploadPanel = document.getElementById('upload-panel');
                    if (uploadPanel) {
                        uploadPanel.style.display = 'block';
                    }
                    
                    // Force repaint
                    if (editorPanel) {
                        editorPanel.offsetHeight; // Trigger reflow
                    }
                    
                    console.log('‚úÖ UI updates complete, proceeding with processing...');
                    
                    // Load STL (non-blocking)
                    loadSTLFromServer(selectedGridSize).catch(error => {
                        console.warn('‚ö†Ô∏è STL load error (non-critical):', error);
                    });
                    
                    // PROCESS IMAGE (wrap in try-catch so errors don't block UI)
                    try {
                        processImage();
                        console.log('‚úÖ Image processing started');
                    } catch (processError) {
                        const errorMsg = `Error: Image processing failed - ${processError.message || 'Unknown error'}. The image was uploaded but may not display correctly.`;
                        console.error('‚ùå Image processing error:', processError);
                        console.error('‚ùå Error stack:', processError.stack);
                        // Show error but keep UI updated
                        if (typeof showStatus === 'function') {
                            showStatus('error', errorMsg);
                        } else {
                            alert(errorMsg);
                        }
                        // Don't throw - allow UI to remain visible so user can try to fix
                    }
                    
                    // Automatically show size panel and cropper (with delays)
                    setTimeout(() => {
                        try {
                            togglePanel('size');
                            console.log('‚úÖ Size panel toggled');
                            
                            // Auto-show cropper
                            setTimeout(() => {
                                try {
                                    if (rawUploadedImage) {
                                        if (!cropperManuallyHidden) {
                                            showCropper();
                                            console.log('‚úÖ Cropper shown');
                                        } else {
                                            const showBtn = document.getElementById('show-cropper-btn');
                                            const hideBtn = document.getElementById('hide-cropper-btn');
                                            if (showBtn) showBtn.style.display = 'block';
                                            if (hideBtn) hideBtn.style.display = 'none';
                                        }
                                    }
                                } catch (cropperError) {
                                    console.warn('‚ö†Ô∏è Cropper show error:', cropperError);
                                }
                            }, 150);
                        } catch (panelError) {
                            console.warn('‚ö†Ô∏è Panel toggle error:', panelError);
                        }
                    }, 200);
                    
                    console.log('‚úÖ Editor panel shown inline with size panel auto-opened');
                    isProcessingFile = false; // Reset flag
                        
                    } catch (error) {
                        // CRITICAL: Even if everything fails, force UI to update
                        console.error('‚ùå Error in post-upload flow:', error);
                        console.error('‚ùå Error stack:', error.stack);
                        
                        // FORCE UI UPDATES REGARDLESS OF ERROR
                        const initialUploadBox = document.getElementById('initial-upload-box');
                        if (initialUploadBox) {
                            initialUploadBox.style.display = 'none';
                        }
                        
                        const editorPanel = document.getElementById('editor-panel');
                        if (editorPanel) {
                            editorPanel.style.display = 'block';
                            editorPanel.style.visibility = 'visible';
                        }
                        
                        const actionButtonsContainer = document.getElementById('action-buttons-container');
                        if (actionButtonsContainer) {
                            actionButtonsContainer.style.display = 'flex';
                        }
                        
                        const priceSection = document.getElementById('price-display-section');
                        if (priceSection) {
                            priceSection.style.display = 'block';
                        }
                        
                        // Show error message
                        if (typeof showStatus === 'function') {
                            showStatus('error', `Image uploaded but encountered an error: ${error.message}. You can try editing the image.`);
                        } else {
                            alert(`Image uploaded but encountered an error: ${error.message}`);
                        }
                        
                        isProcessingFile = false; // Reset flag
                    }
                    
                    // Save to IndexedDB
                    try {
                        await saveFileToDB(dbKey('png'), fileToProcess);
                    } catch (error) {
                        console.error('Save to DB error:', error);
                    }
                })(); // End of async image processing function
            } catch (error) {
                console.error('‚ùå Image load error:', error);
                console.error('‚ùå Error stack:', error.stack);
                isProcessingFile = false;
                const formatName = file.name.split('.').pop().toUpperCase() || 'image';
                const errorMsg = error.message || `Error: Unable to display ${formatName} image. The file may be corrupted or in an unsupported format. Please try converting it to JPEG format using an online converter.`;
                if (typeof showStatus === 'function') {
                    showStatus('error', errorMsg);
                } else {
                    alert(errorMsg);
                }
                throw error; // Re-throw so caller knows it failed
            }
        } catch (outerError) {
            // Catch errors from the outer try block (image creation/loading outside inner try)
            console.error('‚ùå Error in image creation:', outerError);
            console.error('‚ùå Error stack:', outerError.stack);
            isProcessingFile = false;
            const errorMsg = outerError.message || 'Error: Failed to create or load image.';
            if (typeof showStatus === 'function') {
                showStatus('error', errorMsg);
            } else {
                alert(errorMsg);
            }
            // Don't re-throw - let the function complete
        }
        };
        
        try {
            reader.readAsDataURL(fileToProcess);
        } catch (error) {
            console.error('‚ùå File read error:', error);
            console.error('‚ùå Error stack:', error.stack);
            const formatName = file.name.split('.').pop().toUpperCase() || 'image';
            const errorMsg = error.message || `Error: Unable to read ${formatName} file. The file may be corrupted or in an unsupported format. Please try converting it to JPEG format using an online converter.`;
            if (typeof showStatus === 'function') {
                showStatus('error', errorMsg);
            } else {
                alert(errorMsg);
            }
            isProcessingFile = false;
            throw error; // Re-throw so caller knows it failed
        }
    } catch (error) {
        const errorMsg = `Error: Failed to set up file reader - ${error.message || 'Unknown error'}`;
        console.error('‚ùå', errorMsg);
        console.error('‚ùå Error stack:', error.stack);
        isProcessingFile = false;
        if (typeof showStatus === 'function') {
            showStatus('error', errorMsg);
        } else {
            alert(errorMsg);
        }
        throw error; // Re-throw so caller knows it failed
    }
        };

        // Main input handler is now set up in setupUploadHandlers() above
        // This ensures it's attached at the right time with proper error handling


        // Add to Cart button - Creates order and adds to Shopify cart
        document.getElementById('add-to-cart-btn').addEventListener('click', async () => {
            if (!stlFile || !pngFile) {
                alert('Please upload both STL and PNG files first');
                return;
            }

            console.log('Adding to cart...');
            const btn = document.getElementById('add-to-cart-btn');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Processing...';

            try {
                // Show Buy Now button if hidden
                const buyNowBtn = document.getElementById('buy-now-btn');
                if (buyNowBtn && buyNowBtn.style.display === 'none') {
                    buyNowBtn.style.display = 'block';
                }

                // Use the EXACT same PNG that's displayed in the 3D view
                // This ensures perfect alignment between 3D view and exported file
                // CRITICAL: If user has painted/edited the image, use processedImageData (the painted version)
                let processedPngFile = pngFile;
                
                // Check if there's painted image data - this is what's shown in the 3D viewer
                if (processedImageData && processedImageData.width > 0 && processedImageData.height > 0) {
                    // Use the painted/edited image data - this is EXACTLY what's in the 3D viewer
                    console.log('üé® Using painted image data for export (exact match to 3D viewer)');
                    await new Promise((resolve) => {
                        const paintedCanvas = document.createElement('canvas');
                        paintedCanvas.width = processedImageData.width;
                        paintedCanvas.height = processedImageData.height;
                        const paintedCtx = paintedCanvas.getContext('2d');
                        paintedCtx.putImageData(processedImageData, 0, 0);
                        
                        // Convert to blob and file
                        paintedCanvas.toBlob((blob) => {
                            processedPngFile = new File([blob], 'painted.png', { type: 'image/png' });
                            // Also update pngFile and pngImage to keep them in sync
                            pngFile = processedPngFile;
                            const img = new Image();
                            img.onload = () => {
                                pngImage = img;
                                resolve();
                            };
                            img.src = URL.createObjectURL(blob);
                        }, 'image/png');
                    });
                } else if (!processedPngFile && rawUploadedImage) {
                    // If pngFile doesn't exist yet (user hasn't viewed in 3D), generate it now
                    console.log('üì∏ Generating processed image for export');
                    await new Promise((resolve) => {
                        createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                            processedPngFile = file;
                            pngFile = file;
                            pngImage = img;
                            resolve();
                        });
                    });
                } else {
                    // Use existing pngFile (already processed, no painting done)
                    console.log('‚úÖ Using existing processed PNG file for export');
                }
                
                // Calculate total price
                let totalPrice = 0;
                if (prices && prices[`${selectedGridSize}x${selectedGridSize}`]) {
                    totalPrice += prices[`${selectedGridSize}x${selectedGridSize}`];
                }
                if (standSelected && prices && prices.stand) {
                    totalPrice += prices.stand;
                }
                if (selectedAddons.mounting && prices && prices.wall_mounting_dots) {
                    totalPrice += prices.wall_mounting_dots;
                }

                btn.textContent = 'Creating order...';
                
                // Create order (this still sends to admin temporarily)
                const formData = new FormData();
                formData.append('stl', stlFile);
                formData.append('png', processedPngFile);
                formData.append('grid_size', String(selectedGridSize));
                formData.append('stand_selected', String(standSelected));
                formData.append('mounting_selected', String(selectedAddons.mounting));
                formData.append('total_price', String(totalPrice));

                const response = await fetch(getApiUrl('/upload-for-checkout'), {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({ error: 'Failed to create order' }));
                    throw new Error(error.error || 'Failed to create order');
                }

                const result = await response.json();
                const orderId = result.order_id;
                
                console.log('Order created:', orderId);
                
                // Check if we're in Shopify context and have cart service
                const urlParams = new URLSearchParams(window.location.search);
                const isShopifyContext = urlParams.get('shopify') === 'true' || 
                                        window.Shopify || 
                                        window.parent.Shopify ||
                                        window.location.hostname.includes('myshopify.com');
                
                if (isShopifyContext && shopifyCart) {
                    btn.textContent = 'Adding to cart...';
                    
                    try {
                        // Get variant ID for selected grid size
                        const variantId = shopifyVariants[selectedGridSize];
                        
                        if (!variantId) {
                            throw new Error(`Variant ID not found for grid size ${selectedGridSize}. Please configure Shopify variants.`);
                        }
                        
                        // Prepare order data for cart
                        const orderData = {
                            orderId: orderId,
                            variantId: variantId,
                            gridSize: selectedGridSize,
                            standSelected: standSelected,
                            standVariantId: shopifyVariants.stand,
                            mountingSelected: selectedAddons.mounting,
                            mountingVariantId: shopifyVariants.mounting
                        };
                        
                        // Add order to cart
                        await shopifyCart.addOrderToCart(orderData);
                        
                        console.log('‚úÖ Added to cart successfully');
                        
                        // Redirect to cart
                        // Redirect to checkout (Buy Now goes directly to checkout)
                        window.location.href = `${shopifyCart.cartUrl.replace('/cart', '/checkout')}`;
                        
                    } catch (cartError) {
                        console.error('Error adding to Shopify cart:', cartError);
                        showStatus('error', `‚ö†Ô∏è Added to cart failed: ${cartError.message}`);
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }
                } else {
                    // Not in Shopify context, show success message
                    showStatus('success', `‚úÖ Order created! Order ID: ${orderId.substring(0, 8)}`);
                    btn.textContent = originalText;
                    btn.disabled = false;
                }

            } catch (error) {
                console.error('Add to cart error:', error);
                showStatus('error', `‚ùå Error: ${error.message}`);
                btn.textContent = originalText;
                btn.disabled = false;
            }
        });

        // Buy Now - Generate file and redirect to Shopify
        document.getElementById('buy-now-btn').addEventListener('click', async () => {
            if (!stlFile || !pngFile) return;

            console.log('Proceeding to checkout...');
            showStatus('loading', '<span class="spinner"></span>Preparing your order...');
            document.getElementById('buy-now-btn').disabled = true;

            try {
                // Use the EXACT same PNG that's displayed in the 3D view
                // This ensures perfect alignment between 3D view and exported file
                // CRITICAL: If user has painted/edited the image, use processedImageData (the painted version)
                let processedPngFile = pngFile;
                
                // Check if there's painted image data - this is what's shown in the 3D viewer
                if (processedImageData && processedImageData.width > 0 && processedImageData.height > 0) {
                    // Use the painted/edited image data - this is EXACTLY what's in the 3D viewer
                    console.log('üé® Using painted image data for Buy Now export (exact match to 3D viewer)');
                    await new Promise((resolve) => {
                        const paintedCanvas = document.createElement('canvas');
                        paintedCanvas.width = processedImageData.width;
                        paintedCanvas.height = processedImageData.height;
                        const paintedCtx = paintedCanvas.getContext('2d');
                        paintedCtx.putImageData(processedImageData, 0, 0);
                        
                        // Convert to blob and file
                        paintedCanvas.toBlob((blob) => {
                            processedPngFile = new File([blob], 'painted.png', { type: 'image/png' });
                            // Also update pngFile and pngImage to keep them in sync
                            pngFile = processedPngFile;
                            const img = new Image();
                            img.onload = () => {
                                pngImage = img;
                                resolve();
                            };
                            img.src = URL.createObjectURL(blob);
                        }, 'image/png');
                    });
                } else if (!processedPngFile && rawUploadedImage) {
                    // If pngFile doesn't exist yet (user hasn't viewed in 3D), generate it now
                    console.log('üì∏ Generating processed image for Buy Now export');
                    await new Promise((resolve) => {
                        createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                            processedPngFile = file;
                            pngFile = file;
                            pngImage = img;
                            resolve();
                        });
                    });
                } else {
                    // Use existing pngFile (already processed, no painting done)
                    console.log('‚úÖ Using existing processed PNG file for Buy Now export');
                }
                
                // Generate and upload file for checkout
                const formData = new FormData();
                formData.append('stl', stlFile);
                formData.append('png', processedPngFile);
                formData.append('grid_size', String(selectedGridSize));
                formData.append('stand_selected', String(standSelected));
                formData.append('mounting_selected', String(selectedAddons.mounting));
                
                // Calculate total price
                let totalPrice = 0;
                if (prices && prices[`${selectedGridSize}x${selectedGridSize}`]) {
                    totalPrice += prices[`${selectedGridSize}x${selectedGridSize}`];
                }
                if (standSelected && prices && prices.stand) {
                    totalPrice += prices.stand;
                }
                if (selectedAddons.mounting && prices && prices.wall_mounting_dots) {
                    totalPrice += prices.wall_mounting_dots;
                }
                formData.append('total_price', String(totalPrice));

                const response = await fetch(getApiUrl('/upload-for-checkout'), {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({ error: 'Failed to prepare order' }));
                    throw new Error(error.error || 'Failed to prepare order');
                }

                const result = await response.json();
                const orderId = result.order_id;
                
                console.log('Order ID:', orderId);
                
                // Check if we're in Shopify context and have cart service
                const isShopifyContext = urlParams.get('shopify') === 'true';
                
                if (isShopifyContext && shopifyCart) {
                    // Add to Shopify cart using Cart API
                    try {
                        // Get variant ID for selected grid size
                        const variantId = shopifyVariants[selectedGridSize];
                        
                        if (!variantId) {
                            throw new Error(`Variant ID not found for grid size ${selectedGridSize}. Please configure Shopify variants.`);
                        }
                        
                        // Prepare order data for cart
                        const orderData = {
                            orderId: orderId,
                            variantId: variantId,
                            gridSize: selectedGridSize,
                            standSelected: standSelected,
                            standVariantId: shopifyVariants.stand,
                            mountingSelected: selectedAddons.mounting,
                            mountingVariantId: shopifyVariants.mounting
                        };
                        
                        // Add order to cart
                        await shopifyCart.addOrderToCart(orderData);
                        
                        // Redirect to checkout (Buy Now goes directly to checkout)
                        window.location.href = `${shopifyCart.cartUrl.replace('/cart', '/checkout')}`;
                        
                    } catch (cartError) {
                        console.error('Error adding to Shopify cart:', cartError);
                        // Fallback: redirect to product page with order ID
                        showStatus('error', `‚ö†Ô∏è Added to cart failed: ${cartError.message}. Redirecting to product page...`);
                        setTimeout(() => {
                            const shopifyUrl = `${SHOPIFY_PRODUCT_URL}?order_id=${orderId}`;
                            window.location.href = shopifyUrl;
                        }, 2000);
                    }
                } else {
                    // Not in Shopify context, use fallback redirect
                    const shopifyUrl = `${SHOPIFY_PRODUCT_URL}?order_id=${orderId}`;
                    window.location.href = shopifyUrl;
                }

            } catch (error) {
                console.error('Checkout error:', error);
                showStatus('error', `‚ùå Error: ${error.message}`);
                document.getElementById('buy-now-btn').disabled = false;
            }
        });

        function showStatus(type, message) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.className = `status-message ${type}`;
            statusMessage.innerHTML = message;
            statusMessage.style.display = 'block';

            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 5000);
            }
        }

        // Initialize Three.js when page loads
        window.addEventListener('load', initThree);
        
        // Ensure page starts at top on initial load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                window.scrollTo(0, 0);
                document.documentElement.scrollTop = 0;
                document.body.scrollTop = 0;
            });
        } else {
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
        }

        // Restore state and files on load; start with editor visible
        window.addEventListener('load', async () => {
            // Ensure page starts at the top
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            
            // Don't restore image state on page load - always start fresh
            // This ensures users always see the upload screen when they first visit
            // console.log('üìÇ Checking for saved image state on page load...');
            // const hasRestoredImage = restoreImageState();
            // if (hasRestoredImage) {
            //     console.log('‚úÖ Image state restored from previous session');
            //     // Don't proceed with normal restore if we restored an image
            //     return;
            // }
            document.body.scrollTop = 0;
            
            loadSimpleState();

            // Reflect selected grid size buttons
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.size) === selectedGridSize) {
                    btn.classList.add('active');
                }
            });
            document.getElementById('png-upload-subtext').textContent = `Will be resized to ${selectedGridSize}√ó${selectedGridSize} pixels`;

            // Load cached data immediately for instant display
            loadCachedPrices();
            loadCachedProductImages();

            // Load prices from API (will update cache)
            await loadPrices();
            
            // Reload images again after prices load to ensure they're displayed
            setTimeout(() => {
                loadImages().then(() => {
                    updateProductImages();
                });
            }, 200);
            
            // Automatically select 75√ó75 and update price
            // But don't restore images - just set the grid size
            selectedGridSize = 75;
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.size) === 75) {
                    btn.classList.add('active');
                }
            });
            const pngSubtext = document.getElementById('png-upload-subtext');
            if (pngSubtext) {
                pngSubtext.textContent = `Will be resized to 75√ó75 pixels`;
            }
            updatePriceDisplay();
            // Load STL for selected grid size (but don't restore images)
            await loadSTLFromServer(75);
            
            // Force multiple price updates to ensure it displays
            setTimeout(() => updatePriceDisplay(), 50);
            setTimeout(() => updatePriceDisplay(), 200);
            setTimeout(() => updatePriceDisplay(), 500);

            // Don't restore files on page load - always start fresh with initial upload screen
            // This ensures users always see the upload screen when they first visit
            // await restoreForSize(selectedGridSize);
            
            // Explicitly ensure rawUploadedImage is null on page load
            rawUploadedImage = null;
            pngFile = null;
            
            // Clear any saved image state from localStorage to prevent restoration
            // This ensures we always start fresh
            try {
                localStorage.removeItem('uploadedImageState');
                console.log('‚úÖ Cleared saved image state from localStorage');
            } catch (e) {
                console.warn('‚ö†Ô∏è Could not clear localStorage:', e);
            }
            
            // Always show initial upload screen on page load (don't restore previous image)
            // Only show editor and controls if image was already uploaded (should be null on fresh load)
            if (rawUploadedImage) {
                // Hide initial upload box and show all controls
                const initialUploadBox = document.getElementById('initial-upload-box');
                if (initialUploadBox) {
                    initialUploadBox.style.display = 'none';
                }
                
                // Show action buttons
                const actionButtonsContainer = document.getElementById('action-buttons-container');
                if (actionButtonsContainer) {
                    actionButtonsContainer.style.display = 'flex';
                }
                
                // Show price section
                const priceSection = document.getElementById('price-display-section');
                if (priceSection) {
                    priceSection.style.display = 'block';
                }
                
                showEditorPanel();
            } else {
                // Ensure initial upload box is visible
                const initialUploadBox = document.getElementById('initial-upload-box');
                if (initialUploadBox) {
                    initialUploadBox.style.display = 'block';
                }
                
                // Ensure action buttons are hidden
                const actionButtonsContainer = document.getElementById('action-buttons-container');
                if (actionButtonsContainer) {
                    actionButtonsContainer.style.display = 'none';
                }
                
                // Ensure price section is hidden
                const priceSection = document.getElementById('price-display-section');
                if (priceSection) {
                    priceSection.style.display = 'none';
                }
            }
            
            // Load STL for selected grid size
            await loadSTLFromServer(selectedGridSize);
            
            // Only show panels if image is uploaded
            if (rawUploadedImage) {
                // Hide all panels by default
                document.getElementById('adjust-panel').classList.remove('active');
                document.getElementById('size-panel').classList.remove('active');
                document.getElementById('paint-panel').classList.remove('active');
                document.getElementById('adjust-btn').classList.remove('active');
                document.getElementById('size-btn').classList.remove('active');
                document.getElementById('paint-btn').classList.remove('active');
                
                // Open size panel by default
                document.getElementById('size-panel').classList.add('active');
                document.getElementById('size-btn').classList.add('active');
                
                // Show cropper if image is uploaded (always show when size panel is open)
                setTimeout(() => {
                    // Make sure upload panel is visible for cropper
                    const uploadPanel = document.getElementById('upload-panel');
                    if (uploadPanel) {
                        uploadPanel.style.display = 'block';
                        // Hide upload area and label, keep only cropper visible
                        const uploadArea = document.getElementById('png-upload-area');
                        const sectionLabel = uploadPanel.querySelector('.section-label');
                        if (uploadArea) uploadArea.style.display = 'none';
                        if (sectionLabel) sectionLabel.style.display = 'none';
                        // Show crop buttons
                        const cropButtons = document.getElementById('crop-buttons');
                        if (cropButtons) {
                            cropButtons.style.display = 'block';
                        }
                        
                        // Show cropper
                        // Only show cropper if user hasn't manually hidden it
                        if (!cropperManuallyHidden) {
                            showCropper();
                        } else {
                            // Cropper was manually hidden, show the show button instead
                            document.getElementById('show-cropper-btn').style.display = 'block';
                            document.getElementById('hide-cropper-btn').style.display = 'none';
                        }
                    }
                }, 200);
            }
            
            // Setup paint handlers after everything is loaded
            setTimeout(() => {
                setupPaintHandlers();
            }, 500);
        });
    </script>
    <script>
        function toggleSizeGuide() {
            const dropdown = document.getElementById('size-guide-dropdown');
            const chevron = document.getElementById('mobile-size-guide-chevron');
            const btnText = document.getElementById('mobile-size-guide-btn-text');
            
            if (dropdown.style.display === 'none' || !dropdown.style.display) {
                dropdown.style.display = 'block';
                if (chevron) chevron.textContent = '‚ñ≤';
                // Text is already orange from initial styling
            } else {
                dropdown.style.display = 'none';
                if (chevron) chevron.textContent = '‚ñº';
            }
        }

        // Load size guide content from JSON
        async function loadSizeGuide() {
            // Access BACKEND_URL from window (defined in another script block)
            const BACKEND_URL = window.BACKEND_URL || null;
            
            // If no backend URL (file:// protocol), skip API call
            if (!BACKEND_URL) {
                console.log('‚ö†Ô∏è No backend URL - skipping size guide load for file:// protocol');
                return;
            }
            
            try {
                // Access getApiUrl from window or define locally
                const getApiUrl = window.getApiUrl || function(path) {
                    if (!BACKEND_URL) return null;
                    const baseUrl = BACKEND_URL.replace(/\/$/, '');
                    const cleanPath = path.startsWith('/') ? path : '/' + path;
                    return baseUrl + cleanPath;
                };
                
                const url = getApiUrl('/api/content?t=' + Date.now());
                if (!url) {
                    return; // No backend, skip
                }
                // Use the API endpoint with cache busting to ensure we get the latest content
                const response = await fetch(url);
                const content = await response.json();
                
                if (content.size_guide) {
                    const contentDiv = document.getElementById('mobile-size-guide-content');
                    if (contentDiv) {
                        // Format the size guide content
                        let html = '';
                        if (content.size_guide.square && content.size_guide.square.length > 0) {
                            html += '<h3>Square Sizes</h3><ul>';
                            content.size_guide.square.forEach(size => {
                                html += `<li><strong>${size.bricks}</strong> = ${size.cm}</li>`;
                            });
                            html += '</ul>';
                        }
                        // Portrait and landscape will be added later
                        // if (content.size_guide.portrait && content.size_guide.portrait.length > 0) {
                        //     html += '<h3>Portrait Sizes</h3><ul>';
                        //     content.size_guide.portrait.forEach(size => {
                        //         html += `<li><strong>${size.bricks}</strong> = ${size.cm}</li>`;
                        //     });
                        //     html += '</ul>';
                        // }
                        // if (content.size_guide.landscape && content.size_guide.landscape.length > 0) {
                        //     html += '<h3>Landscape Sizes</h3><ul>';
                        //     content.size_guide.landscape.forEach(size => {
                        //         html += `<li><strong>${size.bricks}</strong> = ${size.cm}</li>`;
                        //     });
                        //     html += '</ul>';
                        // }
                        if (content.size_guide.note) {
                            html += `<p style="font-size: 12px; color: #666; margin-top: 15px;"><em>${content.size_guide.note}</em></p>`;
                        }
                        contentDiv.innerHTML = html;
                    }
                    
                    if (content.size_guide_title && document.getElementById('mobile-size-guide-title')) {
                        document.getElementById('mobile-size-guide-title').textContent = content.size_guide_title;
                    }
                    if (content.size_guide_button_text && document.getElementById('mobile-size-guide-btn-text')) {
                        document.getElementById('mobile-size-guide-btn-text').textContent = content.size_guide_button_text;
                    }
                }
            } catch (error) {
                console.error('Error loading size guide:', error);
            }
        }

        // Load size guide when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadSizeGuide);
            
            // Add scroll listener for viewer controls positioning
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    updateViewerControlsPosition();
                }, 10);
            }, { passive: true });
            
            // Also update on resize
            window.addEventListener('resize', () => {
                updateViewerControlsPosition();
            }, { passive: true });
        } else {
            loadSizeGuide();
        }
    </script>
</body>
</html>
