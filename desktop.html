<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Album Cover Mosaic Builder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <script src="/assets/js/shopifyCart.js" onerror="console.warn('Shopify Cart script failed to load - continuing without it')"></script>
    <script>
        // ULTRA-AGGRESSIVE BUTTON REMOVAL - RUNS IMMEDIATELY BEFORE ANYTHING ELSE
        (function() {
            'use strict';
            function killButtons() {
                // Remove all editor-actions containers
                document.querySelectorAll('.editor-actions').forEach(el => {
                    el.remove();
                    if (el.parentNode) el.parentNode.removeChild(el);
                });
                
                // Find and remove Cancel and Apply buttons
                document.querySelectorAll('button').forEach(btn => {
                    const text = btn.textContent.trim();
                    const onclick = btn.getAttribute('onclick') || '';
                    const parent = btn.parentElement;
                    
                    // Kill Cancel button
                    if (text === 'Cancel' && onclick.includes('show3DView') && !btn.classList.contains('viewer-btn')) {
                        btn.remove();
                        if (btn.parentNode) btn.parentNode.removeChild(btn);
                    }
                    
                    // Kill Apply button
                    if ((text.includes('Apply') && text.includes('Use This Image')) || 
                        (onclick.includes('applyPhotoEdits') && !btn.classList.contains('viewer-btn'))) {
                        btn.remove();
                        if (btn.parentNode) btn.parentNode.removeChild(btn);
                    }
                    
                    // Kill parent if it's editor-actions
                    if (parent && parent.classList && parent.classList.contains('editor-actions')) {
                        parent.remove();
                        if (parent.parentNode) parent.parentNode.removeChild(parent);
                    }
                });
            }
            
            // Run immediately
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', killButtons);
            } else {
                killButtons();
            }
            
            // Run continuously
            setInterval(killButtons, 10);
            
            // Override any function that might create these buttons
            const originalCreateElement = document.createElement;
            document.createElement = function(tagName) {
                const el = originalCreateElement.call(this, tagName);
                if (tagName === 'button' || tagName === 'div') {
                    setTimeout(killButtons, 0);
                }
                return el;
            };
            
            // Watch for any DOM changes
            const observer = new MutationObserver(killButtons);
            if (document.body) {
                observer.observe(document.body, { childList: true, subtree: true });
            } else {
                document.addEventListener('DOMContentLoaded', () => {
                    observer.observe(document.body, { childList: true, subtree: true });
                });
            }
        })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            background: #FFFFFF;
            min-height: 100vh;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        html {
            overflow-x: hidden;
        }

        .main-container {
            display: flex;
            height: 100vh;
            max-width: 100vw;
            overflow-x: hidden;
            margin: 0 auto;
        }

        /* Left Panel - 3D Viewer */
        .viewer-panel {
            flex: 1;
            min-width: 0;
            background: #FFFFFF;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: visible;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #FFFFFF;
            border-right: 1px solid #e0e0e0;
            min-height: 600px; /* ensure visible height when shown */
        }

        #canvas-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* Inline editor panel that replaces the 3D view initially */
        #editor-panel {
            flex: 1;
            padding: 20px 24px 20px 24px;
            padding-right: 40px;
            overflow: visible;
            background: #FFFFFF;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .viewer-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .viewer-controls.stopped {
            display: none;
        }

        .viewer-btn {
            background: #E0E0E0;
            border: 1px solid #333333;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: none;
            font-size: 14px;
            transition: all 0.2s;
            font-weight: normal;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .viewer-btn:hover {
            background: #d0d0d0;
        }

        .viewer-btn.icon-only {
            padding: 10px;
            font-size: 18px;
        }

        .placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #333333;
            font-size: 16px;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .placeholder-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        /* Right Panel - Controls */
        .control-panel {
            flex: 0 0 450px;
            min-width: 450px;
            background: #FFFFFF;
            padding: 40px;
            overflow: visible;
            border-left: 1px solid #e0e0e0;
        }
        
        .control-panel .section {
            overflow: visible !important;
            width: 100%;
        }
        
        .control-panel .section-label {
            white-space: nowrap !important;
            overflow: visible !important;
            text-overflow: clip !important;
            width: auto !important;
            max-width: none !important;
            min-width: fit-content !important;
            display: inline-block !important;
        }
        
        /* Lock scrolling in Shopify embedded context - prevent free scrolling */
        body.shopify-embedded, html.shopify-embedded {
            overflow: hidden !important;
            height: 100vh !important;
            position: fixed !important;
            width: 100% !important;
        }
        
        .main-container.shopify-embedded {
            height: 100vh !important;
            overflow: hidden !important;
            position: relative !important;
        }
        
        /* Prevent scrolling on viewer and control panels in Shopify */
        .viewer-panel.shopify-embedded,
        .control-panel.shopify-embedded {
            overflow: hidden !important;
            height: 100vh !important;
        }
        
        #editor-panel.shopify-embedded {
            overflow-y: auto !important; /* Allow scrolling within editor panel only */
        }

        .title {
            font-size: 32px;
            font-weight: normal;
            margin-bottom: 10px;
            color: #E87D3E;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .price {
            font-size: 20px;
            color: #333333;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-label {
            white-space: nowrap !important;
            overflow: visible !important;
            text-overflow: clip !important;
            width: auto !important;
            max-width: none !important;
            min-width: fit-content !important;
            display: inline-block !important;
            font-size: 16px;
            font-weight: normal;
            color: #FF6B35;
            margin-bottom: 12px;
            text-transform: none;
            letter-spacing: 0;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }
        
        .section {
            overflow: visible !important;
            width: 100%;
        }

        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
            margin-bottom: 15px;
        }

        .upload-area:hover {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-area.has-file {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-icon {
            font-size: 40px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .upload-text {
            font-size: 14px;
            color: #333333;
            margin-bottom: 5px;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .upload-subtext {
            font-size: 12px;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .file-input {
            display: none;
        }

        .grid-options {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .grid-btn {
            flex: 1;
            padding: 12px;
            border: 1px solid #333333;
            background: #E0E0E0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: normal;
            color: #333333;
            transition: all 0.2s;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .grid-btn.active {
            background: #333333;
            color: #FFFFFF;
            border-color: #333333;
        }

        .grid-btn:hover:not(.active) {
            background: #d0d0d0;
        }

        .color-palette {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            border: 3px solid #333333;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #333333;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 30px;
        }

        .btn {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #333333;
            border-radius: 6px;
            font-size: 14px;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s;
            background: #E0E0E0;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .btn-primary {
            background: #333333;
            color: #FFFFFF;
            border: 1px solid #333333;
        }

        .btn-primary:hover:not(:disabled) {
            background: #444444;
        }

        .btn-secondary {
            background: #333333;
            color: #FFFFFF;
            border: 1px solid #333333;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #444444;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            display: none;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: #0c5460;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .info-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 13px;
            color: #856404;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-shrink: 0;
        }

        .panel-title {
            font-size: 24px;
            font-weight: normal;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            color: #E87D3E;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #999;
        }

        .close-btn:hover {
            color: #333;
        }

        .editor-grid {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            width: 100%;
        }

        .canvas-wrapper {
            text-align: center;
            flex-shrink: 0;
            margin-bottom: 20px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .canvas-label {
            font-size: 17px;
            font-weight: normal;
            margin-bottom: 10px;
            color: #E87D3E;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .editor-canvas {
            max-width: 100%;
            width: auto;
            max-height: calc(100vh - 100px);
            aspect-ratio: 1 / 1; /* keep preview perfectly square */
            height: auto;
            border-radius: 10px;
            border: 2px solid #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background: #ffffff !important;
            display: block;
            margin: 0 auto;
        }

        #png-preview img { background: #ffffff !important; }

        .slider-control {
            margin-bottom: 20px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: normal;
            color: #333333;
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
            border: none;
        }

        /* ULTRA-AGGRESSIVE HIDING - MAXIMUM SPECIFICITY */
        .editor-actions,
        div.editor-actions,
        #editor-panel .editor-actions,
        body .editor-actions,
        html body .editor-actions {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            height: 0 !important;
            width: 0 !important;
            overflow: hidden !important;
            margin: 0 !important;
            padding: 0 !important;
            position: absolute !important;
            left: -9999px !important;
            top: -9999px !important;
        }
        
        /* Hide any buttons with Cancel or Apply text */
        button[onclick*="applyPhotoEdits"]:not(.viewer-btn),
        #editor-panel button[onclick*="applyPhotoEdits"]:not(.viewer-btn),
        body button[onclick*="applyPhotoEdits"]:not(.viewer-btn) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            height: 0 !important;
            width: 0 !important;
            position: absolute !important;
            left: -9999px !important;
        }
        
        /* Desktop view - ensure editor-actions is hidden */
        @media (min-width: 1025px) {
            .editor-actions,
            div.editor-actions,
            #editor-panel .editor-actions {
                display: none !important;
                visibility: hidden !important;
                opacity: 0 !important;
                height: 0 !important;
                width: 0 !important;
                overflow: hidden !important;
                margin: 0 !important;
                padding: 0 !important;
                position: absolute !important;
                left: -9999px !important;
            }
            
            button[onclick*="applyPhotoEdits"]:not(.viewer-btn) {
                display: none !important;
                visibility: hidden !important;
                opacity: 0 !important;
                height: 0 !important;
                width: 0 !important;
            }
        }

        /* Toggle Switch Styling */
        #stand-toggle + span,
        #addon-mounting-toggle + span {
            background-color: #ccc;
        }

        #stand-toggle:checked + span,
        #addon-mounting-toggle:checked + span {
            background-color: #2d5016;
        }

        #stand-toggle + span:before,
        #addon-mounting-toggle + span:before {
            content: "";
            position: absolute;
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }

        #stand-toggle:checked + span:before,
        #addon-mounting-toggle:checked + span:before {
            content: "";
            position: absolute;
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
            transform: translateX(20px);
        }

        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }

            .control-panel {
                width: 100%;
            }

            #canvas-container {
                height: 400px;
            }

            .editor-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Left Panel: Editor (initial) and 3D Viewer -->
        <div class="viewer-panel">
            <!-- Inline Editor Panel (shown first) -->
            <div id="editor-panel">
                <div class="panel-header">
                    <h2 class="panel-title" id="desktop-panel-title">Edit Your Photo</h2>
                    <button class="viewer-btn" onclick="show3DView()">View in 3D</button>
                </div>
                <div class="editor-grid" style="margin-top:12px;">
                    <div class="canvas-wrapper">
                        <div class="canvas-label" id="desktop-canvas-label" style="display: none;">Processed (Posterized)</div>
                        <div style="position: relative; display: flex; align-items: center; justify-content: center; width: 100%;">
                            <canvas id="processed-canvas" class="editor-canvas" style="max-width:100%; max-height:calc(100vh - 100px); width:auto; aspect-ratio:1/1; cursor: crosshair;"></canvas>
                            <div id="processed-controls" style="position: absolute; top: 0; left: calc(50% + 1px); margin-left: 10px; display: flex !important; flex-direction: column; gap: 8px; z-index: 1000; pointer-events: auto;">
                                <button class="btn" onclick="zoomInProcessed()" style="padding: 12px 16px; font-size: 20px; min-width: 44px; min-height: 44px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; display: flex; align-items: center; justify-content: center;" title="Zoom In">+</button>
                                <button class="btn" onclick="zoomOutProcessed()" style="padding: 12px 16px; font-size: 20px; min-width: 44px; min-height: 44px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; display: flex; align-items: center; justify-content: center;" title="Zoom Out">‚àí</button>
                                <button class="btn" onclick="resetZoomProcessed()" style="padding: 12px 16px; font-size: 20px; min-width: 44px; min-height: 44px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; display: flex; align-items: center; justify-content: center;" title="Reset View">‚ñ°</button>
                                <button class="btn" onclick="togglePanProcessed()" id="processed-pan-btn" style="padding: 12px 16px; font-size: 20px; min-width: 44px; min-height: 44px; background: #E0E0E0; border: 1px solid #333333; border-radius: 6px; cursor: pointer; box-shadow: none; color: #333333; display: flex; align-items: center; justify-content: center;" title="Pan">‚§°</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3D Viewer (hidden initially) -->
            <div id="canvas-container" style="display:none;">
                <div class="viewer-controls">
                    <button class="viewer-btn" onclick="showEditorPanel()" id="edit-photo-btn">Edit Photo</button>
                    <button class="viewer-btn icon-only" onclick="resetCamera()" title="Reset View">‚Ü∫</button>
                    <button class="viewer-btn icon-only" onclick="toggleWireframe()" title="Toggle Wireframe">‚ñ°</button>
                </div>
                <div id="three-placeholder" class="placeholder">
                    <div class="placeholder-icon">‚ñ°</div>
                    <div>Upload an STL file to preview your 3D model</div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Controls -->
        <div class="control-panel">
            <h1 class="title" id="desktop-main-title">3D Album Cover Mosaic Builder</h1>
            <div class="price" id="desktop-price-subtitle">Create colorized 3D prints</div>

            <!-- Upload PNG -->
            <div class="section">
                <div class="section-label" id="desktop-section-upload">1. Upload Color Image</div>
                <label for="png-input" class="upload-area" id="png-upload-area" style="cursor: pointer;">
                    <div class="upload-icon">üñºÔ∏è</div>
                    <div class="upload-text" id="png-upload-text">Choose image file...</div>
                    <div class="upload-subtext" id="png-upload-subtext">Will be resized to 75√ó75 pixels</div>
                </label>
                <input type="file" id="png-input" class="file-input" accept=".png,.jpg,.jpeg,.heic,.heif" />
                
                <!-- Crop Buttons - Always visible when image is uploaded -->
                <div id="crop-buttons" style="display: none; margin-top: 15px;">
                    <button class="btn" id="show-cropper-btn" onclick="showCropper()" style="width: 100%; background: #E0E0E0; color: #333333; border: 1px solid #333333;">
                        Show Cropper
                    </button>
                    <button class="btn" id="hide-cropper-btn" onclick="hideCropper()" style="width: 100%; background: #E0E0E0; color: #333333; border: 1px solid #333333; display: none; margin-top: 10px;">
                        Hide Cropper ^
                    </button>
                </div>
                
                <!-- PNG Preview with Crop Tool -->
                <div id="png-preview" style="display: none; text-align: center; margin-top: 15px;">
                    <div id="crop-container" style="position: relative; display: inline-block; max-width: 350px; width: 100%; box-sizing: border-box; margin: 0 auto;">
                        <img id="png-preview-img" style="width: 350px; height: 350px; max-width: 100%; max-height: 350px; object-fit: contain; border-radius: 8px; border: 2px solid #ddd; display: block; flex-shrink: 0; box-sizing: border-box;" />
                        <canvas id="crop-canvas" style="position: absolute; top: 0; left: 0; pointer-events: auto; display: none; border: none; background: transparent; z-index: 10; box-sizing: border-box;"></canvas>
                    </div>
            </div>
        </div>

            <!-- Grid Size -->
            <div class="section">
                <div class="section-label" id="desktop-section-grid">2. Select Grid Size</div>
                <div class="grid-options">
                    <button class="grid-btn" data-size="48" onclick="selectGridSize(48)">48 √ó 48</button>
                    <button class="grid-btn active" data-size="75" onclick="selectGridSize(75)">75 √ó 75</button>
                    <button class="grid-btn" data-size="96" onclick="selectGridSize(96)">96 √ó 96</button>
                </div>
            </div>

            <!-- Image Adjustments (moved to right side) -->
            <div class="section">
                <div class="section-label" id="desktop-section-adjustments">Image Adjustments</div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Contrast</span>
                        <span id="contrast-value">1.2</span>
                    </div>
                    <input type="range" class="slider" id="contrast-slider" min="0" max="3" step="0.1" value="1.2" />
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Brightness</span>
                        <span id="brightness-value">1.0</span>
                    </div>
                    <input type="range" class="slider" id="brightness-slider" min="0" max="3" step="0.1" value="1.0" />
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Tones</span>
                        <span id="tones-value">4</span>
                    </div>
                    <input type="range" class="slider" id="tones-slider" min="2" max="4" step="1" value="4" />
                </div>
            </div>

            <!-- Painting -->
            <div class="section">
                <div class="section-label" id="desktop-section-painting">Painting</div>
            <div class="color-palette">
                    <div class="color-swatch selected" data-color="0,0,0" style="background: rgb(0,0,0);" title="Black" onclick="selectPaintColor(0, 0, 0, this)"></div>
                    <div class="color-swatch" data-color="85,85,85" style="background: rgb(85,85,85);" title="Dark Gray" onclick="selectPaintColor(85, 85, 85, this)"></div>
                    <div class="color-swatch" data-color="170,170,170" style="background: rgb(170,170,170);" title="Light Gray" onclick="selectPaintColor(170, 170, 170, this)"></div>
                    <div class="color-swatch" data-color="255,255,255" style="background: rgb(255,255,255);" title="White" onclick="selectPaintColor(255, 255, 255, this)"></div>
            </div>
                <div class="slider-control" style="margin-top: 15px;">
                    <div class="slider-label">
                        <span>Brush Size</span>
                        <span id="brush-size-value">1</span>
                    </div>
                    <input type="range" class="slider" id="brush-size-slider" min="1" max="10" step="1" value="1" />
                </div>
                <div id="undo-redo-buttons" style="display: none; margin-top: 15px; gap: 10px;" class="action-buttons">
                    <button class="btn" id="undo-btn" onclick="undoPaint()" style="flex: 1; background: #E0E0E0; color: #333333; border: 1px solid #333333;" disabled>‚Üê Undo</button>
                    <button class="btn" id="redo-btn" onclick="redoPaint()" style="flex: 1; background: #E0E0E0; color: #333333; border: 1px solid #333333;" disabled>Redo ‚Üí</button>
                </div>
                <button class="btn" onclick="resetProcessedImage()" style="width: 100%; margin-top: 10px; background: #E0E0E0; color: #333333; border: 1px solid #333333;">
                    Reset Image
                </button>
        </div>

            <!-- Price Display Section -->
            <div class="section" id="price-display-section" style="margin-top: 30px;">
                <div style="margin-bottom: 15px;">
                    <div id="main-price" style="font-size: 24px; font-weight: 600; color: #333; margin-bottom: 5px;">$119.99</div>
                    <div id="price-details" style="font-size: 12px; color: #666; line-height: 1.5;">
                        <div>Dimensions: <span id="price-dimensions">75 √ó 75</span></div>
                        <div>Addons: <span id="breakdown-addons">None</span></div>
                    </div>
                </div>
                
                <!-- Stand Toggle -->
                <div id="stand-section" style="margin-top: 20px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f9f9f9; border-radius: 6px;">
                        <div style="display: flex; align-items: center; flex: 1;">
                            <img id="stand-image" src="" alt="Stand" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 12px; display: none;">
                            <div style="flex: 1;">
                                <div style="font-size: 14px; font-weight: 500; color: #333;">Stand</div>
                                <div id="stand-price-display" style="font-size: 12px; color: #666;">$10.00</div>
                            </div>
                        </div>
                        <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                            <input type="checkbox" id="stand-toggle" style="opacity: 0; width: 0; height: 0;" onchange="updateStandAndPrice()">
                            <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; border-radius: 24px; transition: .4s;"></span>
                        </label>
                    </div>
                </div>
                
                <!-- Add-ons Section -->
                <div id="addons-section" style="margin-top: 20px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: #f9f9f9; border-radius: 6px;">
                        <div style="display: flex; align-items: center; flex: 1;">
                            <img id="mounting-image" src="" alt="Wall Mounting Dots" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 12px; display: none;">
                            <div style="flex: 1;">
                                <div style="font-size: 14px; font-weight: 500; color: #333;">Nano Wall Mounting Dots (Pack of 8)</div>
                                <div id="addon-mounting-price" style="font-size: 12px; color: #666;">$5.99</div>
                            </div>
                        </div>
                        <label style="position: relative; display: inline-block; width: 44px; height: 24px;">
                            <input type="checkbox" id="addon-mounting-toggle" style="opacity: 0; width: 0; height: 0;" onchange="updateTotalPrice()">
                            <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; border-radius: 24px; transition: .4s;"></span>
                        </label>
                    </div>
                </div>
                
                <!-- Add to Cart Button -->
                <button id="add-to-cart-btn" style="width: 100%; padding: 16px; margin-top: 20px; background: #2d5016; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; text-transform: uppercase;">ADD TO CART</button>
                <button id="buy-now-btn" style="display: none; width: 100%; padding: 16px; margin-top: 10px; background: #2d5016; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; text-transform: uppercase;">BUY NOW</button>
            </div>

            <!-- Status Message -->
        <div class="status-message" id="status-message"></div>

        <!-- Info Box -->
        <div class="info-box" style="background: transparent; border: none; padding: 20px; margin: 20px 0; text-align: left; max-width: 100%; box-sizing: border-box;">
            <div id="desktop-info-title" style="font-size: 16px; font-weight: bold; margin-bottom: 15px; color: #333; text-align: left;">Custom Brick Mosaic Designer</div>
            <div id="desktop-info-description" style="font-size: 14px; line-height: 1.6; color: #666; margin-bottom: 15px; text-align: left;">
                Turn your favourite photos into stunning brick art‚Äîmade by you!
            </div>
            <div id="desktop-info-additional" style="font-size: 14px; line-height: 1.6; color: #666; text-align: left;">
                Bring your memories to life, one brick at a time. With our Custom Brick Mosaic Designer you can transform any image into a beautiful 3D printable mosaic.
            </div>
        </div>

        <!-- Directions Section -->
        <div style="padding: 20px; margin-top: 20px; background: transparent;">
            <div id="desktop-howto-title" style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #333;">How to Use</div>
            <div id="desktop-howto-content" style="font-size: 14px; line-height: 1.8; color: #666;">
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">1. Upload Your Image</strong>
                    Click the "Upload" button and select a photo from your device. The image will be automatically processed.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">2. Adjust Size & Crop</strong>
                    Use the "Size" button to crop your image and choose your grid size (48√ó48, 75√ó75, or 96√ó96). Drag the blue crop box to select the area you want to use.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">3. Fine-Tune Adjustments</strong>
                    Click "Adjust" to modify brightness, contrast, and other settings to get the perfect look for your mosaic.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">4. Paint & Customize (Optional)</strong>
                    Use the "Paint" button to manually adjust individual colors and add your personal touch to the design.
                </div>
                <div style="margin-bottom: 16px;">
                    <strong style="color: #333; display: block; margin-bottom: 4px;">5. View in 3D</strong>
                    Click "View in 3D" to see your custom brick mosaic come to life. Rotate and zoom to explore your creation.
                </div>
                <div>
                    <strong style="color: #333; display: block; margin-bottom: 4px;">6. Proceed to Checkout</strong>
                    Once you're happy with your design, click "Proceed to Checkout" to order your custom brick mosaic.
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Backend API Configuration - UPDATE THIS WITH YOUR BACKEND SERVER URL
        // Example: 'https://your-backend.onrender.com' or 'https://your-backend.railway.app'
        // Auto-detect localhost vs production
        const BACKEND_URL = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
            ? 'http://localhost:5003'  // Local development on port 5003
            : 'https://rizepics.onrender.com'; // Production (Render) - matches admin panel
        
        // Helper function to get API URL
        function getApiUrl(path) {
            if (BACKEND_URL) {
                // Ensure BACKEND_URL doesn't end with slash and path starts with slash
                const baseUrl = BACKEND_URL.replace(/\/$/, '');
                const cleanPath = path.startsWith('/') ? path : '/' + path;
                const fullUrl = baseUrl + cleanPath;
                console.log(`üîó API Call: ${fullUrl}`);
                return fullUrl;
            }
            return path; // Use relative URL if no backend URL set
        }
        
        // Log backend URL on load
        console.log('üöÄ Backend URL configured:', BACKEND_URL);
        
        // Responsive resize detection - switch to mobile if window becomes small
        (function() {
            const BREAKPOINT = 1024;
            
            // Check if device is actually a mobile device (by user agent)
            function isRealMobileDevice() {
                const userAgent = navigator.userAgent || navigator.vendor || window.opera;
                return /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
            }
            
            // Check and redirect function
            function checkAndRedirect() {
                const currentWidth = window.innerWidth;
                console.log(`üîç Current window width: ${currentWidth}px, breakpoint: ${BREAKPOINT}px`);
                
                // Real mobile devices should be on mobile, but if somehow on desktop, let them stay
                // For desktop browsers, switch to mobile if window becomes small
                if (!isRealMobileDevice() && currentWidth < BREAKPOINT) {
                    console.log('üì± Window width < 1024px, switching to mobile...');
                    window.location.href = '/mobile/';
                }
            }
            
            // Check immediately on page load
            checkAndRedirect();
            
            // Debounce function to prevent too many redirects
            let resizeTimeout;
            function debounceResize(callback, delay) {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(callback, delay);
            }
            
            // Add resize event listener
            window.addEventListener('resize', function() {
                console.log('üìê Window resized, checking width...');
                debounceResize(checkAndRedirect, 300); // Reduced to 300ms for faster response
            });
            
            // Also check on orientation change (for tablets)
            window.addEventListener('orientationchange', function() {
                setTimeout(checkAndRedirect, 100);
            });
        })();
        
        // Shopify Configuration
        // Get Shopify store URL from URL parameters, current domain, or config
        const urlParams = new URLSearchParams(window.location.search);
        
        // Try multiple methods to detect Shopify store URL
        let shopifyStore = urlParams.get('shop');
        
        // Method 1: Check if we're on a Shopify domain
        if (!shopifyStore && window.location.hostname.includes('myshopify.com')) {
            shopifyStore = window.location.hostname;
            console.log('‚úÖ Detected Shopify store from domain:', shopifyStore);
        }
        
        // Method 2: Check if parent window is Shopify (for embedded apps)
        if (!shopifyStore && window.parent && window.parent.location.hostname.includes('myshopify.com')) {
            shopifyStore = window.parent.location.hostname;
            console.log('‚úÖ Detected Shopify store from parent window:', shopifyStore);
        }
        
        // Method 3: Check window.Shopify object
        if (!shopifyStore && (window.Shopify || window.parent.Shopify)) {
            const shopifyObj = window.Shopify || window.parent.Shopify;
            if (shopifyObj.shop) {
                shopifyStore = shopifyObj.shop;
                console.log('‚úÖ Detected Shopify store from Shopify object:', shopifyStore);
            }
        }
        
        // Method 4: Default fallback (user should configure this)
        if (!shopifyStore) {
            shopifyStore = 'your-store.myshopify.com'; // USER: Replace with your actual Shopify store
            console.warn('‚ö†Ô∏è Using default Shopify store. To configure: Add ?shop=your-store.myshopify.com to URL or update this default value.');
        }
        
        const SHOPIFY_STORE_URL = shopifyStore.startsWith('http') ? shopifyStore : `https://${shopifyStore}`;
        const SHOPIFY_PRODUCT_URL = `${SHOPIFY_STORE_URL}/products/3d-album-mosaic`; // Fallback URL
        
        console.log('üõí Shopify Store URL:', SHOPIFY_STORE_URL);
        
        // Initialize Shopify Cart Service
        let shopifyCart = null;
        // Check if we're in Shopify context (iframe, Shopify domain, or shopify param)
        const isInIframe = window.self !== window.top;
        const isShopifyDomain = window.location.hostname.includes('myshopify.com') || 
                               window.parent.location.hostname.includes('myshopify.com');
        const hasShopifyParam = urlParams.get('shopify') === 'true';
        
        if (hasShopifyParam || isInIframe || isShopifyDomain) {
            try {
                if (typeof ShopifyCartService !== 'undefined') {
                    const storeUrl = ShopifyCartService.getStoreUrl() || SHOPIFY_STORE_URL;
                    if (storeUrl && storeUrl !== 'https://your-store.myshopify.com') {
                        shopifyCart = new ShopifyCartService(storeUrl);
                        console.log('‚úÖ Shopify Cart Service initialized:', storeUrl);
                    } else {
                        console.warn('‚ö†Ô∏è Shopify store URL not configured');
                    }
                } else {
                    console.warn('‚ö†Ô∏è ShopifyCartService not loaded');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Shopify Cart Service initialization error:', error);
            }
        }
        
        // Shopify Variant IDs - Get from backend API or environment
        // These will be loaded from backend configuration
        let shopifyVariants = {
            48: null,  // Will be loaded from API
            75: null,
            96: null,
            stand: null,
            mounting: null
        };
        
        // Load Shopify variant IDs from backend
        async function loadShopifyVariants() {
            try {
                const response = await fetch(getApiUrl('/api/shopify/variants'));
                if (response.ok) {
                    const data = await response.json();
                    shopifyVariants = {
                        48: data.variant_48 || null,
                        75: data.variant_75 || null,
                        96: data.variant_96 || null,
                        stand: data.variant_stand || null,
                        mounting: data.variant_mounting || null
                    };
                    console.log('‚úÖ Shopify variants loaded:', shopifyVariants);
                    // Show Buy Now button if we have variants
                    const buyNowBtn = document.getElementById('buy-now-btn');
                    if (buyNowBtn && (shopifyVariants[48] || shopifyVariants[75] || shopifyVariants[96])) {
                        buyNowBtn.style.display = 'block';
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not load Shopify variants:', error);
            }
        }
        
        // Load variants on page load if in Shopify context
        const isInIframeForVariants = window.self !== window.top;
        const isShopifyDomainForVariants = window.location.hostname.includes('myshopify.com') || 
                                          window.parent.location.hostname.includes('myshopify.com');
        if (urlParams.get('shopify') === 'true' || isInIframeForVariants || isShopifyDomainForVariants) {
            loadShopifyVariants();
        }

        // Price management
        let prices = {};
        let productImages = {};
        let textContent = {};
        let selectedAddons = {
            mounting: false
        };
        let standSelected = false; // Default to stand OFF

        // Load prices from API
        async function loadPrices() {
            try {
                const response = await fetch(getApiUrl('/api/prices'));
                prices = await response.json();
                await loadImages();
                await loadTextContent();
                updatePriceDisplay();
            } catch (error) {
                console.error('Failed to load prices:', error);
            }
        }

        // Load text content from API
        async function loadTextContent() {
            try {
                // Add cache-busting parameter to ensure fresh content
                const response = await fetch(getApiUrl('/api/content?t=' + Date.now()));
                textContent = await response.json();
                updateTextContent();
            } catch (error) {
                console.error('Failed to load text content:', error);
            }
        }
        
        // Periodically refresh content to pick up admin changes
        setInterval(() => {
            loadTextContent();
        }, 5000); // Check every 5 seconds

        // Update text content on page
        function updateTextContent() {
            // Upload area text
            if (textContent.upload_image_text) {
                const uploadText = document.getElementById('png-upload-text');
                if (uploadText) uploadText.textContent = textContent.upload_image_text;
            }
            if (textContent.upload_subtext) {
                const uploadSubtext = document.getElementById('png-upload-subtext');
                if (uploadSubtext) uploadSubtext.textContent = textContent.upload_subtext;
            }
            
            // STL upload text
            // STL upload UI removed - these elements no longer exist
            // if (textContent.stl_upload_text) {
            //     const stlText = document.getElementById('stl-upload-text');
            //     if (stlText) stlText.textContent = textContent.stl_upload_text;
            // }
            // if (textContent.stl_subtext) {
            //     const stlSubtext = document.getElementById('stl-upload-subtext');
            //     if (stlSubtext) stlSubtext.textContent = textContent.stl_subtext;
            // }
            
            // Info box content (using mobile view text)
            if (textContent.info_title) {
                const titleEl = document.getElementById('desktop-info-title');
                if (titleEl) titleEl.textContent = textContent.info_title;
            }
            if (textContent.info_description) {
                const descEl = document.getElementById('desktop-info-description');
                if (descEl) descEl.textContent = textContent.info_description;
            }
            if (textContent.info_additional) {
                const addEl = document.getElementById('desktop-info-additional');
                if (addEl) addEl.textContent = textContent.info_additional;
            }
            
            // Main title and subtitle
            if (textContent.title) {
                const titleEl = document.getElementById('desktop-main-title');
                if (titleEl) titleEl.textContent = textContent.title;
            }
            if (textContent.price_subtitle) {
                const subtitleEl = document.getElementById('desktop-price-subtitle');
                if (subtitleEl) subtitleEl.textContent = textContent.price_subtitle;
            }
            
            // Panel title
            if (textContent.panel_title) {
                const panelTitleEl = document.getElementById('desktop-panel-title');
                if (panelTitleEl) panelTitleEl.textContent = textContent.panel_title;
            }
            
            // Canvas label
            if (textContent.canvas_label) {
                const canvasLabelEl = document.getElementById('desktop-canvas-label');
                if (canvasLabelEl) canvasLabelEl.textContent = textContent.canvas_label;
            }
            
            // Section labels
            if (textContent.section_upload) {
                const sectionUploadEl = document.getElementById('desktop-section-upload');
                if (sectionUploadEl) sectionUploadEl.textContent = textContent.section_upload;
            }
            if (textContent.section_grid) {
                const sectionGridEl = document.getElementById('desktop-section-grid');
                if (sectionGridEl) sectionGridEl.textContent = textContent.section_grid;
            }
            if (textContent.section_adjustments) {
                const sectionAdjustmentsEl = document.getElementById('desktop-section-adjustments');
                if (sectionAdjustmentsEl) sectionAdjustmentsEl.textContent = textContent.section_adjustments;
            }
            if (textContent.section_painting) {
                const sectionPaintingEl = document.getElementById('desktop-section-painting');
                if (sectionPaintingEl) sectionPaintingEl.textContent = textContent.section_painting;
            }
            
            // How to Use section
            if (textContent.howto_title) {
                const howtoTitleEl = document.getElementById('desktop-howto-title');
                if (howtoTitleEl) howtoTitleEl.textContent = textContent.howto_title;
            }
            if (textContent.howto_content) {
                const howtoContentEl = document.getElementById('desktop-howto-content');
                if (howtoContentEl) {
                    // Parse the howto_content and format it with the step structure
                    const steps = textContent.howto_content.split('\n\n');
                    let formattedContent = '';
                    steps.forEach((step, index) => {
                        const lines = step.split('\n');
                        const title = lines[0];
                        const description = lines.slice(1).join(' ');
                        formattedContent += `
                            <div style="margin-bottom: 16px;">
                                <strong style="color: #333; display: block; margin-bottom: 4px;">${title}</strong>
                                ${description}
                            </div>
                        `;
                    });
                    howtoContentEl.innerHTML = formattedContent;
                }
            }
        }

        // Load product images from API
        async function loadImages() {
            try {
                // Add cache-busting parameter to force reload
                const response = await fetch(getApiUrl('/api/images?t=' + Date.now()));
                const images = await response.json();
                console.log('Loaded images from server (raw):', images);
                
                // Convert relative image URLs to full backend URLs
                productImages = {};
                for (const [key, value] of Object.entries(images)) {
                    if (value && typeof value === 'string') {
                        // If it's a relative URL (starts with /), convert to full backend URL
                        if (value.startsWith('/')) {
                            productImages[key] = BACKEND_URL.replace(/\/$/, '') + value;
                        } else if (value.startsWith('http://') || value.startsWith('https://')) {
                            // Already a full URL, use as-is
                            productImages[key] = value;
                        } else {
                            // Relative path without leading slash, add backend URL
                            productImages[key] = BACKEND_URL.replace(/\/$/, '') + '/' + value;
                        }
                    } else {
                        productImages[key] = value;
                    }
                }
                console.log('Loaded images from server (converted):', productImages);
                updateProductImages();
            } catch (error) {
                console.error('Failed to load images:', error);
            }
        }

        // Update product images display
        function updateProductImages() {
            console.log('Updating product images:', productImages);
            
            // Stand image
            const standImage = document.getElementById('stand-image');
            if (standImage) {
                if (productImages.stand) {
                    // Convert relative URL to full backend URL if needed
                    let imageUrl = productImages.stand;
                    if (!imageUrl.startsWith('http')) {
                        // It's a relative URL, convert to full backend URL
                        imageUrl = getApiUrl(imageUrl.startsWith('/') ? imageUrl : '/' + imageUrl);
                    }
                    // Add cache-busting parameter to image URL
                    imageUrl = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
                    standImage.src = imageUrl;
                    standImage.style.display = 'block';
                    standImage.onerror = function() {
                        console.error('‚ùå Failed to load stand image from:', imageUrl);
                        standImage.style.display = 'none';
                    };
                    standImage.onload = function() {
                        console.log('‚úÖ Stand image loaded successfully:', imageUrl);
                    };
                } else {
                    console.log('‚ö†Ô∏è No stand image in productImages');
                    standImage.style.display = 'none';
                }
            }
            
            // Mounting dots image
            const mountingImage = document.getElementById('mounting-image');
            if (mountingImage) {
                if (productImages.wall_mounting_dots) {
                    // Convert relative URL to full backend URL if needed
                    let imageUrl = productImages.wall_mounting_dots;
                    if (!imageUrl.startsWith('http')) {
                        // It's a relative URL, convert to full backend URL
                        imageUrl = getApiUrl(imageUrl.startsWith('/') ? imageUrl : '/' + imageUrl);
                    }
                    // Add cache-busting parameter to image URL
                    imageUrl = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
                    mountingImage.src = imageUrl;
                    mountingImage.style.display = 'block';
                    mountingImage.onerror = function() {
                        console.error('‚ùå Failed to load mounting image from:', imageUrl);
                        mountingImage.style.display = 'none';
                    };
                    mountingImage.onload = function() {
                        console.log('‚úÖ Mounting image loaded successfully:', imageUrl);
                    };
                } else {
                    console.log('‚ö†Ô∏è No wall_mounting_dots image in productImages');
                    mountingImage.style.display = 'none';
                }
            }
        }

        // Update price display based on selected grid size, stand, and addons
        function updatePriceDisplay() {
            const gridSize = selectedGridSize || 75;
            const priceKey = `${gridSize}x${gridSize}`;
            const basePrice = prices[priceKey] || 0;
            
            // Calculate total with stand and addons
            let total = basePrice;
            
            // Add stand price if selected
            if (standSelected) {
                total += prices.stand || 0;
            }
            
            // Add addons
            if (selectedAddons.mounting) {
                total += prices.wall_mounting_dots || 0;
            }
            
            // Update main price
            const mainPriceEl = document.getElementById('main-price');
            if (mainPriceEl) {
                mainPriceEl.textContent = `$${total.toFixed(2)}`;
            }
            
            // Update dimensions
            const dimensionsEl = document.getElementById('price-dimensions');
            if (dimensionsEl) {
                dimensionsEl.textContent = `${gridSize} √ó ${gridSize}`;
            }
            
            // Update stand price display
            const standPriceEl = document.getElementById('stand-price-display');
            if (standPriceEl) {
                const standPrice = prices.stand || 0;
                standPriceEl.textContent = `$${standPrice.toFixed(2)}`;
            }
            
            // Update addons breakdown
            updateOrderBreakdown();
            
            // Update addon prices
            const mountingPriceEl = document.getElementById('addon-mounting-price');
            if (mountingPriceEl && prices.wall_mounting_dots !== undefined) {
                mountingPriceEl.textContent = `$${prices.wall_mounting_dots.toFixed(2)}`;
            }
        }

        // Update stand selection and total price
        function updateStandAndPrice() {
            const standToggle = document.getElementById('stand-toggle');
            standSelected = standToggle ? standToggle.checked : false;
            updatePriceDisplay();
        }

        // Update total price when addons change
        function updateTotalPrice() {
            const mountingToggle = document.getElementById('addon-mounting-toggle');
            
            selectedAddons.mounting = mountingToggle ? mountingToggle.checked : false;
            
            updatePriceDisplay();
        }

        // Update order breakdown display
        function updateOrderBreakdown() {
            const breakdownAddons = document.getElementById('breakdown-addons');
            
            if (breakdownAddons) {
                const addons = [];
                if (standSelected) {
                    addons.push('Stand');
                }
                if (selectedAddons.mounting) {
                    addons.push('Nano');
                }
                
                if (addons.length > 0) {
                    breakdownAddons.textContent = addons.join(', ');
                } else {
                    breakdownAddons.textContent = 'None';
                }
            }
        }

        let stlFile = null;
        let pngFile = null;
        let pngImage = null;
        let scene, camera, renderer, controls, currentMesh;
        let originalGeometry = null;
        let selectedGridSize = 75;
        let rawUploadedImage = null;
        let editorSettings = {
            contrast: 1.2,
            brightness: 1.0,
            pixelSize: 75,
            tones: 4,
            blackPoint: 0,
            whitePoint: 255
        };
        // Crop variables
        let cropperVisible = false;
        let cropperManuallyHidden = false; // Track if user manually hid the cropper
        let cropX = 0, cropY = 0, cropSize = 0;
        let cropInitialized = false; // Track if crop has ever been initialized
        let isDraggingCrop = false;
        let isResizingCrop = false;
        let resizeEdge = ''; // 'left', 'right', 'top', 'bottom', 'topleft', 'topright', 'bottomleft', 'bottomright'
        let dragStartX = 0, dragStartY = 0;
        let cropStartX = 0, cropStartY = 0, cropStartSize = 0;
        // Cropper zoom/pan variables
        let cropperZoom = 1.0;
        let cropperPanX = 0;
        let cropperPanY = 0;
        let isPanningCropper = false;
        let panStartX = 0, panStartY = 0;
        
        // Paint variables
        let selectedPaintColor = { r: 0, g: 0, b: 0 }; // Default to black
        let brushSize = 1; // Brush size in pixels (1 = single pixel, larger = area)
        let processedImageData = null; // Store the processed image data for pixel editing
        let originalProcessedImageData = null; // Store the original processed image data (before painting)
        let undoStack = []; // Stack for undo history
        let redoStack = []; // Stack for redo history
        let lastPaintState = null; // Store state before current paint stroke starts
        let processedZoom = 1.0; // Zoom level for processed canvas
        let processedZoomOffsetX = 0;
        let processedZoomOffsetY = 0;
        let isPanningProcessed = false;
        let processedPanStartX = 0, processedPanStartY = 0;
        let zoomMode = null; // 'zoom-in', 'zoom-out', or null
        let fullOriginalImage = null; // Store the full original uncropped image
        let cropCoordinates = null; // Store crop coordinates {x, y, size} for processing
        let fullProcessedImageDataURL = null; // Store the full processed image snapshot for cropper preview

        const pixelSizes = [48, 75, 96];

        // IndexedDB persistence for files
        let dbPromise = null;
        function openDB() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
                const req = indexedDB.open('albumCoverDB', 1);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains('files')) {
                        db.createObjectStore('files');
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
            return dbPromise;
        }

        // Key helper for per-size storage
        function dbKey(type, size = selectedGridSize) {
            return `${type}_${size}`;
        }

        async function saveFileToDB(key, file) {
            try {
                const db = await openDB();
                await new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readwrite');
                    const store = tx.objectStore('files');
                    const value = { name: file.name, type: file.type, blob: file };
                    const req = store.put(value, key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                console.warn('Failed to save file to IndexedDB', e);
            }
        }

        async function loadFileFromDB(key) {
            try {
                const db = await openDB();
                return await new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const req = store.get(key);
                    req.onsuccess = () => resolve(req.result || null);
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                console.warn('Failed to load file from IndexedDB', e);
                return null;
            }
        }

        // Persist simple state in localStorage
        function saveSimpleState() {
            localStorage.setItem('selectedGridSize', String(selectedGridSize));
            localStorage.setItem('editorSettings', JSON.stringify(editorSettings));
        }
        
        // Save image state to localStorage for persistence across view switches
        function saveImageState(img, file) {
            try {
                console.log('üíæ Saving image state to localStorage...');
                
                // Convert image to DataURL for storage
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const imageDataURL = canvas.toDataURL('image/png');
                
                // Save image data
                const imageState = {
                    dataURL: imageDataURL,
                    width: img.width,
                    height: img.height,
                    fileName: file.name,
                    fileSize: file.size,
                    fileType: file.type,
                    timestamp: Date.now()
                };
                
                localStorage.setItem('uploadedImageState', JSON.stringify(imageState));
                console.log('‚úÖ Image state saved to localStorage');
                return true;
            } catch (e) {
                console.warn('‚ö†Ô∏è Failed to save image state:', e);
                return false;
            }
        }
        
        // Restore image state from localStorage
        function restoreImageState() {
            try {
                console.log('üìÇ Checking for saved image state...');
                const saved = localStorage.getItem('uploadedImageState');
                if (!saved) {
                    console.log('üìÇ No saved image state found');
                    return false;
                }
                
                const imageState = JSON.parse(saved);
                console.log('üìÇ Found saved image state:', imageState.fileName);
                
                // Check if state is recent (within 24 hours)
                const age = Date.now() - imageState.timestamp;
                if (age > 24 * 60 * 60 * 1000) {
                    console.log('üìÇ Saved image state is too old, ignoring');
                    localStorage.removeItem('uploadedImageState');
                    return false;
                }
                
                // Restore image from DataURL
                const img = new Image();
                img.onload = () => {
                    console.log('‚úÖ Restored image from localStorage');
                    rawUploadedImage = img;
                    fullOriginalImage = img;
                    
                    // Show editor panel
                    showEditorPanel();
                    
                    // Process the restored image
                    try {
                        processImage();
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Error processing restored image:', error);
                    }
                };
                img.onerror = () => {
                    console.warn('‚ö†Ô∏è Failed to load restored image');
                    localStorage.removeItem('uploadedImageState');
                };
                img.src = imageState.dataURL;
                
                return true;
            } catch (e) {
                console.warn('‚ö†Ô∏è Failed to restore image state:', e);
                localStorage.removeItem('uploadedImageState');
                return false;
            }
        }

        function loadSimpleState() {
            const sizeStr = localStorage.getItem('selectedGridSize');
            if (sizeStr) {
                const s = parseInt(sizeStr);
                if ([32,48,75,96].includes(s)) {
                    selectedGridSize = s;
                }
            }
            const es = localStorage.getItem('editorSettings');
            if (es) {
                try {
                    const parsed = JSON.parse(es);
                    editorSettings = { ...editorSettings, ...parsed };
                } catch {}
            }
        }

        async function restoreForSize(size) {
            // PNG
            const pngEntry = await loadFileFromDB(dbKey('png', size));
            if (pngEntry && pngEntry.blob) {
                const restoredPNG = new File([pngEntry.blob], pngEntry.name || 'image.png', { type: pngEntry.type || 'image/png' });
                pngFile = restoredPNG;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        rawUploadedImage = img;
                        fullOriginalImage = img; // Store full original uncropped image
                        cropCoordinates = null; // Reset crop coordinates when restoring image
                        pngImage = img;
                        
                        // Reset cropper state when restoring image
                        fullProcessedImageDataURL = null;
                        cropperVisible = false;
                        cropperManuallyHidden = false; // Reset flag when restoring
                        cropInitialized = false;
                        const previewImg = document.getElementById('png-preview-img');
                        if (previewImg) {
                            previewImg.removeAttribute('data-cropper-fixed');
                        }
                        document.getElementById('png-preview').style.display = 'none';
                        document.getElementById('crop-canvas').style.display = 'none';
                        document.getElementById('show-cropper-btn').style.display = 'block';
                        document.getElementById('hide-cropper-btn').style.display = 'none';
                        
                        // Show original image in editor
                        // Original image canvas removed - no longer needed
                        // Auto-tune per restored image
                        autoTuneSettingsFromImage(img);
                        document.getElementById('contrast-slider').value = String(editorSettings.contrast);
                        document.getElementById('brightness-slider').value = String(editorSettings.brightness);
                        document.getElementById('contrast-value').textContent = editorSettings.contrast.toFixed(1);
                        document.getElementById('brightness-value').textContent = editorSettings.brightness.toFixed(1);
                        // Don't set preview image here - it will be set to processed version after processImage() runs
                        // document.getElementById('png-preview-img').src = ev.target.result;
                        // Show crop buttons when image is restored
                        document.getElementById('crop-buttons').style.display = 'block';
                        // Don't show preview automatically - only show when "Show Cropper" is clicked
                        // document.getElementById('png-preview').style.display = 'block';
                        document.getElementById('png-upload-area').classList.add('has-file');
                        document.getElementById('png-upload-text').textContent = restoredPNG.name;
                        if (currentMesh) applyColorsToMesh();
                        processImage();
                        // Automatically show cropper after image is processed (with small delay to ensure processed canvas is ready)
                        // Only auto-show if user hasn't manually hidden it
                        if (!cropperManuallyHidden) {
                            setTimeout(() => {
                                showCropper();
                            }, 100);
                        }
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(restoredPNG);
            } else {
                // Clear preview if no PNG for this size
                document.getElementById('png-preview').style.display = 'none';
                document.getElementById('crop-buttons').style.display = 'none';
                document.getElementById('png-upload-area').classList.remove('has-file');
                document.getElementById('png-upload-text').textContent = 'Choose image file...';
                pngFile = null;
            }

            // STL - Try to restore from IndexedDB first, then fall back to server
            const stlEntry = await loadFileFromDB(dbKey('stl', size));
            if (stlEntry && stlEntry.blob) {
                const restoredSTL = new File([stlEntry.blob], stlEntry.name || `${size}x${size}_grid.stl`, { type: stlEntry.type || 'application/octet-stream' });
                stlFile = restoredSTL;
                // STL upload UI removed, but still load the STL file
                loadSTL(restoredSTL);
                console.log(`‚úÖ Restored STL for ${size}√ó${size} grid from cache`);
            } else {
                // No STL in IndexedDB, load from server
                await loadSTLFromServer(size);
            }
        }

        // Helper function to create processed image at a specific size
        function createProcessedImageAtSize(image, targetSize, callback) {
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = targetSize;
            finalCanvas.height = targetSize;
            const finalCtx = finalCanvas.getContext('2d');

            // If crop coordinates exist, crop from the full original image first
            let imageToProcess = image;
            if (cropCoordinates && cropCoordinates.size > 0) {
                // Create cropped version from full original
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = cropCoordinates.size;
                cropCanvas.height = cropCoordinates.size;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(image, cropCoordinates.x, cropCoordinates.y, cropCoordinates.size, cropCoordinates.size, 0, 0, cropCoordinates.size, cropCoordinates.size);
                imageToProcess = cropCanvas;
            }

            // Draw and process (cropped image if crop exists, otherwise full image)
            finalCtx.drawImage(imageToProcess, 0, 0, targetSize, targetSize);
            const imageData = finalCtx.getImageData(0, 0, targetSize, targetSize);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }

            finalCtx.putImageData(imageData, 0, 0);

            // Convert to image
            finalCanvas.toBlob((blob) => {
                const processedFile = new File([blob], 'processed.png', { type: 'image/png' });
                const img = new Image();
                img.onload = () => {
                    if (callback) callback(processedFile, img);
                };
                img.src = URL.createObjectURL(blob);
            });
        }

        // Handle grid size selection
        async function selectGridSize(size) {
            selectedGridSize = size;
            saveSimpleState();
            
            // Update button states
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.size) === size) {
                    btn.classList.add('active');
                }
            });
            
            // Update text to show selected grid size
            document.getElementById('png-upload-subtext').textContent = `Will be resized to ${size}√ó${size} pixels`;
            // STL upload UI removed - STL files auto-load from server
            // Update price display
            updatePriceDisplay();
            
            console.log(`Grid size selected: ${size}√ó${size}`);

            // Clear current STL to allow restore
            stlFile = null;

            // If there's a current image loaded, reprocess it with the new size
            // Otherwise, restore saved files for this size
            if (rawUploadedImage) {
                // Reprocess current image with new grid size
                processImage(); // Update preview canvas
                // Also create new processed image for 3D view
                createProcessedImageAtSize(rawUploadedImage, size, (file, img) => {
                    pngFile = file;
                    pngImage = img;
                    // Save to IndexedDB for this size
                    saveFileToDB(dbKey('png', size), file);
                    // Apply colors to 3D mesh if loaded
                    if (currentMesh) {
                        applyColorsToMesh();
                    }
                });
                
                // Load STL for this size (from IndexedDB cache or server)
                const stlEntry = await loadFileFromDB(dbKey('stl', size));
                if (stlEntry && stlEntry.blob) {
                    const restoredSTL = new File([stlEntry.blob], stlEntry.name || `${size}x${size}_grid.stl`, { type: stlEntry.type || 'application/octet-stream' });
                    stlFile = restoredSTL;
                    // STL upload UI removed, but still load the STL file
                    loadSTL(restoredSTL);
                    console.log(`‚úÖ Restored STL for ${size}√ó${size} grid from cache`);
                } else {
                    // No cached STL, load from server
                    await loadSTLFromServer(size);
                }
            } else if (pngFile) {
                // If we have a processed PNG file, reload the original if possible
                // Otherwise, just restore saved files for this size
                await restoreForSize(size);
            } else {
                // No current image, restore saved PNG for this size
                await restoreForSize(size);
            }
        }

        // Photo Editor Functions
        // Function to position controls correctly
        function positionControls() {
            const controls = document.getElementById('processed-controls');
            const processedCanvas = document.getElementById('processed-canvas');
            if (controls && processedCanvas) {
                // Always ensure controls are visible
                controls.style.display = 'flex';
                controls.style.zIndex = '1000';
                
                const canvasRect = processedCanvas.getBoundingClientRect();
                const container = processedCanvas.parentElement;
                if (container && canvasRect.width > 0) {
                    // Canvas has dimensions, position relative to it
                    const containerRect = container.getBoundingClientRect();
                    const canvasRight = canvasRect.right - containerRect.left;
                    // Position buttons to the right of the canvas with small spacing
                    controls.style.left = canvasRight + 10 + 'px';
                    controls.style.top = '0px';
                } else {
                    // Canvas not yet rendered or empty, use fallback positioning
                    // Position relative to center of container
                    controls.style.left = 'calc(50% + 10px)';
                    controls.style.top = '0px';
                }
            }
        }

        function showEditorPanel() {
            document.getElementById('editor-panel').style.display = 'block';
            document.getElementById('canvas-container').style.display = 'none';
            // Reset viewer controls position when editor is shown
            updateViewerControlsPosition();
            // Ensure controls are positioned correctly when editor panel is shown
            setTimeout(() => {
                positionControls();
            }, 100);
            if (rawUploadedImage) {
                // Wait for panel to be visible before recalculating canvas size
                requestAnimationFrame(() => {
                    // Double-check panel is visible and has dimensions
                    const container = document.getElementById('editor-panel');
                    if (container && container.clientWidth > 0) {
                        // If we have painted image data, just redraw it instead of reprocessing
                        if (processedImageData && processedImageData.width === selectedGridSize && processedImageData.height === selectedGridSize) {
                            // Ensure canvas size is correct before redrawing
                            const processedCanvas = document.getElementById('processed-canvas');
                            if (processedCanvas) {
                                const containerWidth = Math.max(200, container.clientWidth - 88);
                                const reservedHeight = 80;
                                const availableHeight = window.innerHeight - reservedHeight;
                                const maxSize = Math.max(containerWidth, availableHeight * 0.95);
                                const side = Math.min(containerWidth * 0.98, availableHeight * 0.95, maxSize) + 100;
                                processedCanvas.width = side;
                                processedCanvas.height = side;
                            }
                            redrawProcessedCanvas();
                        } else {
                            // No painted data, process from scratch
                            processImage();
                        }
                    } else {
                        // Panel not ready yet, try again after a short delay
                        setTimeout(() => {
                            if (processedImageData && processedImageData.width === selectedGridSize && processedImageData.height === selectedGridSize) {
                                const processedCanvas = document.getElementById('processed-canvas');
                                if (processedCanvas) {
                                    const containerWidth = Math.max(200, container.clientWidth - 88);
                                    const reservedHeight = 80;
                                    const availableHeight = window.innerHeight - reservedHeight;
                                    const maxSize = Math.max(containerWidth, availableHeight * 0.95);
                                    const side = Math.min(containerWidth * 0.98, availableHeight * 0.95, maxSize) + 100;
                                    processedCanvas.width = side;
                                    processedCanvas.height = side;
                                }
                                redrawProcessedCanvas();
                            } else {
                                processImage();
                            }
                        }, 50);
                    }
                });
            }
        }

        function updateViewerControlsPosition() {
            const canvasContainer = document.getElementById('canvas-container');
            const viewerControls = document.querySelector('.viewer-controls');
            
            if (!canvasContainer || !viewerControls) return;
            
            // Only update if viewer is visible
            if (canvasContainer.style.display === 'none') {
                viewerControls.classList.remove('stopped');
                return;
            }
            
            const containerRect = canvasContainer.getBoundingClientRect();
            
            // If the bottom of the container has scrolled past the top of the viewport, hide the controls
            // Otherwise keep them visible at the top
            if (containerRect.bottom < 0) {
                viewerControls.classList.add('stopped');
            } else {
                viewerControls.classList.remove('stopped');
            }
        }

        function show3DView() {
            // Regenerate PNG with current crop settings before showing 3D view
            if (rawUploadedImage && currentMesh) {
                // Create processed image at current grid size with current crop
                createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                    pngFile = file;
                    pngImage = img;
                    // Apply colors to 3D mesh with cropped image
                    applyColorsToMesh();
                });
            }
            
            document.getElementById('editor-panel').style.display = 'none';
            document.getElementById('canvas-container').style.display = 'block';
            // Update controls position and setup scroll handler
            updateViewerControlsPosition();
            // Ensure Three.js canvas resizes correctly after becoming visible (wait a frame)
            requestAnimationFrame(() => {
                try {
                    const container = document.getElementById('canvas-container');
                    let w = container.clientWidth || container.offsetWidth;
                    let h = container.clientHeight || container.offsetHeight;
                    if (!w || !h) {
                        w = window.innerWidth;
                        h = window.innerHeight;
                    }
                    // Ensure renderer DOM is attached
                    if (renderer && container && renderer.domElement && renderer.domElement.parentNode !== container) {
                        container.appendChild(renderer.domElement);
                    }
                    if (renderer && camera) {
                        renderer.setSize(w, h, true);
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                    }
                    // Fit camera to current mesh if available
                    if (currentMesh) {
                        const box = new THREE.Box3().setFromObject(currentMesh);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z) || 100;
                        camera.position.set(maxDim, maxDim, maxDim);
                        controls.target.set(0, 0, 0);
                        controls.update();
                    }
                    // Render once immediately after resize
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                } catch (e) {
                    console.warn('Resize after showing 3D view failed:', e);
                }
            });
        }

        function processImage() {
            if (!rawUploadedImage) return;

            const processedCanvas = document.getElementById('processed-canvas');
            const processedCtx = processedCanvas.getContext('2d');

            // Set canvas sizes - make it as large as possible to fill the screen
            const container = document.getElementById('editor-panel');
            const containerWidth = Math.max(200, container.clientWidth - 88); // padding: 24px left + 40px right + some margin
            // Reserve minimal space for header and label only
            const reservedHeight = 80;
            const availableHeight = window.innerHeight - reservedHeight;
            // Use much larger max size to fill the screen - prioritize height
            const maxSize = Math.max(containerWidth, availableHeight * 0.95);
            const side = Math.min(containerWidth * 0.98, availableHeight * 0.95, maxSize) + 100;
            // Set canvas internal resolution (for rendering quality)
            processedCanvas.width = side;
            processedCanvas.height = side;
            // Let CSS control the display size for responsive scaling
            processedCanvas.style.width = '';
            processedCanvas.style.height = '';
            processedCanvas.style.maxWidth = '';
            
            // Position controls at top right, just outside the canvas
            setTimeout(() => {
                positionControls();
            }, 100);
            
            // Also ensure controls are visible on window resize
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    positionControls();
                }, 100);
            });

            // Process: Convert to grayscale with luminosity + posterize + pixelate
            const pixelSize = selectedGridSize;
            
            // Create temp canvas at target pixel size
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = pixelSize;
            tempCanvas.height = pixelSize;
            const tempCtx = tempCanvas.getContext('2d');
            
            // If crop coordinates exist, crop from the full original image first
            if (cropCoordinates && cropCoordinates.size > 0) {
                // Create cropped version from full original
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = cropCoordinates.size;
                cropCanvas.height = cropCoordinates.size;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(rawUploadedImage, cropCoordinates.x, cropCoordinates.y, cropCoordinates.size, cropCoordinates.size, 0, 0, cropCoordinates.size, cropCoordinates.size);
                
                // Draw cropped image at small size (pixelation effect)
                tempCtx.drawImage(cropCanvas, 0, 0, pixelSize, pixelSize);
            } else {
                // No crop - draw full image at small size (pixelation effect)
                // Crop to square first to prevent stretching - use centered crop
                const sourceSquareSize = Math.min(rawUploadedImage.width, rawUploadedImage.height);
                const offsetX = (rawUploadedImage.width - sourceSquareSize) / 2;
                const offsetY = (rawUploadedImage.height - sourceSquareSize) / 2;
                tempCtx.drawImage(rawUploadedImage, offsetX, offsetY, sourceSquareSize, sourceSquareSize, 0, 0, pixelSize, pixelSize);
            }
            
            // Get image data
            const imageData = tempCtx.getImageData(0, 0, pixelSize, pixelSize);
            const data = imageData.data;

            // Process each pixel: grayscale + percentile stretch + contrast/brightness + N-tone posterize
            for (let i = 0; i < data.length; i += 4) {
                // Convert to grayscale using luminosity method (perceputal brightness)
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                // Percentile stretch using black/white points
                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                // Apply contrast and brightness
                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                // Posterize to N tones based on brightness using base palette [0,85,170,255]
                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                // thresholds midpoints
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }

            tempCtx.putImageData(imageData, 0, 0);

            // Store the processed image data for pixel editing (at pixel size, not display size)
            const imageDataCopy = tempCtx.getImageData(0, 0, pixelSize, pixelSize);
            processedImageData = imageDataCopy;
            
            // Store a deep copy as the original (for reset functionality)
            originalProcessedImageData = new ImageData(
                new Uint8ClampedArray(imageDataCopy.data),
                imageDataCopy.width,
                imageDataCopy.height
            );

            // Draw pixelated result to processed canvas (scaled up)
            processedCtx.imageSmoothingEnabled = false;
            processedCtx.drawImage(tempCanvas, 0, 0, processedCanvas.width, processedCanvas.height);
            
            // Create a preview version at preview size for general use
            const previewCanvas = document.createElement('canvas');
            const previewMaxSize = 400;
            previewCanvas.width = previewMaxSize;
            previewCanvas.height = previewMaxSize;
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.imageSmoothingEnabled = false;
            previewCtx.drawImage(tempCanvas, 0, 0, previewMaxSize, previewMaxSize);
            const previewDataURL = previewCanvas.toDataURL();
            
            // IMPORTANT: Only store the full processed preview if cropper is NOT visible
            // Once cropper is visible, this snapshot is FROZEN and must never change
            // This is exclusively for the cropper preview - completely separate from editor updates
            if (!cropperVisible) {
                // Only update when cropper is not visible - this way it captures the full image before cropping
                fullProcessedImageDataURL = previewDataURL;
            }
            // If cropper IS visible, DO NOT overwrite fullProcessedImageDataURL - keep it frozen
            
            // Update preview image to show same processed result (scaled up to match preview size)
            // BUT NEVER update if cropper is visible/fixed - the cropper preview must stay unchanged
            // IMPORTANT: Check cropperVisible FIRST to prevent any updates while cropping
            const previewImg = document.getElementById('png-preview-img');
            const isCropperFixed = previewImg && previewImg.getAttribute('data-cropper-fixed') === 'true';
            // Only update if cropper is NOT visible AND preview is NOT fixed
            if (previewImg && rawUploadedImage && !cropperVisible && !isCropperFixed) {
                previewImg.src = previewDataURL;
            }
            // If cropper is visible, NEVER update the preview - it must stay frozen
            
            // Re-attach paint handlers after processing
            setTimeout(() => {
                setupPaintHandlers();
            }, 100);
        }

        function applyPhotoEdits() {
            // FUNCTION DISABLED - DO NOTHING
            return;
            // Create the processed image at the selected pixel size
            const pixelSize = selectedGridSize; // Use selectedGridSize
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = pixelSize;
            finalCanvas.height = pixelSize;
            const finalCtx = finalCanvas.getContext('2d');

            // Use painted image data if available, otherwise process from scratch
            let imageData;
            if (processedImageData && processedImageData.width === pixelSize && processedImageData.height === pixelSize) {
                // Use the painted image data (preserve paintings)
                imageData = new ImageData(
                    new Uint8ClampedArray(processedImageData.data),
                    processedImageData.width,
                    processedImageData.height
                );
            } else {
                // Draw and process from original
                finalCtx.drawImage(rawUploadedImage, 0, 0, pixelSize, pixelSize);
                imageData = finalCtx.getImageData(0, 0, pixelSize, pixelSize);
                const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const bp = editorSettings.blackPoint ?? 0;
                const wp = editorSettings.whitePoint ?? 255;
                gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                gray = gray * editorSettings.brightness;
                gray = Math.max(0, Math.min(255, gray));

                const base = [0,85,170,255];
                const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                const indices = [];
                for (let k = 0; k < n; k++) {
                    const idx = Math.round((k*(base.length-1))/(n-1));
                    indices.push(base[idx]);
                }
                let finalColor = indices[indices.length-1];
                for (let t = 0; t < indices.length-1; t++) {
                    const mid = (indices[t] + indices[t+1]) / 2;
                    if (gray < mid) { finalColor = indices[t]; break; }
                }

                data[i] = finalColor;
                data[i + 1] = finalColor;
                data[i + 2] = finalColor;
            }
            
                // Store for future editing
                processedImageData = imageData;
                
                // Store a deep copy as the original (for reset functionality)
                originalProcessedImageData = new ImageData(
                    new Uint8ClampedArray(imageData.data),
                    imageData.width,
                    imageData.height
                );
            }

            finalCtx.putImageData(imageData, 0, 0);

            // Convert to image and use as PNG
            finalCanvas.toBlob((blob) => {
                const processedFile = new File([blob], 'processed.png', { type: 'image/png' });
                pngFile = processedFile;

                const img = new Image();
                img.onload = () => {
                    pngImage = img;
                    // Don't set preview here - it's already set to processed version in processImage()
                    // document.getElementById('png-preview-img').src = img.src;
                    // Show crop buttons when image is processed
                    document.getElementById('crop-buttons').style.display = 'block';
                    // Don't show preview automatically - only show when "Show Cropper" is clicked
                    // document.getElementById('png-preview').style.display = 'block';
                    document.getElementById('png-upload-area').classList.add('has-file');
                    document.getElementById('png-upload-text').textContent = 'Processed image';

                    // Apply colors to 3D mesh if STL is loaded
                    if (currentMesh) {
                        applyColorsToMesh();
                    }
                    // Automatically switch to 3D view after applying
                    show3DView();
                };
                img.src = URL.createObjectURL(blob);

                // Persist processed PNG for current grid size
                saveFileToDB(dbKey('png'), processedFile);
            }, 'image/png');
        }

        // Crop Functions - Simple cropper with blue dotted line
        function showCropper() {
            console.log('Show cropper clicked');
            
            const previewImg = document.getElementById('png-preview-img');
            const cropCanvas = document.getElementById('crop-canvas');
            const container = document.getElementById('crop-container');
            
            if (!previewImg || !cropCanvas || !container) {
                console.error('Cropper elements not found');
                return;
            }
            
            // User is manually showing the cropper, so clear the manually hidden flag
            cropperManuallyHidden = false;
            
            // Make sure preview image is visible
            document.getElementById('png-preview').style.display = 'block';
            
            // Show the original image in the cropper instead of processed image
            if (rawUploadedImage) {
                // Create a snapshot from the original uploaded image
                const snapshotCanvas = document.createElement('canvas');
                snapshotCanvas.width = 350;
                snapshotCanvas.height = 350;
                const snapshotCtx = snapshotCanvas.getContext('2d');
                snapshotCtx.imageSmoothingEnabled = true; // Use smoothing for original image
                
                // Draw the original image to create the snapshot
                const tempImg = new Image();
                tempImg.onload = () => {
                    // Calculate aspect ratio to maintain proportions
                    const imgAspect = tempImg.width / tempImg.height;
                    let drawWidth = 350;
                    let drawHeight = 350;
                    let offsetX = 0;
                    let offsetY = 0;
                    
                    if (imgAspect > 1) {
                        // Image is wider than tall
                        drawHeight = 350 / imgAspect;
                        offsetY = (350 - drawHeight) / 2;
                    } else {
                        // Image is taller than wide
                        drawWidth = 350 * imgAspect;
                        offsetX = (350 - drawWidth) / 2;
                    }
                    
                    snapshotCtx.drawImage(tempImg, offsetX, offsetY, drawWidth, drawHeight);
                    const snapshotDataURL = snapshotCanvas.toDataURL();
                    previewImg.src = snapshotDataURL;
                    previewImg.setAttribute('data-cropper-fixed', 'true');
                    
                    // Wait for image to load if needed
                    if (previewImg.complete && previewImg.naturalWidth > 0) {
                        setTimeout(initCropper, 50);
                    } else {
                        previewImg.onload = function() {
                            setTimeout(initCropper, 50);
                        };
                        if (previewImg.src) {
                            previewImg.load();
                        }
                    }
                };
                tempImg.src = rawUploadedImage.src;
                return; // Exit early, will continue after image loads
            } else {
                alert('Please upload an image first');
                return;
            }
            
            function initCropper() {
                // Reset zoom/pan when showing cropper
                cropperZoom = 1.0;
                cropperPanX = 0;
                cropperPanY = 0;
                updateCropperTransform();
                
                // Use smaller fixed size and center it
                const container = document.getElementById('crop-container');
                let imgDisplayWidth = 350;
                let imgDisplayHeight = 350;
                
                // Update image and container to use the size
                if (previewImg) {
                    previewImg.style.width = imgDisplayWidth + 'px';
                    previewImg.style.height = imgDisplayHeight + 'px';
                    previewImg.style.maxWidth = imgDisplayWidth + 'px';
                    previewImg.style.maxHeight = imgDisplayHeight + 'px';
                }
                if (container) {
                    container.style.maxWidth = imgDisplayWidth + 'px';
                }
                
                // Set canvas display size to match calculated image size
                cropCanvas.style.width = imgDisplayWidth + 'px';
                cropCanvas.style.height = imgDisplayHeight + 'px';
                cropCanvas.style.left = '0px';
                cropCanvas.style.top = '0px';
                cropCanvas.style.display = 'block';
                cropCanvas.style.pointerEvents = 'auto';
                cropCanvas.style.cursor = 'move';
                cropCanvas.style.zIndex = '10';
                
                // Set canvas internal resolution (device pixel ratio for crisp lines)
                const dpr = window.devicePixelRatio || 1;
                cropCanvas.width = imgDisplayWidth * dpr;
                cropCanvas.height = imgDisplayHeight * dpr;
                
                // Initialize crop area - ONLY if never initialized before (preserve position forever after first use)
                if (!cropInitialized) {
                    // First time - center it, 80% of image size, snapped to grid
                    const gridSize = selectedGridSize;
                    const cellSize = imgDisplayWidth / gridSize;
                    
                    let initialSize = Math.min(imgDisplayWidth, imgDisplayHeight) * 0.8;
                    const numCells = Math.round(initialSize / cellSize);
                    cropSize = Math.max(1, numCells) * cellSize;
                    
                    // Precise center calculation with snapping
                    const centerX = (imgDisplayWidth - cropSize) / 2;
                    const centerY = (imgDisplayHeight - cropSize) / 2;
                    const centerCellX = Math.round(centerX / cellSize);
                    const centerCellY = Math.round(centerY / cellSize);
                    cropX = centerCellX * cellSize;
                    cropY = centerCellY * cellSize;
                    
                    // Ensure crop box stays within image bounds
                    cropX = Math.max(0, Math.min(cropX, imgDisplayWidth - cropSize));
                    cropY = Math.max(0, Math.min(cropY, imgDisplayHeight - cropSize));
                    
                    cropInitialized = true; // Mark as initialized - never reset again
                }
                // If crop position already exists, keep it exactly where it is (don't reset to center)
                
                cropperVisible = true;
                document.getElementById('show-cropper-btn').style.display = 'none';
                document.getElementById('hide-cropper-btn').style.display = 'block';
                // Show the preview image
                document.getElementById('png-preview').style.display = 'block';
                
                drawCropBox();
            }
        }
        
        function drawCropBox() {
            if (!cropperVisible) return;
            
            const cropCanvas = document.getElementById('crop-canvas');
            if (!cropCanvas) return;
            
            // Get actual image display dimensions from the preview image
            const previewImg = document.getElementById('png-preview-img');
            let imgDisplayWidth = 400;
            let imgDisplayHeight = 400;
            
            if (previewImg) {
                // Get the actual displayed size of the image
                const rect = previewImg.getBoundingClientRect();
                imgDisplayWidth = rect.width || 400;
                imgDisplayHeight = rect.height || 400;
            }
            
            const ctx = cropCanvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            // Clear canvas completely
            ctx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            
            // Reset transform to identity first
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Scale to device pixel ratio for crisp rendering
            ctx.scale(dpr, dpr);
            
            // Draw blue dotted square border
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3; // Make it slightly thicker to be more visible
            ctx.setLineDash([8, 4]); // Dash pattern: 8px dash, 4px gap
            ctx.lineDashOffset = 0;
            
            // Ensure crop coordinates are within bounds
            const maxX = Math.min(cropX + cropSize, imgDisplayWidth);
            const maxY = Math.min(cropY + cropSize, imgDisplayHeight);
            const clampedX = Math.max(0, Math.min(cropX, imgDisplayWidth));
            const clampedY = Math.max(0, Math.min(cropY, imgDisplayHeight));
            const clampedSizeX = Math.max(1, maxX - clampedX);
            const clampedSizeY = Math.max(1, maxY - clampedY);
            
            // Draw the rectangle
            ctx.beginPath();
            ctx.rect(clampedX, clampedY, clampedSizeX, clampedSizeY);
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            console.log('Drew crop box at:', clampedX, clampedY, clampedSizeX, clampedSizeY);
        }
        
        // Make the canvas interactive
        document.getElementById('crop-canvas').addEventListener('mousedown', (e) => {
            if (!cropperVisible) return;
            
            const cropCanvas = document.getElementById('crop-canvas');
            const rect = cropCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Check if clicking on edge (for resize) or center (for drag)
            const edgeThreshold = 15;
            const onLeftEdge = Math.abs(mouseX - cropX) < edgeThreshold;
            const onRightEdge = Math.abs(mouseX - (cropX + cropSize)) < edgeThreshold;
            const onTopEdge = Math.abs(mouseY - cropY) < edgeThreshold;
            const onBottomEdge = Math.abs(mouseY - (cropY + cropSize)) < edgeThreshold;
            
            // Check corners first
            const onTopLeft = onTopEdge && onLeftEdge;
            const onTopRight = onTopEdge && onRightEdge;
            const onBottomLeft = onBottomEdge && onLeftEdge;
            const onBottomRight = onBottomEdge && onRightEdge;
            
            if (onTopLeft || onTopRight || onBottomLeft || onBottomRight) {
                // Resize from corner
                isResizingCrop = true;
                if (onTopLeft) resizeEdge = 'topleft';
                else if (onTopRight) resizeEdge = 'topright';
                else if (onBottomLeft) resizeEdge = 'bottomleft';
                else if (onBottomRight) resizeEdge = 'bottomright';
                cropStartX = cropX;
                cropStartY = cropY;
                cropStartSize = cropSize;
                dragStartX = mouseX;
                dragStartY = mouseY;
                cropCanvas.style.cursor = 'nwse-resize';
            } else if (onLeftEdge || onRightEdge || onTopEdge || onBottomEdge) {
                // Resize from edge
                isResizingCrop = true;
                if (onLeftEdge) resizeEdge = 'left';
                else if (onRightEdge) resizeEdge = 'right';
                else if (onTopEdge) resizeEdge = 'top';
                else if (onBottomEdge) resizeEdge = 'bottom';
                cropStartX = cropX;
                cropStartY = cropY;
                cropStartSize = cropSize;
                dragStartX = mouseX;
                dragStartY = mouseY;
                cropCanvas.style.cursor = onLeftEdge || onRightEdge ? 'ew-resize' : 'ns-resize';
            } else if (isPanningCropper) {
                // Start panning
                panStartX = mouseX;
                panStartY = mouseY;
            } else if (mouseX >= cropX && mouseX <= cropX + cropSize &&
                      mouseY >= cropY && mouseY <= cropY + cropSize) {
                // Drag from center (only if not panning)
                isDraggingCrop = true;
                dragStartX = mouseX - cropX * cropperZoom;
                dragStartY = mouseY - cropY * cropperZoom;
                cropCanvas.style.cursor = 'move';
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!cropperVisible && !isDraggingCrop && !isResizingCrop && !isPanningCropper) return;
            
            const cropCanvas = document.getElementById('crop-canvas');
            const rect = cropCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (isPanningCropper) {
                // Pan the cropper view
                const deltaX = mouseX - panStartX;
                const deltaY = mouseY - panStartY;
                cropperPanX += deltaX;
                cropperPanY += deltaY;
                panStartX = mouseX;
                panStartY = mouseY;
                updateCropperTransform();
            } else if (isDraggingCrop) {
                // Move crop box - need to convert mouse coordinates to image coordinates
                // Account for zoom/pan transform
                const cropCanvas = document.getElementById('crop-canvas');
                const rect = cropCanvas.getBoundingClientRect();
                const canvasMouseX = (e.clientX - rect.left) / cropperZoom - cropperPanX / cropperZoom;
                const canvasMouseY = (e.clientY - rect.top) / cropperZoom - cropperPanY / cropperZoom;
                
                let newX = canvasMouseX - dragStartX;
                let newY = canvasMouseY - dragStartY;
                
                // Get actual image display dimensions
                const previewImg = document.getElementById('png-preview-img');
                let imgWidth = 400;
                let imgHeight = 400;
                if (previewImg) {
                    const rect = previewImg.getBoundingClientRect();
                    imgWidth = rect.width || 400;
                    imgHeight = rect.height || 400;
                }
                
                newX = Math.max(0, Math.min(newX, imgWidth - cropSize));
                newY = Math.max(0, Math.min(newY, imgHeight - cropSize));
                
                // Snap to pixel grid
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize;
                
                // Snap position to grid cell boundaries
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                cropX = cellX * cellSize;
                cropY = cellY * cellSize;
                
                // Ensure it stays within bounds
                const maxCellX = Math.floor((imgWidth - cropSize) / cellSize);
                const maxCellY = Math.floor((imgHeight - cropSize) / cellSize);
                cropX = Math.max(0, Math.min(cropX, maxCellX * cellSize));
                cropY = Math.max(0, Math.min(cropY, maxCellY * cellSize));
                
                // Ensure final bounds check
                cropX = Math.max(0, Math.min(cropX, imgWidth - cropSize));
                cropY = Math.max(0, Math.min(cropY, imgHeight - cropSize));
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you drag (like the reference)
                applyCropFromBox(true);
            } else if (isResizingCrop) {
                // Resize crop box (keep square) based on which edge/corner
                // Get actual image display dimensions
                const previewImg = document.getElementById('png-preview-img');
                let imgWidth = 400;
                let imgHeight = 400;
                if (previewImg) {
                    const rect = previewImg.getBoundingClientRect();
                    imgWidth = rect.width || 400;
                    imgHeight = rect.height || 400;
                }
                const gridSize = selectedGridSize;
                const cellSize = imgWidth / gridSize; // Each cell size in screen pixels
                
                // Calculate resize direction - fix inverted logic
                let deltaX = mouseX - dragStartX;
                let deltaY = mouseY - dragStartY;
                
                // For corners, use the dominant direction
                let delta = 0;
                if (resizeEdge.includes('left') && resizeEdge.includes('top')) {
                    // Top-left: dragging right/down = larger, left/up = smaller
                    delta = Math.max(-deltaX, -deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('top')) {
                    // Top-right: dragging right/down = larger, left/up = smaller
                    delta = Math.max(deltaX, -deltaY);
                } else if (resizeEdge.includes('left') && resizeEdge.includes('bottom')) {
                    // Bottom-left: dragging right/down = larger, left/up = smaller
                    delta = Math.max(-deltaX, deltaY);
                } else if (resizeEdge.includes('right') && resizeEdge.includes('bottom')) {
                    // Bottom-right: dragging right/down = larger, left/up = smaller
                    delta = Math.max(deltaX, deltaY);
                } else if (resizeEdge === 'left') {
                    // Left edge: dragging right = larger, left = smaller
                    delta = -deltaX;
                } else if (resizeEdge === 'right') {
                    // Right edge: dragging right = larger, left = smaller
                    delta = deltaX;
                } else if (resizeEdge === 'top') {
                    // Top edge: dragging down = larger, up = smaller
                    delta = -deltaY;
                } else if (resizeEdge === 'bottom') {
                    // Bottom edge: dragging down = larger, up = smaller
                    delta = deltaY;
                }
                
                // Calculate new size (delta > 0 means larger, delta < 0 means smaller)
                let newSize = cropStartSize + delta;
                
                // Constrain size
                newSize = Math.max(cellSize, Math.min(newSize, imgWidth, imgHeight));
                
                // Snap size to grid cells (must be multiple of cellSize) - use precise calculation
                const numCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, numCells) * cellSize;
                
                // Calculate new position based on which edge is being resized
                let newX = cropStartX;
                let newY = cropStartY;
                
                if (resizeEdge.includes('left')) {
                    newX = cropStartX + cropStartSize - newSize;
                    newX = Math.max(0, Math.min(newX, imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    newY = cropStartY + cropStartSize - newSize;
                    newY = Math.max(0, Math.min(newY, imgHeight - newSize));
                }
                if (resizeEdge.includes('right')) {
                    newX = cropStartX;
                }
                if (resizeEdge.includes('bottom')) {
                    newY = cropStartY;
                }
                
                // Snap position to grid with better precision
                const cellX = Math.round(newX / cellSize);
                const cellY = Math.round(newY / cellSize);
                newX = cellX * cellSize;
                newY = cellY * cellSize;
                
                // Adjust size if needed after snapping position - with precise snapping
                if (resizeEdge.includes('left')) {
                    const actualX = Math.max(0, Math.min(newX, imgWidth - newSize));
                    let adjustedSize = cropStartX + cropStartSize - actualX;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedX = cropStartX + cropStartSize - adjustedSize;
                    const cellX2 = Math.round(adjustedX / cellSize);
                    newX = cellX2 * cellSize;
                    newSize = cropStartX + cropStartSize - newX;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newX = cropStartX + cropStartSize - newSize;
                    const cellX3 = Math.round(newX / cellSize);
                    newX = Math.max(0, Math.min(cellX3 * cellSize, imgWidth - newSize));
                }
                if (resizeEdge.includes('top')) {
                    const actualY = Math.max(0, Math.min(newY, imgHeight - newSize));
                    let adjustedSize = cropStartY + cropStartSize - actualY;
                    const numCells2 = Math.round(adjustedSize / cellSize);
                    adjustedSize = Math.max(1, numCells2) * cellSize;
                    const adjustedY = cropStartY + cropStartSize - adjustedSize;
                    const cellY2 = Math.round(adjustedY / cellSize);
                    newY = cellY2 * cellSize;
                    newSize = cropStartY + cropStartSize - newY;
                    const numCells3 = Math.round(newSize / cellSize);
                    newSize = Math.max(1, numCells3) * cellSize;
                    newY = cropStartY + cropStartSize - newSize;
                    const cellY3 = Math.round(newY / cellSize);
                    newY = Math.max(0, Math.min(cellY3 * cellSize, imgHeight - newSize));
                }
                
                // Final constraints with precise snapping
                newSize = Math.max(cellSize, Math.min(newSize, imgWidth - newX, imgHeight - newY));
                const finalNumCells = Math.round(newSize / cellSize);
                newSize = Math.max(1, finalNumCells) * cellSize;
                
                // Final position snap
                const finalCellX = Math.round(newX / cellSize);
                const finalCellY = Math.round(newY / cellSize);
                cropX = Math.max(0, Math.min(finalCellX * cellSize, imgWidth - newSize));
                cropY = Math.max(0, Math.min(finalCellY * cellSize, imgHeight - newSize));
                cropSize = newSize;
                
                // Update the crop box visual position
                drawCropBox();
                
                // Update editor section in real-time as you resize (like the reference)
                applyCropFromBox(true);
            } else if (cropperVisible) {
                // Update cursor when hovering
                const edgeThreshold = 15;
                const onLeftEdge = Math.abs(mouseX - cropX) < edgeThreshold;
                const onRightEdge = Math.abs(mouseX - (cropX + cropSize)) < edgeThreshold;
                const onTopEdge = Math.abs(mouseY - cropY) < edgeThreshold;
                const onBottomEdge = Math.abs(mouseY - (cropY + cropSize)) < edgeThreshold;
                
                if ((onTopEdge && onLeftEdge) || (onBottomEdge && onRightEdge)) {
                    cropCanvas.style.cursor = 'nwse-resize';
                } else if ((onTopEdge && onRightEdge) || (onBottomEdge && onLeftEdge)) {
                    cropCanvas.style.cursor = 'nesw-resize';
                } else if (onLeftEdge || onRightEdge) {
                    cropCanvas.style.cursor = 'ew-resize';
                } else if (onTopEdge || onBottomEdge) {
                    cropCanvas.style.cursor = 'ns-resize';
                } else if (mouseX >= cropX && mouseX <= cropX + cropSize &&
                          mouseY >= cropY && mouseY <= cropY + cropSize) {
                    cropCanvas.style.cursor = 'move';
                } else {
                    cropCanvas.style.cursor = 'default';
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDraggingCrop || isResizingCrop) {
                // Redraw crop box
                drawCropBox();
                // Auto-apply crop when done dragging/resizing to update editor section
                setTimeout(() => {
                    applyCropFromBox(true);
                }, 50);
            }
            isDraggingCrop = false;
            isResizingCrop = false;
            isPanningCropper = false;
            resizeEdge = '';
            const cropCanvas = document.getElementById('crop-canvas');
            if (cropCanvas) {
                cropCanvas.style.cursor = isPanningCropper ? 'grab' : 'move';
            }
        });
        
        // Hide cropper and image preview
        function hideCropper() {
            // Just hide the cropper, don't apply any changes
            cropperVisible = false;
            cropperManuallyHidden = true; // Mark that user manually hid it
            isPanningCropper = false;
            document.getElementById('crop-canvas').style.display = 'none';
            document.getElementById('show-cropper-btn').style.display = 'block';
            document.getElementById('hide-cropper-btn').style.display = 'none';
            // Hide the entire preview section
            document.getElementById('png-preview').style.display = 'none';
        }
        
        // Cropper zoom/pan functions
        function cropperZoomIn() {
            cropperZoom = Math.min(cropperZoom * 1.5, 5.0);
            updateCropperTransform();
        }
        
        function cropperZoomOut() {
            cropperZoom = Math.max(cropperZoom / 1.5, 0.5);
            updateCropperTransform();
        }
        
        function cropperResetView() {
            cropperZoom = 1.0;
            cropperPanX = 0;
            cropperPanY = 0;
            updateCropperTransform();
        }
        
        function cropperTogglePan() {
            const btn = document.getElementById('cropper-pan-btn');
            const cropCanvas = document.getElementById('crop-canvas');
            if (isPanningCropper) {
                isPanningCropper = false;
                btn.style.background = 'white';
                if (cropCanvas) cropCanvas.style.cursor = 'move';
            } else {
                isPanningCropper = true;
                btn.style.background = '#e0e0e0';
                if (cropCanvas) cropCanvas.style.cursor = 'grab';
            }
        }
        
        function updateCropperTransform() {
            const previewImg = document.getElementById('png-preview-img');
            if (previewImg) {
                const transform = `translate(${cropperPanX}px, ${cropperPanY}px) scale(${cropperZoom})`;
                previewImg.style.transform = transform;
                
                // Also update crop canvas to match
                const cropCanvas = document.getElementById('crop-canvas');
                if (cropCanvas) {
                    cropCanvas.style.transform = transform;
                }
                
                // Redraw crop box with new transform
                drawCropBox();
            }
        }
        
        function applyCropFromBox(skipVisibilityCheck = false) {
            // Only proceed if we have the full original image
            if (!fullOriginalImage) {
                // If no fullOriginalImage but we have rawUploadedImage, use that
                if (!rawUploadedImage || (!cropperVisible && !skipVisibilityCheck)) return;
            } else if (!cropperVisible && !skipVisibilityCheck) {
                return;
            }
            
            // IMPORTANT: While cropper is visible, we need to use the stored full processed image dimensions
            // NOT the cropper preview image dimensions (which might change)
            const previewImg = document.getElementById('png-preview-img');
            if (!previewImg) return;
            
            // Use fullOriginalImage if available, otherwise fall back to rawUploadedImage
            const sourceImage = fullOriginalImage || rawUploadedImage;
            
            // If cropper is visible, use fixed dimensions based on fullProcessedImageDataURL
            // This prevents any changes to the cropper preview image
            let imgDisplayWidth, imgDisplayHeight;
            if (cropperVisible && fullProcessedImageDataURL) {
                // Use fixed dimensions - preview is always 400px max with aspect ratio 1:1
                imgDisplayWidth = 400;
                imgDisplayHeight = 400;
            } else {
                // Normal case: get dimensions from preview image
                const imgRect = previewImg.getBoundingClientRect();
                if (imgRect.width === 0 || imgRect.height === 0) return;
                imgDisplayWidth = imgRect.width;
                imgDisplayHeight = imgRect.height;
            }
            
            // Calculate scale from preview display size to actual image size
            const scale = sourceImage.width / imgDisplayWidth;
            
            // Check if crop covers the entire displayed image (within a small threshold)
            // Check in displayed coordinates first, before converting to source coordinates
            const threshold = 10; // pixels tolerance in displayed coordinates
            const coversFullWidth = Math.abs(cropX) < threshold && Math.abs(cropX + cropSize - imgDisplayWidth) < threshold;
            const coversFullHeight = Math.abs(cropY) < threshold && Math.abs(cropY + cropSize - imgDisplayHeight) < threshold;
            const isFullSize = Math.abs(cropSize - imgDisplayWidth) < threshold && Math.abs(cropSize - imgDisplayHeight) < threshold;
            
            // If crop covers the full displayed image, reset crop coordinates to null (no crop)
            if (coversFullWidth && coversFullHeight && isFullSize) {
                cropCoordinates = null;
            } else {
                // Calculate actual pixel coordinates in the full original image
                const x = cropX * scale;
                const y = cropY * scale;
                const size = cropSize * scale;
                
                // Snap to grid cells
                const gridSize = selectedGridSize;
                const cellSize = size / gridSize;
                const snappedSize = Math.floor(size / cellSize) * cellSize;
                
                // Ensure we have valid crop dimensions
                if (snappedSize <= 0 || x < 0 || y < 0 || x + snappedSize > sourceImage.width || y + snappedSize > sourceImage.height) {
                    return;
                }
                
                // Store crop coordinates for use in processImage
                // DO NOT modify rawUploadedImage - keep it as the full original always
                cropCoordinates = { x, y, size: snappedSize };
            }
            
            // IMPORTANT: Prevent fullProcessedImageDataURL from being overwritten during cropping
            const savedFullProcessedImageDataURL = fullProcessedImageDataURL;
            
            // Process image with current crop settings
            processImage();
            
            // Restore fullProcessedImageDataURL after processing
            fullProcessedImageDataURL = savedFullProcessedImageDataURL;
            
            // Update preview image if needed (but don't modify rawUploadedImage)
            const img = new Image();
            img.onload = () => {
                // Don't update rawUploadedImage - keep it as full original
                // rawUploadedImage stays as the full original image
                
                // Keep the full original image visible (don't update it)
                // Only update the processed/preview versions with the cropped image
                // Original image canvas removed - no longer needed
                
                // Only update if we haven't shown the full original yet
                if (!fullOriginalImage) {
                    // Show the full original image
                    if (fullOriginalImage) {
                        const editorCanvas = document.getElementById('processed-canvas');
                        if (editorCanvas) {
                            const canvasSize = editorCanvas.width || 400;
                            const displayCanvas = document.createElement('canvas');
                            displayCanvas.width = canvasSize;
                            displayCanvas.height = canvasSize;
                            const displayCtx = displayCanvas.getContext('2d');
                            
                            // Draw full original image fitting to canvas
                            const aspect = fullOriginalImage.width / fullOriginalImage.height;
                            let drawWidth = canvasSize;
                            let drawHeight = canvasSize;
                            let offsetX = 0;
                            let offsetY = 0;
                            
                            if (aspect > 1) {
                                drawHeight = canvasSize / aspect;
                                offsetY = (canvasSize - drawHeight) / 2;
                            } else {
                                drawWidth = canvasSize * aspect;
                                offsetX = (canvasSize - drawWidth) / 2;
                            }
                            
                            displayCtx.drawImage(fullOriginalImage, offsetX, offsetY, drawWidth, drawHeight);
                            originalImg.src = displayCanvas.toDataURL();
                            originalImg.style.display = 'block';
                            placeholder.style.display = 'none';
                        } else {
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = fullOriginalImage.width;
                            tempCanvas.height = fullOriginalImage.height;
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCtx.drawImage(fullOriginalImage, 0, 0);
                            originalImg.src = tempCanvas.toDataURL();
                            originalImg.style.display = 'block';
                            placeholder.style.display = 'none';
                        }
                    }
                }
                
                // IMPORTANT: Do NOT update the cropper preview image here!
                // The cropper preview should always stay showing the FULL processed image at fixed size
                // Only the editor panel (processed-canvas) will show the cropped/zoomed version
                
                // IMPORTANT: Prevent fullProcessedImageDataURL from being overwritten during cropping
                // Save it temporarily and restore it after processing
                const savedFullProcessedImageDataURL = fullProcessedImageDataURL;
                
                // Reprocess image with cropped version - this will update processed view in editor only
                processImage();
                
                // Restore the frozen cropper preview snapshot - it must NEVER change
                fullProcessedImageDataURL = savedFullProcessedImageDataURL;
                // Also update the processed canvas in the left editor
                const processedCanvas = document.getElementById('processed-canvas');
                if (processedCanvas) {
                    const ctx = processedCanvas.getContext('2d');
                    // Draw the cropped image processed at the selected grid size
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = selectedGridSize;
                    tempCanvas.height = selectedGridSize;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0, selectedGridSize, selectedGridSize);
                    
                    // Apply same processing as processImage
                    const imageData = tempCtx.getImageData(0, 0, selectedGridSize, selectedGridSize);
                    const data = imageData.data;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        let gray = 0.299 * r + 0.587 * g + 0.114 * b;

                        const bp = editorSettings.blackPoint ?? 0;
                        const wp = editorSettings.whitePoint ?? 255;
                        gray = (gray - bp) * 255 / Math.max(1, (wp - bp));

                        gray = ((gray / 255 - 0.5) * editorSettings.contrast + 0.5) * 255;
                        gray = gray * editorSettings.brightness;
                        gray = Math.max(0, Math.min(255, gray));

                        const base = [0,85,170,255];
                        const n = Math.max(2, Math.min(4, editorSettings.tones|0));
                        const indices = [];
                        for (let k = 0; k < n; k++) {
                            const idx = Math.round((k*(base.length-1))/(n-1));
                            indices.push(base[idx]);
                        }
                        let finalColor = indices[indices.length-1];
                        for (let t = 0; t < indices.length-1; t++) {
                            const mid = (indices[t] + indices[t+1]) / 2;
                            if (gray < mid) { finalColor = indices[t]; break; }
                        }

                        data[i] = finalColor;
                        data[i + 1] = finalColor;
                        data[i + 2] = finalColor;
                    }
                    
                    tempCtx.putImageData(imageData, 0, 0);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(tempCanvas, 0, 0, processedCanvas.width, processedCanvas.height);
                }
                // Redraw crop box with new image
                setTimeout(() => {
                    if (cropperVisible) {
                        showCropper(); // Reinitialize cropper
                    }
                }, 100);
            };
            img.src = newCanvas.toDataURL();
        }

        // Paint Functions
        function selectPaintColor(r, g, b, element) {
            selectedPaintColor = { r, g, b };
            // Update selected state
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.classList.remove('selected');
            });
            element.classList.add('selected');
            console.log('Selected paint color:', selectedPaintColor);
        }

        function zoomInProcessed() {
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const panBtn = document.getElementById('processed-pan-btn');
            
            if (zoomMode === 'zoom-in') {
                // Deactivate zoom in mode
                zoomMode = null;
                if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
                if (zoomInBtn) zoomInBtn.style.background = 'white';
            } else {
                // Activate zoom in mode
                zoomMode = 'zoom-in';
                isPanningProcessed = false;
                if (processedCanvas) processedCanvas.style.cursor = 'zoom-in';
                if (zoomInBtn) zoomInBtn.style.background = '#e0e0e0';
                if (zoomOutBtn) zoomOutBtn.style.background = 'white';
                if (panBtn) panBtn.style.background = 'white';
            }
        }

        function zoomOutProcessed() {
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const panBtn = document.getElementById('processed-pan-btn');
            
            if (zoomMode === 'zoom-out') {
                // Deactivate zoom out mode
                zoomMode = null;
                if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
                if (zoomOutBtn) zoomOutBtn.style.background = 'white';
            } else {
                // Activate zoom out mode
                zoomMode = 'zoom-out';
                isPanningProcessed = false;
                if (processedCanvas) processedCanvas.style.cursor = 'zoom-out';
                if (zoomOutBtn) zoomOutBtn.style.background = '#e0e0e0';
                if (zoomInBtn) zoomInBtn.style.background = 'white';
                if (panBtn) panBtn.style.background = 'white';
            }
        }

        function resetZoomProcessed() {
            processedZoom = 1.0;
            processedZoomOffsetX = 0;
            processedZoomOffsetY = 0;
            zoomMode = null;
            isPanningProcessed = false;
            
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const panBtn = document.getElementById('processed-pan-btn');
            
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            if (zoomInBtn) zoomInBtn.style.background = 'white';
            if (zoomOutBtn) zoomOutBtn.style.background = 'white';
            if (panBtn) panBtn.style.background = 'white';
            
            redrawProcessedCanvas();
        }
        
        function togglePanProcessed() {
            const btn = document.getElementById('processed-pan-btn');
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            
            if (isPanningProcessed) {
                isPanningProcessed = false;
                zoomMode = null;
                btn.style.background = 'white';
                if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            } else {
                isPanningProcessed = true;
                zoomMode = null;
                btn.style.background = '#e0e0e0';
                if (processedCanvas) processedCanvas.style.cursor = 'move'; // Use 'move' cursor for panning
                if (zoomInBtn) zoomInBtn.style.background = 'white';
                if (zoomOutBtn) zoomOutBtn.style.background = 'white';
            }
        }
        
        // Function to deactivate all zoom/pan modes
        function deactivateZoomPanModes() {
            zoomMode = null;
            isPanningProcessed = false;
            
            const processedCanvas = document.getElementById('processed-canvas');
            const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
            const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
            const panBtn = document.getElementById('processed-pan-btn');
            
            if (processedCanvas) processedCanvas.style.cursor = 'crosshair';
            if (zoomInBtn) zoomInBtn.style.background = 'white';
            if (zoomOutBtn) zoomOutBtn.style.background = 'white';
            if (panBtn) panBtn.style.background = 'white';
        }
        
        function zoomToPoint(x, y, zoomFactor) {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            const rect = processedCanvas.getBoundingClientRect();
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            
            // Convert click position to canvas coordinates (absolute, not relative to center)
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            
            // Calculate the point in image space that corresponds to this canvas click
            // In redrawProcessedCanvas, transforms are:
            // 1. translate(w/2, h/2) - center
            // 2. translate(offsetX, offsetY) - pan
            // 3. scale(zoom, zoom)
            // 4. draw at (-w/2, -h/2)
            // So: canvasX = imageX * zoom + offsetX + w/2
            // Therefore: imageX = (canvasX - w/2 - offsetX) / zoom
            const imageX = (canvasX - w/2 - processedZoomOffsetX) / processedZoom;
            const imageY = (canvasY - h/2 - processedZoomOffsetY) / processedZoom;
            
            // Calculate new zoom level
            // For zoom out, limit to minimum zoom that doesn't show whitespace (image should fill at least the canvas)
            const minZoom = 1.0; // Don't zoom out past original size
            const newZoom = zoomMode === 'zoom-in' 
                ? Math.min(processedZoom * zoomFactor, 10)
                : Math.max(processedZoom / zoomFactor, minZoom);
            
            // Calculate new offset so the clicked image point stays at the same canvas position
            // After zoom: canvasX = imageX * newZoom + newOffsetX + w/2
            // So: newOffsetX = canvasX - w/2 - imageX * newZoom
            const newOffsetX = canvasX - w/2 - imageX * newZoom;
            const newOffsetY = canvasY - h/2 - imageY * newZoom;
            
            // Constrain offsets to prevent showing whitespace
            constrainPanBounds(newZoom);
            
            // Update zoom and offset
            processedZoom = newZoom;
            processedZoomOffsetX = newOffsetX;
            processedZoomOffsetY = newOffsetY;
            
            // Apply bounds again after setting
            constrainPanBounds(processedZoom);
            
            redrawProcessedCanvas();
        }
        
        function constrainPanBounds(zoom) {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            const w = processedCanvas.width;
            const h = processedCanvas.height;
            
            // Calculate the maximum allowed offset to keep image within bounds
            // When zoomed, the image is scaled, so we need to prevent panning too far
            // Image is drawn at (-w/2, -h/2) with size (w, h) before transforms
            // After scale(zoom), the visible image size becomes w*zoom, h*zoom
            // We want to constrain so that image edges stay within canvas bounds
            
            // Maximum offset should keep the image edges visible
            // If zoom >= 1, we can pan more freely
            // If zoom < 1, we should limit panning to keep image centered
            if (zoom >= 1.0) {
                // When zoomed in, allow more panning
                const maxOffset = (w * zoom - w) / 2;
                processedZoomOffsetX = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetX));
                processedZoomOffsetY = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetY));
            } else {
                // When zoomed out, limit panning to keep image visible
                // At zoom 1.0, offset should be 0
                const maxOffset = w * (1 - zoom) / 2;
                processedZoomOffsetX = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetX));
                processedZoomOffsetY = Math.max(-maxOffset, Math.min(maxOffset, processedZoomOffsetY));
            }
        }

        function redrawProcessedCanvas() {
            if (!processedImageData) return;
            
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            const processedCtx = processedCanvas.getContext('2d');
            const pixelSize = selectedGridSize;
            
            // Create temp canvas at pixel size with current data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = pixelSize;
            tempCanvas.height = pixelSize;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(processedImageData, 0, 0);
            
            // Get display size (may be different from canvas internal size)
            const displayWidth = processedCanvas.width;
            const displayHeight = processedCanvas.height;
            
            // Clear and redraw with zoom
            processedCtx.clearRect(0, 0, displayWidth, displayHeight);
            
            if (processedZoom === 1.0 && processedZoomOffsetX === 0 && processedZoomOffsetY === 0) {
                // No zoom, just draw normally
                processedCtx.imageSmoothingEnabled = false;
                processedCtx.drawImage(tempCanvas, 0, 0, displayWidth, displayHeight);
            } else {
                // Draw with zoom and offset
                // The image is drawn centered, then scaled and translated
                processedCtx.save();
                // Translate to center, then apply offset, then scale
                processedCtx.translate(displayWidth / 2, displayHeight / 2);
                processedCtx.translate(processedZoomOffsetX, processedZoomOffsetY);
                processedCtx.scale(processedZoom, processedZoom);
                processedCtx.imageSmoothingEnabled = false;
                // Draw image centered at origin (before transforms)
                processedCtx.drawImage(tempCanvas, -displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                processedCtx.restore();
            }
        }

        // Paint pixel function with brush size support
        function paintPixelAt(clickX, clickY, processedCanvas) {
            if (!processedImageData) return false;
            
            const pixelSize = selectedGridSize;
            
            // Convert to pixel coordinates
            // Get the displayed size of the canvas (not internal resolution)
            const rect = processedCanvas.getBoundingClientRect();
            const displayedWidth = rect.width;
            const displayedHeight = rect.height;
            
            // Convert to pixel coordinates using displayed size
            const pixelX = Math.floor((clickX / displayedWidth) * pixelSize);
            const pixelY = Math.floor((clickY / displayedHeight) * pixelSize);
            
            // Paint a brush area based on brush size
            // Brush size N paints an NxN square (N pixels wide, N pixels tall)
            // Size 1 = 1x1 (1 pixel), Size 2 = 2x2 (4 pixels), Size 3 = 3x3 (9 pixels), etc.
            let painted = false;
            
            // Calculate the start position (top-left corner of the square)
            // Center the brush on the click position
            const startX = pixelX - Math.floor(brushSize / 2);
            const startY = pixelY - Math.floor(brushSize / 2);
            
            // Paint all pixels in the NxN square
            for (let dy = 0; dy < brushSize; dy++) {
                for (let dx = 0; dx < brushSize; dx++) {
                    const x = startX + dx;
                    const y = startY + dy;
                    
                    // Ensure within bounds
                    if (x >= 0 && x < pixelSize && y >= 0 && y < pixelSize) {
                        // Update pixel color in image data
                        const index = (y * pixelSize + x) * 4;
                        processedImageData.data[index] = selectedPaintColor.r;     // R
                        processedImageData.data[index + 1] = selectedPaintColor.g; // G
                        processedImageData.data[index + 2] = selectedPaintColor.b; // B
                        processedImageData.data[index + 3] = 255;                  // A
                        painted = true;
                    }
                }
            }
            
            return painted;
        }

        // Add click and drag handlers to processed canvas for pixel painting
        let isPainting = false;
        
        // Set up paint event listeners (called after DOM loads and when canvas is recreated)
        function setupPaintHandlers() {
            const processedCanvas = document.getElementById('processed-canvas');
            if (!processedCanvas) return;
            
            // Use a flag to prevent duplicate listeners
            if (processedCanvas.dataset.paintHandlersSetup === 'true') return;
            processedCanvas.dataset.paintHandlersSetup = 'true';
            
            let isDraggingPan = false;
            
            processedCanvas.addEventListener('mousedown', (e) => {
                if (zoomMode === 'zoom-in') {
                    // Zoom in to the clicked point
                    zoomToPoint(e.clientX, e.clientY, 1.3);
                } else if (zoomMode === 'zoom-out') {
                    // Zoom out from the clicked point
                    zoomToPoint(e.clientX, e.clientY, 1.3);
                } else if (isPanningProcessed) {
                    // Start panning - store the initial mouse position and current offset
                    isDraggingPan = true;
                    processedPanStartX = e.clientX;
                    processedPanStartY = e.clientY;
                    const startOffsetX = processedZoomOffsetX;
                    const startOffsetY = processedZoomOffsetY;
                    
                    // Store start offsets in the event listener closure
                    processedCanvas.dataset.panStartOffsetX = startOffsetX;
                    processedCanvas.dataset.panStartOffsetY = startOffsetY;
                } else if (processedImageData && !isPanningProcessed) {
                    // Start painting (only if not in pan mode)
                    // Save state to undo stack before starting to paint
                    if (!isPainting) {
                        savePaintState();
                    }
                    isPainting = true;
                    const rect = processedCanvas.getBoundingClientRect();
                    
                    // Calculate click position in image space accounting for zoom and offset
                    // The image is drawn with transforms: translate(center) -> translate(offset) -> scale(zoom)
                    // So to reverse: get canvas coords, subtract center, subtract offset, divide by zoom
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    // Use displayed size, not internal canvas resolution
                    const w = rect.width;
                    const h = rect.height;
                    
                    // Convert to coordinates relative to center
                    const centerRelativeX = canvasX - w / 2;
                    const centerRelativeY = canvasY - h / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert to coordinates where image is drawn at (-w/2, -h/2) with size (w, h)
                    // So add w/2 and h/2 to get coordinates from 0 to w/h
                    const normalizedX = imageSpaceX + w / 2;
                    const normalizedY = imageSpaceY + h / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                }
            });
        
            processedCanvas.addEventListener('mousemove', (e) => {
                if (isPanningProcessed && isDraggingPan) {
                    // Pan the view - calculate delta from start position
                    const deltaX = e.clientX - processedPanStartX;
                    const deltaY = e.clientY - processedPanStartY;
                    const startOffsetX = parseFloat(processedCanvas.dataset.panStartOffsetX || 0);
                    const startOffsetY = parseFloat(processedCanvas.dataset.panStartOffsetY || 0);
                    
                    // Update offset based on drag delta
                    processedZoomOffsetX = startOffsetX + deltaX;
                    processedZoomOffsetY = startOffsetY + deltaY;
                    
                    // Constrain to bounds
                    constrainPanBounds(processedZoom);
                    
                    redrawProcessedCanvas();
                } else if (isPainting && processedImageData && !isPanningProcessed) {
                    // Continue painting (only if not in pan mode)
                    const rect = processedCanvas.getBoundingClientRect();
                    
                    // Calculate position in image space accounting for zoom and offset
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    // Use displayed size, not internal canvas resolution
                    const w = rect.width;
                    const h = rect.height;
                    
                    // Convert to coordinates relative to center
                    const centerRelativeX = canvasX - w / 2;
                    const centerRelativeY = canvasY - h / 2;
                    
                    // Apply inverse transform: subtract offset, then divide by zoom
                    const imageSpaceX = (centerRelativeX - processedZoomOffsetX) / processedZoom;
                    const imageSpaceY = (centerRelativeY - processedZoomOffsetY) / processedZoom;
                    
                    // Convert to coordinates where image is drawn at (-w/2, -h/2) with size (w, h)
                    const normalizedX = imageSpaceX + w / 2;
                    const normalizedY = imageSpaceY + h / 2;
                    
                    if (paintPixelAt(normalizedX, normalizedY, processedCanvas)) {
                        redrawProcessedCanvas();
                    }
                }
            });
            
            processedCanvas.addEventListener('mouseup', () => {
                if (isPainting) {
                    // Paint stroke finished - update undo/redo buttons
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
            
            processedCanvas.addEventListener('mouseleave', () => {
                if (isPainting) {
                    // Paint stroke finished - update undo/redo buttons
                    updateUndoRedoButtons();
                }
                isPainting = false;
                isDraggingPan = false;
            });
        }
        
        // Call setup when page loads
        // Detect Shopify embedded context and lock scrolling
        (function() {
            // Check if we're in an iframe (Shopify embedded)
            const isInIframe = window.self !== window.top;
            // Check if Shopify context is detected
            const isShopifyContext = window.Shopify || window.parent.Shopify || 
                                    window.location.search.includes('shopify') ||
                                    window.location.hostname.includes('myshopify.com');
            
            if (isInIframe || isShopifyContext) {
                document.documentElement.classList.add('shopify-embedded');
                document.body.classList.add('shopify-embedded');
                const mainContainer = document.querySelector('.main-container');
                if (mainContainer) {
                    mainContainer.classList.add('shopify-embedded');
                }
                const viewerPanel = document.querySelector('.viewer-panel');
                if (viewerPanel) {
                    viewerPanel.classList.add('shopify-embedded');
                }
                const controlPanel = document.querySelector('.control-panel');
                if (controlPanel) {
                    controlPanel.classList.add('shopify-embedded');
                }
                const editorPanel = document.querySelector('#editor-panel');
                if (editorPanel) {
                    editorPanel.classList.add('shopify-embedded');
                }
                // Lock scrolling - prevent free scrolling
                document.body.style.overflow = 'hidden';
                document.documentElement.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                document.body.style.height = '100vh';
            }
        })();

        window.addEventListener('load', () => {
            setupPaintHandlers();
            
            // Deactivate zoom/pan modes when clicking outside the canvas or buttons
            document.addEventListener('click', (e) => {
                const processedCanvas = document.getElementById('processed-canvas');
                const zoomInBtn = document.querySelector('[onclick="zoomInProcessed()"]');
                const zoomOutBtn = document.querySelector('[onclick="zoomOutProcessed()"]');
                const panBtn = document.getElementById('processed-pan-btn');
                const resetBtn = document.querySelector('[onclick="resetZoomProcessed()"]');
                
                // Check if click is outside canvas and outside all zoom/pan buttons
                const isClickOnCanvas = processedCanvas && processedCanvas.contains(e.target);
                const isClickOnZoomIn = zoomInBtn && (zoomInBtn.contains(e.target) || zoomInBtn === e.target);
                const isClickOnZoomOut = zoomOutBtn && (zoomOutBtn.contains(e.target) || zoomOutBtn === e.target);
                const isClickOnPan = panBtn && (panBtn.contains(e.target) || panBtn === e.target);
                const isClickOnReset = resetBtn && (resetBtn.contains(e.target) || resetBtn === e.target);
                
                // If click is outside all these elements, deactivate modes
                if (!isClickOnCanvas && !isClickOnZoomIn && !isClickOnZoomOut && !isClickOnPan && !isClickOnReset) {
                    deactivateZoomPanModes();
                }
            });
        });

        // Brush size slider
        document.getElementById('brush-size-slider').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brush-size-value').textContent = brushSize;
        });

        // Reset processed image to original state
        function resetProcessedImage() {
            if (!originalProcessedImageData) {
                console.log('No original image data to reset to');
                return;
            }
            
            // Restore the original image data
            processedImageData = new ImageData(
                new Uint8ClampedArray(originalProcessedImageData.data),
                originalProcessedImageData.width,
                originalProcessedImageData.height
            );
            
            // Redraw the canvas
            redrawProcessedCanvas();
            
            // Clear undo/redo stacks on reset
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
            
            console.log('‚úÖ Image reset to original state');
        }

        // Save current paint state to undo stack
        function savePaintState() {
            if (!processedImageData) return;
            
            // Create a deep copy of the current image data
            const stateCopy = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            
            // Save to undo stack
            undoStack.push(stateCopy);
            
            // Clear redo stack when new paint happens
            redoStack = [];
            
            // Limit undo stack size to prevent memory issues (keep last 50 states)
            if (undoStack.length > 50) {
                undoStack.shift();
            }
            
            // Show undo/redo buttons
            document.getElementById('undo-redo-buttons').style.display = 'flex';
            updateUndoRedoButtons();
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const undoRedoContainer = document.getElementById('undo-redo-buttons');
            
            if (!undoBtn || !redoBtn || !undoRedoContainer) return;
            
            if (undoStack.length === 0 && redoStack.length === 0) {
                // Hide buttons if no history
                undoRedoContainer.style.display = 'none';
            } else {
                // Show buttons if there's history
                undoRedoContainer.style.display = 'flex';
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
        }

        // Undo last paint operation
        function undoPaint() {
            if (undoStack.length === 0 || !processedImageData) return;
            
            // Save current state to redo stack before undoing
            const currentState = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            redoStack.push(currentState);
            
            // Restore previous state from undo stack
            const previousState = undoStack.pop();
            processedImageData = new ImageData(
                new Uint8ClampedArray(previousState.data),
                previousState.width,
                previousState.height
            );
            
            // Redraw canvas
            redrawProcessedCanvas();
            
            // Update button states
            updateUndoRedoButtons();
        }

        // Redo last undone paint operation
        function redoPaint() {
            if (redoStack.length === 0 || !processedImageData) return;
            
            // Save current state to undo stack before redoing
            const currentState = new ImageData(
                new Uint8ClampedArray(processedImageData.data),
                processedImageData.width,
                processedImageData.height
            );
            undoStack.push(currentState);
            
            // Restore next state from redo stack
            const nextState = redoStack.pop();
            processedImageData = new ImageData(
                new Uint8ClampedArray(nextState.data),
                nextState.width,
                nextState.height
            );
            
            // Redraw canvas
            redrawProcessedCanvas();
            
            // Update button states
            updateUndoRedoButtons();
        }

        // Keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            // Check if we're in the editor panel (painting is active)
            const editorPanel = document.getElementById('editor-panel');
            if (!editorPanel || editorPanel.style.display === 'none') return;
            
            // Check if user is typing in an input field (don't intercept)
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                return;
            }
            
            // Cmd+Z (Mac) or Ctrl+Z (Windows/Linux) for undo
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoPaint();
            }
            
            // Cmd+Shift+Z (Mac) or Ctrl+Y (Windows/Linux) for redo
            if ((e.metaKey && e.shiftKey && e.key === 'z') || (e.ctrlKey && e.key === 'y')) {
                e.preventDefault();
                redoPaint();
            }
        });

        // Slider event listeners
        document.getElementById('contrast-slider').addEventListener('input', (e) => {
            editorSettings.contrast = parseFloat(e.target.value);
            document.getElementById('contrast-value').textContent = e.target.value;
            processImage();
        });

        document.getElementById('brightness-slider').addEventListener('input', (e) => {
            editorSettings.brightness = parseFloat(e.target.value);
            document.getElementById('brightness-value').textContent = e.target.value;
            processImage();
        });

        document.getElementById('tones-slider').addEventListener('input', (e) => {
            editorSettings.tones = parseInt(e.target.value);
            document.getElementById('tones-value').textContent = `${editorSettings.tones}`;
            processImage();
        });

        // Initialize Three.js
        function initThree() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfafafa);
            
            // Add lights to show geometry details and textures
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft overall lighting
            scene.add(ambientLight);
            
            // Main directional light from above-left
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(50, 100, 50);
            directionalLight1.castShadow = false;
            scene.add(directionalLight1);
            
            // Secondary directional light from opposite side for fill
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-50, 50, -50);
            directionalLight2.castShadow = false;
            scene.add(directionalLight2);

            // Camera
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(100, 100, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width || window.innerWidth, height || 600, true);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Grid
            const gridHelper = new THREE.GridHelper(200, 20, 0xcccccc, 0xe0e0e0);
            scene.add(gridHelper);

            // Animate
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                const w = container.clientWidth || window.innerWidth;
                const h = container.clientHeight || window.innerHeight - 200;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h, true);
            });
        }

        // Auto tune contrast/brightness using percentile stretch (P5..P95)
        function autoTuneSettingsFromImage(img) {
            try {
                const tmp = document.createElement('canvas');
                const s = 128;
                tmp.width = s; tmp.height = s;
                const ctx = tmp.getContext('2d');
                ctx.drawImage(img, 0, 0, s, s);
                const d = ctx.getImageData(0, 0, s, s).data;
                const values = [];
                for (let i = 0; i < d.length; i += 4) {
                    values.push(0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]);
                }
                values.sort((a,b)=>a-b);
                const q = (p)=> values[Math.max(0, Math.min(values.length-1, Math.floor(p*(values.length-1))))];
                const p5 = q(0.05);
                const p95 = q(0.95);
                editorSettings.blackPoint = Math.max(0, Math.min(254, Math.round(p5)));
                editorSettings.whitePoint = Math.max(editorSettings.blackPoint+1, Math.min(255, Math.round(p95)));
                // Keep C/B neutral post stretch
                editorSettings.contrast = 1.0;
                editorSettings.brightness = 1.0;
                saveSimpleState();
            } catch (e) {
                editorSettings.blackPoint = 0;
                editorSettings.whitePoint = 255;
                editorSettings.contrast = 1.0;
                editorSettings.brightness = 1.0;
            }
        }

        // Load STL file
        function loadSTL(file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const loader = new THREE.STLLoader();
                let geometry = loader.parse(event.target.result);

                // Ensure per-triangle unique vertices so colors don't bleed across shared vertices
                if (geometry.index) {
                    geometry = geometry.toNonIndexed();
                }

                // Store original geometry
                originalGeometry = geometry.clone();

                // Remove old mesh
                if (currentMesh) {
                    scene.remove(currentMesh);
                }

                // Create new mesh with lit material to show geometry details (bumps, cubes, textures)
                // Use MeshStandardMaterial for realistic lighting that shows surface details
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff, // base white so vertex colors show true values
                    vertexColors: true, // Enable vertex colors for the painted image
                    side: THREE.DoubleSide,
                    flatShading: false, // Use smooth shading to show geometry details
                    metalness: 0.1, // Slight metalness for better detail visibility
                    roughness: 0.7 // Moderate roughness to catch light on surface details
                });
                currentMesh = new THREE.Mesh(geometry, material);

                // Center the mesh
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                currentMesh.position.sub(center);

                scene.add(currentMesh);

                // Hide placeholder
                document.getElementById('three-placeholder').style.display = 'none';

                // Fit camera
                const box = new THREE.Box3().setFromObject(currentMesh);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim, maxDim, maxDim);
                controls.target.set(0, 0, 0);
                controls.update();

                // Apply colors if PNG is already loaded
                if (pngImage) {
                    applyColorsToMesh();
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Apply PNG colors to the 3D mesh
        function applyColorsToMesh() {
            if (!currentMesh || !pngImage || !originalGeometry) return;

            console.log('Applying colors to mesh...');

            const geometry = currentMesh.geometry;
            const positions = geometry.attributes.position;
            const vertices = [];
            
            // Get all vertices
            for (let i = 0; i < positions.count; i++) {
                vertices.push(new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                ));
            }

            // Compute XY bounds based ONLY on near-horizontal (top) faces to avoid side thickness skew
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const faceCount = positions.count / 3;
            for (let f = 0; f < faceCount; f++) {
                const a = f * 3, b = a + 1, c = a + 2;
                const v0 = vertices[a], v1 = vertices[b], v2 = vertices[c];
                // Face normal
                const abx = v1.x - v0.x, aby = v1.y - v0.y, abz = v1.z - v0.z;
                const acx = v2.x - v0.x, acy = v2.y - v0.y, acz = v2.z - v0.z;
                const nx = aby * acz - abz * acy;
                const ny = abz * acx - abx * acz;
                const nz = abx * acy - aby * acx;
                const len = Math.hypot(nx, ny, nz) || 1;
                const nzUnit = nz / len;
                if (nzUnit > 0.5) { // top-ish
                    minX = Math.min(minX, v0.x, v1.x, v2.x);
                    minY = Math.min(minY, v0.y, v1.y, v2.y);
                    maxX = Math.max(maxX, v0.x, v1.x, v2.x);
                    maxY = Math.max(maxY, v0.y, v1.y, v2.y);
                }
            }
            if (!isFinite(minX) || !isFinite(minY)) {
                // Fallback to bbox if no top faces detected
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                minX = bbox.min.x; minY = bbox.min.y; maxX = bbox.max.x; maxY = bbox.max.y;
            }
            const sizeX = Math.max(1e-9, maxX - minX);
            const sizeY = Math.max(1e-9, maxY - minY);

            // Create canvas to read pixel data
            const canvas = document.createElement('canvas');
            canvas.width = pngImage.width;
            canvas.height = pngImage.height;
            const ctx = canvas.getContext('2d');
            
            // Ensure image is fully loaded and not tainted
            if (!pngImage.complete || pngImage.naturalWidth === 0) {
                console.error('Image not fully loaded');
                return;
            }
            
            let imageData;
            try {
                ctx.drawImage(pngImage, 0, 0);
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Verify image data is valid
                if (!imageData || !imageData.data || imageData.data.length === 0) {
                    console.error('Failed to get image data from canvas');
                    return;
                }
            } catch (error) {
                console.error('Canvas security error or image read error:', error);
                return;
            }

            // Create color array for each face (triangle)
            const numFaces = positions.count / 3;
            const colors = new Float32Array(positions.count * 3);

            for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
                const i0 = faceIndex * 3;
                const i1 = faceIndex * 3 + 1;
                const i2 = faceIndex * 3 + 2;

                // Get triangle centroid
                const v0 = vertices[i0];
                const v1 = vertices[i1];
                const v2 = vertices[i2];
                
                const cx = (v0.x + v1.x + v2.x) / 3;
                const cy = (v0.y + v1.y + v2.y) / 3;
                
                // DIRECT 1:1 MAPPING OVERRIDE - Force perfect grid cell to pixel mapping
                const u = Math.max(0, Math.min(0.999999, (cx - minX) / sizeX));
                const v = Math.max(0, Math.min(0.999999, (cy - minY) / sizeY));
                const grid = selectedGridSize || pngImage?.width || 75;
                
                // Direct mapping: Map normalized coords directly to grid cell index
                let cell_x = Math.floor(u * grid);
                let cell_y = Math.floor(v * grid);
                
                // Clamp to valid grid range
                cell_x = Math.max(0, Math.min(grid - 1, cell_x));
                cell_y = Math.max(0, Math.min(grid - 1, cell_y));
                
                // OVERRIDE: Direct cell-to-pixel mapping (no complex calculations)
                let px, py;
                if (grid === pngImage.width) {
                    // Perfect 1:1 mapping when grid matches image size
                    px = cell_x;
                    py = grid - 1 - cell_y; // Flip Y axis
                } else {
                    // Fallback: Scale cell index to pixel index
                    px = Math.floor((cell_x * pngImage.width) / grid);
                    py = Math.floor(((grid - 1 - cell_y) * pngImage.height) / grid);
                }
                
                // Final clamp to valid pixel range
                px = Math.max(0, Math.min(pngImage.width - 1, px));
                py = Math.max(0, Math.min(pngImage.height - 1, py));

                // Get pixel color
                const pixelIndex = (py * pngImage.width + px) * 4;
                const r = imageData.data[pixelIndex] / 255;
                const g = imageData.data[pixelIndex + 1] / 255;
                const b = imageData.data[pixelIndex + 2] / 255;

                // Apply color to all 3 vertices of this triangle
                for (let j = 0; j < 3; j++) {
                    const vertexIndex = (i0 + j) * 3;
                    colors[vertexIndex] = r;
                    colors[vertexIndex + 1] = g;
                    colors[vertexIndex + 2] = b;
                }
            }

            // Apply colors to geometry
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Update material to use vertex colors
            currentMesh.material.vertexColors = true;
            currentMesh.material.needsUpdate = true;
            // Keep smooth shading to show geometry details (bumps, cubes, textures)
            // The geometry itself has the detail - lighting will show it naturally
            if ('flatShading' in currentMesh.material) {
                currentMesh.material.flatShading = false; // Smooth shading shows surface details better
            }
            // Ensure normals are computed for proper lighting
            geometry.computeVertexNormals();
            geometry.attributes.color.needsUpdate = true;

            console.log('Colors applied successfully!');
        }

        function resetCamera() {
            if (currentMesh) {
                const box = new THREE.Box3().setFromObject(currentMesh);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim, maxDim, maxDim);
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        function toggleWireframe() {
            if (currentMesh) {
                currentMesh.material.wireframe = !currentMesh.material.wireframe;
            }
        }

        // File upload handlers
        // Load STL from server based on grid size (auto-load, no user upload)
        async function loadSTLFromServer(size) {
            try {
                console.log(`üì¶ Loading STL for ${size}√ó${size} grid from admin server...`);
                const url = getApiUrl(`/get-stl/${size}`);
                console.log(`üîó Loading STL from: ${url}`);
                if (typeof BACKEND_URL !== 'undefined') {
                    console.log(`üåê Backend URL: ${BACKEND_URL}`);
                }
                
                const response = await fetch(url, {
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (!response.ok) {
                    let errorText = '';
                    try {
                        errorText = await response.text();
                        // Try to parse as JSON for better error message
                        try {
                            const errorJson = JSON.parse(errorText);
                            errorText = errorJson.error || errorText;
                        } catch (e) {
                            // Not JSON, use as-is
                        }
                    } catch (e) {
                        errorText = 'Could not read error response';
                    }
                    
                    const backendUrl = typeof BACKEND_URL !== 'undefined' ? BACKEND_URL : 'Not configured';
                    const errorMsg = `Failed to load STL file for ${size}√ó${size} grid.\n\n` +
                        `Backend URL: ${backendUrl}\n` +
                        `Request URL: ${url}\n` +
                        `Status: ${response.status} ${response.statusText}\n` +
                        `Error: ${errorText}\n\n` +
                        `Please ensure:\n` +
                        `1. Backend server is running\n` +
                        `2. STL file is uploaded via admin panel\n` +
                        `3. Backend URL is correct in the code`;
                    
                    console.error(`‚ùå Failed to load STL for size ${size}:`);
                    console.error(`   Status: ${response.status} ${response.statusText}`);
                    console.error(`   URL: ${url}`);
                    if (typeof BACKEND_URL !== 'undefined') {
                        console.error(`   Backend: ${BACKEND_URL}`);
                    }
                    console.error(`   Error: ${errorText}`);
                    
                    stlFile = null;
                    alert(errorMsg);
                    return;
                }
                
                const blob = await response.blob();
                if (blob.size === 0) {
                    const backendUrl = typeof BACKEND_URL !== 'undefined' ? BACKEND_URL : 'Not configured';
                    const errorMsg = `STL file is empty for ${size}√ó${size} grid.\n\n` +
                        `Backend URL: ${backendUrl}\n` +
                        `Request URL: ${url}\n` +
                        `Please re-upload the STL file via admin panel.`;
                    console.error(`‚ùå Received empty STL file for size ${size}`);
                    alert(errorMsg);
                    stlFile = null;
                    return;
                }
                
                stlFile = new File([blob], `${size}x${size}_grid.stl`, { type: 'application/octet-stream' });
                console.log(`‚úÖ Received STL file: ${stlFile.name} (${(blob.size / 1024).toFixed(2)} KB)`);
                
                // STL upload UI removed - STL files auto-load from server
                // Save to IndexedDB for caching
                saveFileToDB(dbKey('stl', size), stlFile);
                
                loadSTL(stlFile);
                console.log(`‚úÖ Successfully loaded and displayed STL for ${size}√ó${size} grid from admin`);
            } catch (error) {
                console.error('‚ùå Error loading STL from server:');
                console.error('   Error:', error.message);
                if (error.url) console.error('   URL:', error.url);
                if (error.backendUrl) console.error('   Backend:', error.backendUrl);
                if (error.status) console.error('   Status:', error.status);
                
                const backendUrl = typeof BACKEND_URL !== 'undefined' ? BACKEND_URL : 'Not configured';
                const errorMsg = error.message || 
                    `Failed to load STL file for ${size}√ó${size} grid.\n\n` +
                    `Backend URL: ${backendUrl}\n\n` +
                    `Please ensure:\n` +
                    `1. Backend server is running\n` +
                    `2. STL file is uploaded via admin panel\n` +
                    `3. Check browser console for details`;
                alert(errorMsg);
                stlFile = null;
            }
        }

        // STL file upload event listener (removed - STL upload section removed from UI)
        // STL files now auto-load from server based on grid size

        // Setup PNG input event listener when DOM is ready
        function setupPNGInput() {
            const pngInput = document.getElementById('png-input');
            if (!pngInput) {
                console.error('‚ùå png-input element not found, retrying...');
                // Try again after a short delay
                setTimeout(setupPNGInput, 100);
                return;
            }
            
            console.log('‚úÖ Setting up PNG input handler');
            console.log('‚úÖ Input element found:', pngInput.id, pngInput.type, pngInput.accept);
            
            // Remove existing listener if any, then add new one
            const newHandler = async function(e) {
                console.log('üìÅ CHANGE EVENT FIRED - File input changed');
                console.log('üìÅ Files:', e.target.files);
                console.log('üìÅ File selected:', e.target.files[0]?.name, 'Size:', e.target.files[0]?.size, 'Type:', e.target.files[0]?.type);
                
                // Check if change event actually fired with a file
                if (!e || !e.target) {
                    const errorMsg = 'Error: File input change event did not fire properly';
                    console.error('‚ùå', errorMsg);
                    if (typeof showStatus === 'function') {
                        showStatus('error', errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    return;
                }
                
                if (!e.target.files || !e.target.files[0]) {
                    const errorMsg = 'Error: Could not read selected file. Please try selecting the file again.';
                    console.error('‚ùå', errorMsg);
                    console.warn('‚ö†Ô∏è Files array:', e.target.files);
                    console.warn('‚ö†Ô∏è Files length:', e.target.files?.length);
                    if (typeof showStatus === 'function') {
                        showStatus('error', errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    return;
                }
                
                // Store reference to input for later reset
                const inputElement = e.target;
                
                try {
                    await handlePNGInput(e);
                    // Only reset input value AFTER successful processing and display
                    // This allows the same file to be selected again if needed
                    inputElement.value = '';
                    console.log('‚úÖ File input value reset after successful upload');
                } catch (error) {
                    console.error('‚ùå Error in handlePNGInput:', error);
                    console.error('‚ùå Error stack:', error.stack);
                    const errorMsg = `Error processing image: ${error.message || 'Unknown error occurred'}`;
                    if (typeof showStatus === 'function') {
                        showStatus('error', errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    // Reset input on error so user can try again
                    inputElement.value = '';
                }
            };
            
            // Store handler reference for removal
            if (pngInput._changeHandler) {
                console.log('üîÑ Removing existing change handler');
                pngInput.removeEventListener('change', pngInput._changeHandler);
            }
            pngInput._changeHandler = newHandler;
            pngInput.addEventListener('change', newHandler);
            
            // Verify handler was attached
            console.log('‚úÖ Change event handler attached to png-input');
            console.log('‚úÖ Handler reference stored:', !!pngInput._changeHandler);
            
            // Note: Label with for="png-input" should work naturally, no need for extra click handler
            // The label's for attribute will automatically trigger the input click
        }
        
        async function handlePNGInput(e) {
            console.log('üîÑ handlePNGInput called');
            console.log('üîÑ Event:', e);
            console.log('üîÑ Event target:', e.target);
            console.log('üîÑ Event target files:', e.target.files);
            
            const file = e.target.files[0];
            if (!file) {
                const errorMsg = 'Error: No file selected. Please select a file to upload.';
                console.error('‚ùå', errorMsg);
                console.warn('‚ö†Ô∏è Files array:', e.target.files);
                console.warn('‚ö†Ô∏è Files length:', e.target.files?.length);
                if (typeof showStatus === 'function') {
                    showStatus('error', errorMsg);
                } else {
                    alert(errorMsg);
                }
                throw new Error(errorMsg);
            }
            
            console.log('üìÑ Processing file:', file.name, 'Size:', file.size, 'Type:', file.type);
            console.log('üìÑ File object:', file);
            
            pngFile = file;
            const uploadArea = document.getElementById('png-upload-area');
            const uploadText = document.getElementById('png-upload-text');
            
            if (uploadArea) {
                uploadArea.classList.add('has-file');
            }
            if (uploadText) {
                uploadText.textContent = file.name;
            }
            
            let fileToProcess = file;
            
            // Check if file is HEIC/HEIF and convert it
            const fileExtension = file.name.toLowerCase().split('.').pop();
            const isHeic = fileExtension === 'heic' || fileExtension === 'heif' || 
                           file.type === 'image/heic' || file.type === 'image/heif';
                
            if (isHeic && typeof heic2any !== 'undefined') {
                try {
                    showStatus('loading', 'Converting HEIC image...');
                    // Convert HEIC to JPEG
                    const convertedBlob = await heic2any({
                        blob: file,
                        toType: 'image/jpeg',
                        quality: 0.92
                    });
                    // heic2any returns an array, take the first element
                    const convertedFile = convertedBlob instanceof Array ? convertedBlob[0] : convertedBlob;
                    // Create a new File object with the converted blob
                    fileToProcess = new File([convertedFile], file.name.replace(/\.(heic|heif)$/i, '.jpg'), { 
                        type: 'image/jpeg' 
                    });
                    showStatus('success', 'HEIC image converted successfully');
                } catch (error) {
                    console.error('HEIC conversion error:', error);
                    showStatus('error', 'Failed to convert HEIC image. Please try a different format.');
                    return;
                }
            }
            
            // Load image and show preview
            console.log('üìñ Reading file with FileReader...');
            console.log('üìñ File to process:', fileToProcess.name, fileToProcess.size, fileToProcess.type);
            
            try {
                const reader = new FileReader();
                
                reader.onerror = (error) => {
                    const errorMsg = 'Error: Could not read file. The file may be corrupted or inaccessible. Please try selecting a different file.';
                    console.error('‚ùå FileReader error:', error);
                    console.error('‚ùå FileReader error event:', error);
                    console.error('‚ùå FileReader readyState:', reader.readyState);
                    if (typeof showStatus === 'function') {
                        showStatus('error', errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    throw new Error(errorMsg);
                };
                
                reader.onloadstart = () => {
                    console.log('üìñ FileReader started reading file...');
                };
                
                reader.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const percentLoaded = Math.round((e.loaded / e.total) * 100);
                        console.log(`üìñ FileReader progress: ${percentLoaded}%`);
                    }
                };
                
                reader.onload = (event) => {
                    console.log('‚úÖ FileReader loaded successfully');
                    console.log('‚úÖ FileReader result length:', event.target.result?.length);
                    console.log('‚úÖ FileReader result type:', typeof event.target.result);
                    
                    try {
                        console.log('üñºÔ∏è Creating Image object...');
                        const img = new Image();
                        
                        img.onerror = (error) => {
                            const errorMsg = 'Error: Image failed to load. The file may be corrupted or in an unsupported format.';
                            console.error('‚ùå Image load error:', error);
                            console.error('‚ùå Image src attempted:', img.src?.substring(0, 50));
                            if (typeof showStatus === 'function') {
                                showStatus('error', errorMsg);
                            } else {
                                alert(errorMsg);
                            }
                            throw new Error(errorMsg);
                        };
                        
                        img.onload = () => {
                    console.log('‚úÖ Image loaded successfully, dimensions:', img.width, 'x', img.height);
                    rawUploadedImage = img; // Store raw image for editor
                    fullOriginalImage = img; // Store full original uncropped image
                    cropCoordinates = null; // Reset crop coordinates when new image is uploaded
                    
                    // Save image state immediately for persistence across views
                    try {
                        saveImageState(img, file);
                    } catch (saveError) {
                        console.warn('‚ö†Ô∏è Failed to save image state:', saveError);
                    }
                    
                    // Reset cropper state when new image is uploaded
                    fullProcessedImageDataURL = null;
                    cropperVisible = false;
                    cropperManuallyHidden = false; // Reset flag for new image
                    cropInitialized = false;
                    const previewImg = document.getElementById('png-preview-img');
                    if (previewImg) {
                        previewImg.removeAttribute('data-cropper-fixed');
                    }
                    document.getElementById('png-preview').style.display = 'none';
                    document.getElementById('crop-canvas').style.display = 'none';
                    document.getElementById('show-cropper-btn').style.display = 'block';
                    document.getElementById('hide-cropper-btn').style.display = 'none';
                    
                    // Show original image in editor
                    // Original image canvas removed - no longer needed
                    // Auto-tune settings per new image
                    autoTuneSettingsFromImage(img);
                    // Update sliders/labels
                    document.getElementById('contrast-slider').value = String(editorSettings.contrast);
                    document.getElementById('brightness-slider').value = String(editorSettings.brightness);
                    document.getElementById('contrast-value').textContent = editorSettings.contrast.toFixed(1);
                    document.getElementById('brightness-value').textContent = editorSettings.brightness.toFixed(1);
                    // Don't set preview image here - it will be set to processed version after processImage() runs
                    // document.getElementById('png-preview-img').src = event.target.result;
                    // Show crop buttons when image is uploaded
                    document.getElementById('crop-buttons').style.display = 'block';
                    // Don't show preview automatically - only show when "Show Cropper" is clicked
                    // document.getElementById('png-preview').style.display = 'block';
                    
                    // Ensure editor is visible so user can adjust before mapping
                    showEditorPanel();
                    processImage();
                    // Automatically show cropper after image is processed (with small delay to ensure processed canvas is ready)
                    // Only auto-show if user hasn't manually hidden it
                    if (!cropperManuallyHidden) {
                        setTimeout(() => {
                            showCropper();
                        }, 100);
                    }

                    // Persist converted file to IndexedDB for current grid size
                    try {
                        saveFileToDB(dbKey('png'), fileToProcess);
                    } catch (dbError) {
                        console.warn('‚ö†Ô∏è Failed to save to IndexedDB:', dbError);
                    }
                };
                
                console.log('üñºÔ∏è Setting image src from FileReader result...');
                img.src = event.target.result;
                console.log('üñºÔ∏è Image src set, waiting for load...');
                    } catch (imgError) {
                        const errorMsg = `Error: Failed to create image object - ${imgError.message || 'Unknown error'}`;
                        console.error('‚ùå Error creating Image object:', imgError);
                        console.error('‚ùå Error stack:', imgError.stack);
                        if (typeof showStatus === 'function') {
                            showStatus('error', errorMsg);
                        } else {
                            alert(errorMsg);
                        }
                        throw imgError; // Re-throw so caller knows it failed
                    }
                };
                
                console.log('üìñ Starting FileReader.readAsDataURL...');
                reader.readAsDataURL(fileToProcess);
                console.log('üìñ FileReader.readAsDataURL called');
            } catch (readerError) {
                const errorMsg = `Error: Failed to set up file reader - ${readerError.message || 'Unknown error'}`;
                console.error('‚ùå Error setting up FileReader:', readerError);
                console.error('‚ùå Error stack:', readerError.stack);
                if (typeof showStatus === 'function') {
                    showStatus('error', errorMsg);
                } else {
                    alert(errorMsg);
                }
                throw readerError; // Re-throw so caller knows it failed
            }
        }


        // TEST: Add to Cart / Purchase button - Creates order without redirecting
        function setupCartButtons() {
            const addToCartBtn = document.getElementById('add-to-cart-btn');
            const buyNowBtn = document.getElementById('buy-now-btn');
            
            if (addToCartBtn) {
                addToCartBtn.addEventListener('click', async () => {
                    if (!stlFile || !pngFile) {
                        alert('Please upload both STL and PNG files first');
                        return;
                    }

                    console.log('Adding to cart...');
                    const btn = document.getElementById('add-to-cart-btn');
                    const originalText = btn.textContent;
                    btn.disabled = true;
                    btn.textContent = 'Processing...';

                    try {
                        // Show Buy Now button if hidden
                        if (buyNowBtn && buyNowBtn.style.display === 'none') {
                            buyNowBtn.style.display = 'block';
                        }

                        // Use the exact same PNG that's displayed in the 3D view
                        // This ensures perfect alignment between 3D view and exported file
                        let processedPngFile = pngFile;
                        
                        // If pngFile doesn't exist yet (user hasn't viewed in 3D), generate it now
                        if (!processedPngFile && rawUploadedImage) {
                            await new Promise((resolve) => {
                                createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                                    processedPngFile = file;
                                    pngFile = file;
                                    pngImage = img;
                                    resolve();
                                });
                            });
                        }
                        
                        // Calculate total price
                        let totalPrice = 0;
                        if (prices && prices[`${selectedGridSize}x${selectedGridSize}`]) {
                            totalPrice += prices[`${selectedGridSize}x${selectedGridSize}`];
                        }
                        if (standSelected && prices && prices.stand) {
                            totalPrice += prices.stand;
                        }
                        if (selectedAddons.mounting && prices && prices.wall_mounting_dots) {
                            totalPrice += prices.wall_mounting_dots;
                        }

                        btn.textContent = 'Creating order...';
                        
                        // Generate and upload file for checkout
                        const formData = new FormData();
                        formData.append('stl', stlFile);
                        formData.append('png', processedPngFile);
                        formData.append('grid_size', String(selectedGridSize));
                        formData.append('stand_selected', String(standSelected));
                        formData.append('mounting_selected', String(selectedAddons.mounting));
                        formData.append('total_price', String(totalPrice));

                        const response = await fetch(getApiUrl('/upload-for-checkout'), {
                            method: 'POST',
                            body: formData
                        });

                        if (!response.ok) {
                            const error = await response.json().catch(() => ({ error: 'Failed to create order' }));
                            throw new Error(error.error || 'Failed to create order');
                        }

                        const result = await response.json();
                        const orderId = result.order_id;
                        
                        console.log('Order created:', orderId);
                        
                        // Check if we're in Shopify context and have cart service
                        const urlParams = new URLSearchParams(window.location.search);
                        const isShopifyContext = urlParams.get('shopify') === 'true' || 
                                                window.Shopify || 
                                                window.parent.Shopify ||
                                                window.location.hostname.includes('myshopify.com');
                        
                        if (isShopifyContext && shopifyCart) {
                            btn.textContent = 'Adding to cart...';
                            
                            try {
                                // Get variant ID for selected grid size
                                const variantId = shopifyVariants[selectedGridSize];
                                
                                if (!variantId) {
                                    throw new Error(`Variant ID not found for grid size ${selectedGridSize}. Please configure Shopify variants.`);
                                }
                                
                                // Prepare order data for cart
                                const orderData = {
                                    orderId: orderId,
                                    variantId: variantId,
                                    gridSize: selectedGridSize,
                                    standSelected: standSelected,
                                    standVariantId: shopifyVariants.stand,
                                    mountingSelected: selectedAddons.mounting,
                                    mountingVariantId: shopifyVariants.mounting
                                };
                                
                                // Add order to cart
                                await shopifyCart.addOrderToCart(orderData);
                                
                                console.log('‚úÖ Added to cart successfully');
                                
                                // Redirect to cart
                                shopifyCart.redirectToCart();
                                
                            } catch (cartError) {
                                console.error('Error adding to Shopify cart:', cartError);
                                showStatus('error', `‚ö†Ô∏è Added to cart failed: ${cartError.message}`);
                                btn.textContent = originalText;
                                btn.disabled = false;
                            }
                        } else {
                            // Not in Shopify context, show success message
                            showStatus('success', `‚úÖ Order created! Order ID: ${orderId.substring(0, 8)}`);
                            btn.textContent = originalText;
                            btn.disabled = false;
                        }

                    } catch (error) {
                        console.error('Add to cart error:', error);
                        showStatus('error', `‚ùå Error: ${error.message}`);
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }
                });
            }
            
            // Buy Now - Generate file and redirect to Shopify
            if (buyNowBtn) {
                buyNowBtn.addEventListener('click', async () => {
                    if (!stlFile || !pngFile) return;

                    console.log('Proceeding to checkout...');
                    showStatus('loading', '<span class="spinner"></span>Preparing your order...');
                    document.getElementById('buy-now-btn').disabled = true;

                    try {
                        // Use the exact same PNG that's displayed in the 3D view
                        // This ensures perfect alignment between 3D view and exported file
                        let processedPngFile = pngFile;
                        
                        // If pngFile doesn't exist yet (user hasn't viewed in 3D), generate it now
                        if (!processedPngFile && rawUploadedImage) {
                            await new Promise((resolve) => {
                                createProcessedImageAtSize(rawUploadedImage, selectedGridSize, (file, img) => {
                                    processedPngFile = file;
                                    pngFile = file;
                                    pngImage = img;
                                    resolve();
                                });
                            });
                        }
                        
                        // Generate and upload file for checkout
                        const formData = new FormData();
                        formData.append('stl', stlFile);
                        formData.append('png', processedPngFile);
                        formData.append('grid_size', String(selectedGridSize));
                        formData.append('stand_selected', String(standSelected));
                        formData.append('mounting_selected', String(selectedAddons.mounting));
                        
                        // Calculate total price
                        let totalPrice = 0;
                        if (prices && prices[`${selectedGridSize}x${selectedGridSize}`]) {
                            totalPrice += prices[`${selectedGridSize}x${selectedGridSize}`];
                        }
                        if (standSelected && prices && prices.stand) {
                            totalPrice += prices.stand;
                        }
                        if (selectedAddons.mounting && prices && prices.wall_mounting_dots) {
                            totalPrice += prices.wall_mounting_dots;
                        }
                        formData.append('total_price', String(totalPrice));

                        const response = await fetch(getApiUrl('/upload-for-checkout'), {
                            method: 'POST',
                            body: formData
                        });

                        if (!response.ok) {
                            const error = await response.json().catch(() => ({ error: 'Failed to prepare order' }));
                            throw new Error(error.error || 'Failed to prepare order');
                        }

                        const result = await response.json();
                        const orderId = result.order_id;
                        
                        console.log('Order ID:', orderId);
                        
                        // Check if we're in Shopify context and have cart service
                        const isShopifyContext = urlParams.get('shopify') === 'true';
                        
                        if (isShopifyContext && shopifyCart) {
                            // Add to Shopify cart using Cart API
                            try {
                                // Get variant ID for selected grid size
                                const variantId = shopifyVariants[selectedGridSize];
                                
                                if (!variantId) {
                                    throw new Error(`Variant ID not found for grid size ${selectedGridSize}. Please configure Shopify variants.`);
                                }
                                
                                // Prepare order data for cart
                                const orderData = {
                                    orderId: orderId,
                                    variantId: variantId,
                                    gridSize: selectedGridSize,
                                    standSelected: standSelected,
                                    standVariantId: shopifyVariants.stand,
                                    mountingSelected: selectedAddons.mounting,
                                    mountingVariantId: shopifyVariants.mounting
                                };
                                
                                // Add order to cart
                                await shopifyCart.addOrderToCart(orderData);
                                
                                // Redirect to checkout (Buy Now goes directly to checkout)
                                window.location.href = `${shopifyCart.cartUrl.replace('/cart', '/checkout')}`;
                                
                            } catch (cartError) {
                                console.error('Error adding to Shopify cart:', cartError);
                                // Fallback: redirect to product page with order ID
                                showStatus('error', `‚ö†Ô∏è Added to cart failed: ${cartError.message}. Redirecting to product page...`);
                                setTimeout(() => {
                                    const shopifyUrl = `${SHOPIFY_PRODUCT_URL}?order_id=${orderId}`;
                                    window.location.href = shopifyUrl;
                                }, 2000);
                            }
                        } else {
                            // Not in Shopify context, use fallback redirect
                            const shopifyUrl = `${SHOPIFY_PRODUCT_URL}?order_id=${orderId}`;
                            window.location.href = shopifyUrl;
                        }

                    } catch (error) {
                        console.error('Checkout error:', error);
                        showStatus('error', `‚ùå Error: ${error.message}`);
                        document.getElementById('buy-now-btn').disabled = false;
                    }
                });
            }
        }

        function showStatus(type, message) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.className = `status-message ${type}`;
            statusMessage.innerHTML = message;
            statusMessage.style.display = 'block';

            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 5000);
            }
        }

        // Initialize Three.js when page loads
        window.addEventListener('load', initThree);

        // Restore state and files on load; start with editor visible
        window.addEventListener('load', async () => {
            // Don't restore image state on page load - always start fresh
            // This ensures users always see the upload area when they first visit
            // console.log('üìÇ Checking for saved image state on page load...');
            // const hasRestoredImage = restoreImageState();
            // if (hasRestoredImage) {
            //     console.log('‚úÖ Image state restored from previous session');
            //     // Still load simple state for grid size etc
            //     loadSimpleState();
            //     return;
            // }
            
            loadSimpleState();
            
            // Explicitly ensure rawUploadedImage is null on page load
            // This ensures the upload area is always visible on fresh page load
            rawUploadedImage = null;
            pngFile = null;
            
            // Clear any saved image state from localStorage to prevent restoration
            // This ensures we always start fresh
            try {
                localStorage.removeItem('uploadedImageState');
                console.log('‚úÖ Cleared saved image state from localStorage');
            } catch (e) {
                console.warn('‚ö†Ô∏è Could not clear localStorage:', e);
            }

            // Reflect selected grid size buttons
            document.querySelectorAll('.grid-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.size) === selectedGridSize) {
                    btn.classList.add('active');
                }
            });
            
            // Ensure controls are positioned correctly on initial load
            setTimeout(() => {
                positionControls();
            }, 100);
            document.getElementById('png-upload-subtext').textContent = `Will be resized to ${selectedGridSize}√ó${selectedGridSize} pixels`;

            // Load prices from API
            await loadPrices();

            // Setup PNG input event listener
            setupPNGInput();
            
            // Setup cart buttons
            setupCartButtons();

            // Show editor by default but don't restore files on page load
            // Always start fresh - user should upload a new image
            showEditorPanel();
            // await restoreForSize(selectedGridSize);
            
            // Load STL for selected grid size
            await loadSTLFromServer(selectedGridSize);
            
            // Setup paint handlers after everything is loaded
            setTimeout(() => {
                setupPaintHandlers();
            }, 500);
            
            // Add scroll listener for viewer controls positioning
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    updateViewerControlsPosition();
                }, 10);
            }, { passive: true });
            
            // Also update on resize
            window.addEventListener('resize', () => {
                updateViewerControlsPosition();
            }, { passive: true });
        });
    </script>
</body>
</html>
